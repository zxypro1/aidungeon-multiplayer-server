"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.o = exports.c = exports.a = exports._ = void 0;
(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload"))
    return; for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
    o(r); new MutationObserver(r => { for (const s of r)
    if (s.type === "childList")
        for (const l of s.addedNodes)
            l.tagName === "LINK" && l.rel === "modulepreload" && o(l); }).observe(document, { childList: !0, subtree: !0 }); function n(r) { const s = {}; return r.integrity && (s.integrity = r.integrity), r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s; } function o(r) { if (r.ep)
    return; r.ep = !0; const s = n(r); fetch(r.href, s); } })();
function vp(e, t) { const n = Object.create(null), o = e.split(","); for (let r = 0; r < o.length; r++)
    n[o[r]] = !0; return t ? r => !!n[r.toLowerCase()] : r => !!n[r]; }
const vn = {}, dl = [], Wt = () => { }, r_ = () => !1, s_ = /^on[^a-z]/, lc = e => s_.test(e), mp = e => e.startsWith("onUpdate:"), Cn = Object.assign, gp = (e, t) => { const n = e.indexOf(t); n > -1 && e.splice(n, 1); }, l_ = Object.prototype.hasOwnProperty, Tt = (e, t) => l_.call(e, t), qe = Array.isArray, fl = e => hi(e) === "[object Map]", ac = e => hi(e) === "[object Set]", Fs = e => hi(e) === "[object Date]", at = e => typeof e == "function", it = e => typeof e == "string", Ma = e => typeof e == "symbol", yt = e => e !== null && typeof e == "object", Na = e => yt(e) && at(e.then) && at(e.catch), gy = Object.prototype.toString, hi = e => gy.call(e), ou = e => hi(e).slice(8, -1), yy = e => hi(e) === "[object Object]", yp = e => it(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, ru = vp(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), ic = e => { const t = Object.create(null); return n => t[n] || (t[n] = e(n)); }, a_ = /-(\w)/g, Eo = ic(e => e.replace(a_, (t, n) => n ? n.toUpperCase() : "")), i_ = /\B([A-Z])/g, os = ic(e => e.replace(i_, "-$1").toLowerCase()), vi = ic(e => e.charAt(0).toUpperCase() + e.slice(1)), su = ic(e => e ? `on${vi(e)}` : ""), Pa = (e, t) => !Object.is(e, t), lu = (e, t) => { for (let n = 0; n < e.length; n++)
    e[n](t); }, Mu = (e, t, n) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: n }); }, jd = e => { const t = parseFloat(e); return isNaN(t) ? e : t; }, u_ = e => { const t = it(e) ? Number(e) : NaN; return isNaN(t) ? e : t; };
let Iv;
const Wd = () => Iv || (Iv = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function et(e) { if (qe(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
        const o = e[n], r = it(o) ? p_(o) : et(o);
        if (r)
            for (const s in r)
                t[s] = r[s];
    }
    return t;
}
else {
    if (it(e))
        return e;
    if (yt(e))
        return e;
} }
const c_ = /;(?![^(]*\))/g, d_ = /:([^]+)/, f_ = /\/\*[^]*?\*\//g;
function p_(e) { const t = {}; return e.replace(f_, "").split(c_).forEach(n => { if (n) {
    const o = n.split(d_);
    o.length > 1 && (t[o[0].trim()] = o[1].trim());
} }), t; }
function O(e) { let t = ""; if (it(e))
    t = e;
else if (qe(e))
    for (let n = 0; n < e.length; n++) {
        const o = O(e[n]);
        o && (t += o + " ");
    }
else if (yt(e))
    for (const n in e)
        e[n] && (t += n + " "); return t.trim(); }
function Lo(e) { if (!e)
    return null; let { class: t, style: n } = e; return t && !it(t) && (e.class = O(t)), n && (e.style = et(n)), e; }
const h_ = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", v_ = vp(h_);
function by(e) { return !!e || e === ""; }
function m_(e, t) { if (e.length !== t.length)
    return !1; let n = !0; for (let o = 0; n && o < e.length; o++)
    n = Cl(e[o], t[o]); return n; }
function Cl(e, t) { if (e === t)
    return !0; let n = Fs(e), o = Fs(t); if (n || o)
    return n && o ? e.getTime() === t.getTime() : !1; if (n = Ma(e), o = Ma(t), n || o)
    return e === t; if (n = qe(e), o = qe(t), n || o)
    return n && o ? m_(e, t) : !1; if (n = yt(e), o = yt(t), n || o) {
    if (!n || !o)
        return !1;
    const r = Object.keys(e).length, s = Object.keys(t).length;
    if (r !== s)
        return !1;
    for (const l in e) {
        const a = e.hasOwnProperty(l), u = t.hasOwnProperty(l);
        if (a && !u || !a && u || !Cl(e[l], t[l]))
            return !1;
    }
} return String(e) === String(t); }
function wy(e, t) { return e.findIndex(n => Cl(n, t)); }
const Be = e => it(e) ? e : e == null ? "" : qe(e) || yt(e) && (e.toString === gy || !at(e.toString)) ? JSON.stringify(e, Cy, 2) : String(e), Cy = (e, t) => t && t.__v_isRef ? Cy(e, t.value) : fl(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((n, [o, r]) => (n[`${o} =>`] = r, n), {}) } : ac(t) ? { [`Set(${t.size})`]: [...t.values()] } : yt(t) && !qe(t) && !yy(t) ? String(t) : t;
let fo;
class Sy {
    constructor(t = !1) { this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this.parent = fo, !t && fo && (this.index = (fo.scopes || (fo.scopes = [])).push(this) - 1); }
    get active() { return this._active; }
    run(t) { if (this._active) {
        const n = fo;
        try {
            return fo = this, t();
        }
        finally {
            fo = n;
        }
    } }
    on() { fo = this; }
    off() { fo = this.parent; }
    stop(t) { if (this._active) {
        let n, o;
        for (n = 0, o = this.effects.length; n < o; n++)
            this.effects[n].stop();
        for (n = 0, o = this.cleanups.length; n < o; n++)
            this.cleanups[n]();
        if (this.scopes)
            for (n = 0, o = this.scopes.length; n < o; n++)
                this.scopes[n].stop(!0);
        if (!this.detached && this.parent && !t) {
            const r = this.parent.scopes.pop();
            r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index);
        }
        this.parent = void 0, this._active = !1;
    } }
}
function g_(e) { return new Sy(e); }
function y_(e, t = fo) { t && t.active && t.effects.push(e); }
function _y() { return fo; }
function ky(e) { fo && fo.cleanups.push(e); }
const bp = e => { const t = new Set(e); return t.w = 0, t.n = 0, t; }, Ey = e => (e.w & Xr) > 0, $y = e => (e.n & Xr) > 0, b_ = ({ deps: e }) => { if (e.length)
    for (let t = 0; t < e.length; t++)
        e[t].w |= Xr; }, w_ = e => { const { deps: t } = e; if (t.length) {
    let n = 0;
    for (let o = 0; o < t.length; o++) {
        const r = t[o];
        Ey(r) && !$y(r) ? r.delete(e) : t[n++] = r, r.w &= ~Xr, r.n &= ~Xr;
    }
    t.length = n;
} }, Nu = new WeakMap;
let pa = 0, Xr = 1;
const Ud = 30;
let Ro;
const Ms = Symbol(""), qd = Symbol("");
class wp {
    constructor(t, n = null, o) { this.fn = t, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, y_(this, o); }
    run() { if (!this.active)
        return this.fn(); let t = Ro, n = Ur; for (; t;) {
        if (t === this)
            return;
        t = t.parent;
    } try {
        return this.parent = Ro, Ro = this, Ur = !0, Xr = 1 << ++pa, pa <= Ud ? b_(this) : xv(this), this.fn();
    }
    finally {
        pa <= Ud && w_(this), Xr = 1 << --pa, Ro = this.parent, Ur = n, this.parent = void 0, this.deferStop && this.stop();
    } }
    stop() { Ro === this ? this.deferStop = !0 : this.active && (xv(this), this.onStop && this.onStop(), this.active = !1); }
}
function xv(e) { const { deps: t } = e; if (t.length) {
    for (let n = 0; n < t.length; n++)
        t[n].delete(e);
    t.length = 0;
} }
let Ur = !0;
const Ty = [];
function Kl() { Ty.push(Ur), Ur = !1; }
function jl() { const e = Ty.pop(); Ur = e === void 0 ? !0 : e; }
function io(e, t, n) { if (Ur && Ro) {
    let o = Nu.get(e);
    o || Nu.set(e, o = new Map);
    let r = o.get(n);
    r || o.set(n, r = bp()), Oy(r);
} }
function Oy(e, t) { let n = !1; pa <= Ud ? $y(e) || (e.n |= Xr, n = !Ey(e)) : n = !e.has(Ro), n && (e.add(Ro), Ro.deps.push(e)); }
function wr(e, t, n, o, r, s) { const l = Nu.get(e); if (!l)
    return; let a = []; if (t === "clear")
    a = [...l.values()];
else if (n === "length" && qe(e)) {
    const u = Number(o);
    l.forEach((c, d) => { (d === "length" || d >= u) && a.push(c); });
}
else
    switch (n !== void 0 && a.push(l.get(n)), t) {
        case "add":
            qe(e) ? yp(n) && a.push(l.get("length")) : (a.push(l.get(Ms)), fl(e) && a.push(l.get(qd)));
            break;
        case "delete":
            qe(e) || (a.push(l.get(Ms)), fl(e) && a.push(l.get(qd)));
            break;
        case "set":
            fl(e) && a.push(l.get(Ms));
            break;
    } if (a.length === 1)
    a[0] && Yd(a[0]);
else {
    const u = [];
    for (const c of a)
        c && u.push(...c);
    Yd(bp(u));
} }
function Yd(e, t) { const n = qe(e) ? e : [...e]; for (const o of n)
    o.computed && Av(o); for (const o of n)
    o.computed || Av(o); }
function Av(e, t) { (e !== Ro || e.allowRecurse) && (e.scheduler ? e.scheduler() : e.run()); }
function C_(e, t) { var n; return (n = Nu.get(e)) == null ? void 0 : n.get(t); }
const S_ = vp("__proto__,__v_isRef,__isVue"), Iy = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(Ma)), __ = Cp(), k_ = Cp(!1, !0), E_ = Cp(!0), Mv = $_();
function $_() { const e = {}; return ["includes", "indexOf", "lastIndexOf"].forEach(t => { e[t] = function (...n) { const o = Bt(this); for (let s = 0, l = this.length; s < l; s++)
    io(o, "get", s + ""); const r = o[t](...n); return r === -1 || r === !1 ? o[t](...n.map(Bt)) : r; }; }), ["push", "pop", "shift", "unshift", "splice"].forEach(t => { e[t] = function (...n) { Kl(); const o = Bt(this)[t].apply(this, n); return jl(), o; }; }), e; }
function T_(e) { const t = Bt(this); return io(t, "has", e), t.hasOwnProperty(e); }
function Cp(e = !1, t = !1) { return function (o, r, s) { if (r === "__v_isReactive")
    return !e; if (r === "__v_isReadonly")
    return e; if (r === "__v_isShallow")
    return t; if (r === "__v_raw" && s === (e ? t ? K_ : Py : t ? Ny : My).get(o))
    return o; const l = qe(o); if (!e) {
    if (l && Tt(Mv, r))
        return Reflect.get(Mv, r, s);
    if (r === "hasOwnProperty")
        return T_;
} const a = Reflect.get(o, r, s); return (Ma(r) ? Iy.has(r) : S_(r)) || (e || io(o, "get", r), t) ? a : Jt(a) ? l && yp(r) ? a : a.value : yt(a) ? e ? Wl(a) : Lt(a) : a; }; }
const O_ = xy(), I_ = xy(!0);
function xy(e = !1) { return function (n, o, r, s) { let l = n[o]; if (Sl(l) && Jt(l) && !Jt(r))
    return !1; if (!e && (!Pu(r) && !Sl(r) && (l = Bt(l), r = Bt(r)), !qe(n) && Jt(l) && !Jt(r)))
    return l.value = r, !0; const a = qe(n) && yp(o) ? Number(o) < n.length : Tt(n, o), u = Reflect.set(n, o, r, s); return n === Bt(s) && (a ? Pa(r, l) && wr(n, "set", o, r) : wr(n, "add", o, r)), u; }; }
function x_(e, t) { const n = Tt(e, t); e[t]; const o = Reflect.deleteProperty(e, t); return o && n && wr(e, "delete", t, void 0), o; }
function A_(e, t) { const n = Reflect.has(e, t); return (!Ma(t) || !Iy.has(t)) && io(e, "has", t), n; }
function M_(e) { return io(e, "iterate", qe(e) ? "length" : Ms), Reflect.ownKeys(e); }
const Ay = { get: __, set: O_, deleteProperty: x_, has: A_, ownKeys: M_ }, N_ = { get: E_, set(e, t) { return !0; }, deleteProperty(e, t) { return !0; } }, P_ = Cn({}, Ay, { get: k_, set: I_ }), Sp = e => e, uc = e => Reflect.getPrototypeOf(e);
function Ni(e, t, n = !1, o = !1) { e = e.__v_raw; const r = Bt(e), s = Bt(t); n || (t !== s && io(r, "get", t), io(r, "get", s)); const { has: l } = uc(r), a = o ? Sp : n ? $p : Ra; if (l.call(r, t))
    return a(e.get(t)); if (l.call(r, s))
    return a(e.get(s)); e !== r && e.get(t); }
function Pi(e, t = !1) { const n = this.__v_raw, o = Bt(n), r = Bt(e); return t || (e !== r && io(o, "has", e), io(o, "has", r)), e === r ? n.has(e) : n.has(e) || n.has(r); }
function Ri(e, t = !1) { return e = e.__v_raw, !t && io(Bt(e), "iterate", Ms), Reflect.get(e, "size", e); }
function Nv(e) { e = Bt(e); const t = Bt(this); return uc(t).has.call(t, e) || (t.add(e), wr(t, "add", e, e)), this; }
function Pv(e, t) { t = Bt(t); const n = Bt(this), { has: o, get: r } = uc(n); let s = o.call(n, e); s || (e = Bt(e), s = o.call(n, e)); const l = r.call(n, e); return n.set(e, t), s ? Pa(t, l) && wr(n, "set", e, t) : wr(n, "add", e, t), this; }
function Rv(e) { const t = Bt(this), { has: n, get: o } = uc(t); let r = n.call(t, e); r || (e = Bt(e), r = n.call(t, e)), o && o.call(t, e); const s = t.delete(e); return r && wr(t, "delete", e, void 0), s; }
function Lv() { const e = Bt(this), t = e.size !== 0, n = e.clear(); return t && wr(e, "clear", void 0, void 0), n; }
function Li(e, t) { return function (o, r) { const s = this, l = s.__v_raw, a = Bt(l), u = t ? Sp : e ? $p : Ra; return !e && io(a, "iterate", Ms), l.forEach((c, d) => o.call(r, u(c), u(d), s)); }; }
function Di(e, t, n) { return function (...o) { const r = this.__v_raw, s = Bt(r), l = fl(s), a = e === "entries" || e === Symbol.iterator && l, u = e === "keys" && l, c = r[e](...o), d = n ? Sp : t ? $p : Ra; return !t && io(s, "iterate", u ? qd : Ms), { next() { const { value: f, done: p } = c.next(); return p ? { value: f, done: p } : { value: a ? [d(f[0]), d(f[1])] : d(f), done: p }; }, [Symbol.iterator]() { return this; } }; }; }
function Mr(e) { return function (...t) { return e === "delete" ? !1 : this; }; }
function R_() { const e = { get(s) { return Ni(this, s); }, get size() { return Ri(this); }, has: Pi, add: Nv, set: Pv, delete: Rv, clear: Lv, forEach: Li(!1, !1) }, t = { get(s) { return Ni(this, s, !1, !0); }, get size() { return Ri(this); }, has: Pi, add: Nv, set: Pv, delete: Rv, clear: Lv, forEach: Li(!1, !0) }, n = { get(s) { return Ni(this, s, !0); }, get size() { return Ri(this, !0); }, has(s) { return Pi.call(this, s, !0); }, add: Mr("add"), set: Mr("set"), delete: Mr("delete"), clear: Mr("clear"), forEach: Li(!0, !1) }, o = { get(s) { return Ni(this, s, !0, !0); }, get size() { return Ri(this, !0); }, has(s) { return Pi.call(this, s, !0); }, add: Mr("add"), set: Mr("set"), delete: Mr("delete"), clear: Mr("clear"), forEach: Li(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach(s => { e[s] = Di(s, !1, !1), n[s] = Di(s, !0, !1), t[s] = Di(s, !1, !0), o[s] = Di(s, !0, !0); }), [e, n, t, o]; }
const [L_, D_, B_, F_] = R_();
function _p(e, t) { const n = t ? e ? F_ : B_ : e ? D_ : L_; return (o, r, s) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? o : Reflect.get(Tt(n, r) && r in o ? n : o, r, s); }
const V_ = { get: _p(!1, !1) }, z_ = { get: _p(!1, !0) }, H_ = { get: _p(!0, !1) }, My = new WeakMap, Ny = new WeakMap, Py = new WeakMap, K_ = new WeakMap;
function j_(e) { switch (e) {
    case "Object":
    case "Array": return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet": return 2;
    default: return 0;
} }
function W_(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : j_(ou(e)); }
function Lt(e) { return Sl(e) ? e : Ep(e, !1, Ay, V_, My); }
function kp(e) { return Ep(e, !1, P_, z_, Ny); }
function Wl(e) { return Ep(e, !0, N_, H_, Py); }
function Ep(e, t, n, o, r) { if (!yt(e) || e.__v_raw && !(t && e.__v_isReactive))
    return e; const s = r.get(e); if (s)
    return s; const l = W_(e); if (l === 0)
    return e; const a = new Proxy(e, l === 2 ? o : n); return r.set(e, a), a; }
function pl(e) { return Sl(e) ? pl(e.__v_raw) : !!(e && e.__v_isReactive); }
function Sl(e) { return !!(e && e.__v_isReadonly); }
function Pu(e) { return !!(e && e.__v_isShallow); }
function Ry(e) { return pl(e) || Sl(e); }
function Bt(e) { const t = e && e.__v_raw; return t ? Bt(t) : e; }
function Ns(e) { return Mu(e, "__v_skip", !0), e; }
const Ra = e => yt(e) ? Lt(e) : e, $p = e => yt(e) ? Wl(e) : e;
function Ly(e) { Ur && Ro && (e = Bt(e), Oy(e.dep || (e.dep = bp()))); }
function Tp(e, t) { e = Bt(e); const n = e.dep; n && Yd(n); }
function Jt(e) { return !!(e && e.__v_isRef === !0); }
function M(e) { return Dy(e, !1); }
function Xt(e) { return Dy(e, !0); }
function Dy(e, t) { return Jt(e) ? e : new U_(e, t); }
class U_ {
    constructor(t, n) { this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? t : Bt(t), this._value = n ? t : Ra(t); }
    get value() { return Ly(this), this._value; }
    set value(t) { const n = this.__v_isShallow || Pu(t) || Sl(t); t = n ? t : Bt(t), Pa(t, this._rawValue) && (this._rawValue = t, this._value = n ? t : Ra(t), Tp(this)); }
}
function oa(e) { Tp(e); }
function i(e) { return Jt(e) ? e.value : e; }
const q_ = { get: (e, t, n) => i(Reflect.get(e, t, n)), set: (e, t, n, o) => { const r = e[t]; return Jt(r) && !Jt(n) ? (r.value = n, !0) : Reflect.set(e, t, n, o); } };
function By(e) { return pl(e) ? e : new Proxy(e, q_); }
function Sn(e) { const t = qe(e) ? new Array(e.length) : {}; for (const n in e)
    t[n] = Fy(e, n); return t; }
class Y_ {
    constructor(t, n, o) { this._object = t, this._key = n, this._defaultValue = o, this.__v_isRef = !0; }
    get value() { const t = this._object[this._key]; return t === void 0 ? this._defaultValue : t; }
    set value(t) { this._object[this._key] = t; }
    get dep() { return C_(Bt(this._object), this._key); }
}
class G_ {
    constructor(t) { this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0; }
    get value() { return this._getter(); }
}
function an(e, t, n) { return Jt(e) ? e : at(e) ? new G_(e) : yt(e) && arguments.length > 1 ? Fy(e, t, n) : M(e); }
function Fy(e, t, n) { const o = e[t]; return Jt(o) ? o : new Y_(e, t, n); }
class X_ {
    constructor(t, n, o, r) { this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new wp(t, () => { this._dirty || (this._dirty = !0, Tp(this)); }), this.effect.computed = this, this.effect.active = this._cacheable = !r, this.__v_isReadonly = o; }
    get value() { const t = Bt(this); return Ly(t), (t._dirty || !t._cacheable) && (t._dirty = !1, t._value = t.effect.run()), t._value; }
    set value(t) { this._setter(t); }
}
function Vy(e, t, n = !1) { let o, r; const s = at(e); return s ? (o = e, r = Wt) : (o = e.get, r = e.set), new X_(o, r, s || !r, n); }
function J_(e, ...t) { }
function qr(e, t, n, o) { let r; try {
    r = o ? e(...o) : e();
}
catch (s) {
    dc(s, t, n);
} return r; }
function So(e, t, n, o) { if (at(e)) {
    const s = qr(e, t, n, o);
    return s && Na(s) && s.catch(l => { dc(l, t, n); }), s;
} const r = []; for (let s = 0; s < e.length; s++)
    r.push(So(e[s], t, n, o)); return r; }
function dc(e, t, n, o = !0) { const r = t ? t.vnode : null; if (t) {
    let s = t.parent;
    const l = t.proxy, a = n;
    for (; s;) {
        const c = s.ec;
        if (c) {
            for (let d = 0; d < c.length; d++)
                if (c[d](e, l, a) === !1)
                    return;
        }
        s = s.parent;
    }
    const u = t.appContext.config.errorHandler;
    if (u) {
        qr(u, null, 10, [e, l, a]);
        return;
    }
} Z_(e, n, r, o); }
function Z_(e, t, n, o = !0) { console.error(e); }
let La = !1, Gd = !1;
const Fn = [];
let Go = 0;
const hl = [];
let hr = null, ws = 0;
const zy = Promise.resolve();
let Op = null;
function Xe(e) { const t = Op || zy; return e ? t.then(this ? e.bind(this) : e) : t; }
function Q_(e) { let t = Go + 1, n = Fn.length; for (; t < n;) {
    const o = t + n >>> 1;
    Da(Fn[o]) < e ? t = o + 1 : n = o;
} return t; }
function Ip(e) { (!Fn.length || !Fn.includes(e, La && e.allowRecurse ? Go + 1 : Go)) && (e.id == null ? Fn.push(e) : Fn.splice(Q_(e.id), 0, e), Hy()); }
function Hy() { !La && !Gd && (Gd = !0, Op = zy.then(jy)); }
function ek(e) { const t = Fn.indexOf(e); t > Go && Fn.splice(t, 1); }
function tk(e) { qe(e) ? hl.push(...e) : (!hr || !hr.includes(e, e.allowRecurse ? ws + 1 : ws)) && hl.push(e), Hy(); }
function Dv(e, t = La ? Go + 1 : 0) { for (; t < Fn.length; t++) {
    const n = Fn[t];
    n && n.pre && (Fn.splice(t, 1), t--, n());
} }
function Ky(e) { if (hl.length) {
    const t = [...new Set(hl)];
    if (hl.length = 0, hr) {
        hr.push(...t);
        return;
    }
    for (hr = t, hr.sort((n, o) => Da(n) - Da(o)), ws = 0; ws < hr.length; ws++)
        hr[ws]();
    hr = null, ws = 0;
} }
const Da = e => e.id == null ? 1 / 0 : e.id, nk = (e, t) => { const n = Da(e) - Da(t); if (n === 0) {
    if (e.pre && !t.pre)
        return -1;
    if (t.pre && !e.pre)
        return 1;
} return n; };
function jy(e) { Gd = !1, La = !0, Fn.sort(nk); const t = Wt; try {
    for (Go = 0; Go < Fn.length; Go++) {
        const n = Fn[Go];
        n && n.active !== !1 && qr(n, null, 14);
    }
}
finally {
    Go = 0, Fn.length = 0, Ky(), La = !1, Op = null, (Fn.length || hl.length) && jy();
} }
function ok(e, t, ...n) { if (e.isUnmounted)
    return; const o = e.vnode.props || vn; let r = n; const s = t.startsWith("update:"), l = s && t.slice(7); if (l && l in o) {
    const d = `${l === "modelValue" ? "model" : l}Modifiers`, { number: f, trim: p } = o[d] || vn;
    p && (r = n.map(v => it(v) ? v.trim() : v)), f && (r = n.map(jd));
} let a, u = o[a = su(t)] || o[a = su(Eo(t))]; !u && s && (u = o[a = su(os(t))]), u && So(u, e, 6, r); const c = o[a + "Once"]; if (c) {
    if (!e.emitted)
        e.emitted = {};
    else if (e.emitted[a])
        return;
    e.emitted[a] = !0, So(c, e, 6, r);
} }
function Wy(e, t, n = !1) { const o = t.emitsCache, r = o.get(e); if (r !== void 0)
    return r; const s = e.emits; let l = {}, a = !1; if (!at(e)) {
    const u = c => { const d = Wy(c, t, !0); d && (a = !0, Cn(l, d)); };
    !n && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u);
} return !s && !a ? (yt(e) && o.set(e, null), null) : (qe(s) ? s.forEach(u => l[u] = null) : Cn(l, s), yt(e) && o.set(e, l), l); }
function fc(e, t) { return !e || !lc(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), Tt(e, t[0].toLowerCase() + t.slice(1)) || Tt(e, os(t)) || Tt(e, t)); }
let Rn = null, pc = null;
function Ru(e) { const t = Rn; return Rn = e, pc = e && e.type.__scopeId || null, t; }
function rk(e) { pc = e; }
function sk() { pc = null; }
function ie(e, t = Rn, n) { if (!t || e._n)
    return e; const o = (...r) => { o._d && Xv(-1); const s = Ru(t); let l; try {
    l = e(...r);
}
finally {
    Ru(s), o._d && Xv(1);
} return l; }; return o._n = !0, o._c = !0, o._d = !0, o; }
function ad(e) { const { type: t, vnode: n, proxy: o, withProxy: r, props: s, propsOptions: [l], slots: a, attrs: u, emit: c, render: d, renderCache: f, data: p, setupState: v, ctx: m, inheritAttrs: h } = e; let g, y; const C = Ru(e); try {
    if (n.shapeFlag & 4) {
        const w = r || o;
        g = Yo(d.call(w, w, f, s, v, p, m)), y = u;
    }
    else {
        const w = t;
        g = Yo(w.length > 1 ? w(s, { attrs: u, slots: a, emit: c }) : w(s, null)), y = t.props ? u : lk(u);
    }
}
catch (w) {
    wa.length = 0, dc(w, e, 1), g = ee(Wn);
} let b = g; if (y && h !== !1) {
    const w = Object.keys(y), { shapeFlag: T } = b;
    w.length && T & 7 && (l && w.some(mp) && (y = ak(y, l)), b = Sr(b, y));
} return n.dirs && (b = Sr(b), b.dirs = b.dirs ? b.dirs.concat(n.dirs) : n.dirs), n.transition && (b.transition = n.transition), g = b, Ru(C), g; }
const lk = e => { let t; for (const n in e)
    (n === "class" || n === "style" || lc(n)) && ((t || (t = {}))[n] = e[n]); return t; }, ak = (e, t) => { const n = {}; for (const o in e)
    (!mp(o) || !(o.slice(9) in t)) && (n[o] = e[o]); return n; };
function ik(e, t, n) { const { props: o, children: r, component: s } = e, { props: l, children: a, patchFlag: u } = t, c = s.emitsOptions; if (t.dirs || t.transition)
    return !0; if (n && u >= 0) {
    if (u & 1024)
        return !0;
    if (u & 16)
        return o ? Bv(o, l, c) : !!l;
    if (u & 8) {
        const d = t.dynamicProps;
        for (let f = 0; f < d.length; f++) {
            const p = d[f];
            if (l[p] !== o[p] && !fc(c, p))
                return !0;
        }
    }
}
else
    return (r || a) && (!a || !a.$stable) ? !0 : o === l ? !1 : o ? l ? Bv(o, l, c) : !0 : !!l; return !1; }
function Bv(e, t, n) { const o = Object.keys(t); if (o.length !== Object.keys(e).length)
    return !0; for (let r = 0; r < o.length; r++) {
    const s = o[r];
    if (t[s] !== e[s] && !fc(n, s))
        return !0;
} return !1; }
function uk({ vnode: e, parent: t }, n) { for (; t && t.subTree === e;)
    (e = t.vnode).el = n, t = t.parent; }
const ck = e => e.__isSuspense;
function dk(e, t) { t && t.pendingBranch ? qe(e) ? t.effects.push(...e) : t.effects.push(e) : tk(e); }
function mo(e, t) { return xp(e, null, t); }
const Bi = {};
function Oe(e, t, n) { return xp(e, t, n); }
function xp(e, t, { immediate: n, deep: o, flush: r, onTrack: s, onTrigger: l } = vn) { var a; const u = _y() === ((a = In) == null ? void 0 : a.scope) ? In : null; let c, d = !1, f = !1; if (Jt(e) ? (c = () => e.value, d = Pu(e)) : pl(e) ? (c = () => e, o = !0) : qe(e) ? (f = !0, d = e.some(w => pl(w) || Pu(w)), c = () => e.map(w => { if (Jt(w))
    return w.value; if (pl(w))
    return Es(w); if (at(w))
    return qr(w, u, 2); })) : at(e) ? t ? c = () => qr(e, u, 2) : c = () => { if (!(u && u.isUnmounted))
    return p && p(), So(e, u, 3, [v]); } : c = Wt, t && o) {
    const w = c;
    c = () => Es(w());
} let p, v = w => { p = C.onStop = () => { qr(w, u, 4); }; }, m; if (Ha)
    if (v = Wt, t ? n && So(t, u, 3, [c(), f ? [] : void 0, v]) : c(), r === "sync") {
        const w = Qk();
        m = w.__watcherHandles || (w.__watcherHandles = []);
    }
    else
        return Wt; let h = f ? new Array(e.length).fill(Bi) : Bi; const g = () => { if (C.active)
    if (t) {
        const w = C.run();
        (o || d || (f ? w.some((T, E) => Pa(T, h[E])) : Pa(w, h))) && (p && p(), So(t, u, 3, [w, h === Bi ? void 0 : f && h[0] === Bi ? [] : h, v]), h = w);
    }
    else
        C.run(); }; g.allowRecurse = !!t; let y; r === "sync" ? y = g : r === "post" ? y = () => oo(g, u && u.suspense) : (g.pre = !0, u && (g.id = u.uid), y = () => Ip(g)); const C = new wp(c, y); t ? n ? g() : h = C.run() : r === "post" ? oo(C.run.bind(C), u && u.suspense) : C.run(); const b = () => { C.stop(), u && u.scope && gp(u.scope.effects, C); }; return m && m.push(b), b; }
function fk(e, t, n) { const o = this.proxy, r = it(e) ? e.includes(".") ? Uy(o, e) : () => o[e] : e.bind(o, o); let s; at(t) ? s = t : (s = t.handler, n = t); const l = In; _l(this); const a = xp(r, s.bind(o), n); return l ? _l(l) : Ps(), a; }
function Uy(e, t) { const n = t.split("."); return () => { let o = e; for (let r = 0; r < n.length && o; r++)
    o = o[n[r]]; return o; }; }
function Es(e, t) { if (!yt(e) || e.__v_skip || (t = t || new Set, t.has(e)))
    return e; if (t.add(e), Jt(e))
    Es(e.value, t);
else if (qe(e))
    for (let n = 0; n < e.length; n++)
        Es(e[n], t);
else if (ac(e) || fl(e))
    e.forEach(n => { Es(n, t); });
else if (yy(e))
    for (const n in e)
        Es(e[n], t); return e; }
function dt(e, t) { const n = Rn; if (n === null)
    return e; const o = bc(n) || n.proxy, r = e.dirs || (e.dirs = []); for (let s = 0; s < t.length; s++) {
    let [l, a, u, c = vn] = t[s];
    l && (at(l) && (l = { mounted: l, updated: l }), l.deep && Es(a), r.push({ dir: l, instance: o, value: a, oldValue: void 0, arg: u, modifiers: c }));
} return e; }
function hs(e, t, n, o) { const r = e.dirs, s = t && t.dirs; for (let l = 0; l < r.length; l++) {
    const a = r[l];
    s && (a.oldValue = s[l].value);
    let u = a.dir[o];
    u && (Kl(), So(u, n, 8, [e.el, a, e, t]), jl());
} }
function qy() { const e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map }; return ft(() => { e.isMounted = !0; }), on(() => { e.isUnmounting = !0; }), e; }
const yo = [Function, Array], Yy = { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: yo, onEnter: yo, onAfterEnter: yo, onEnterCancelled: yo, onBeforeLeave: yo, onLeave: yo, onAfterLeave: yo, onLeaveCancelled: yo, onBeforeAppear: yo, onAppear: yo, onAfterAppear: yo, onAppearCancelled: yo }, pk = { name: "BaseTransition", props: Yy, setup(e, { slots: t }) { const n = ht(), o = qy(); let r; return () => { const s = t.default && Ap(t.default(), !0); if (!s || !s.length)
        return; let l = s[0]; if (s.length > 1) {
        for (const h of s)
            if (h.type !== Wn) {
                l = h;
                break;
            }
    } const a = Bt(e), { mode: u } = a; if (o.isLeaving)
        return id(l); const c = Fv(l); if (!c)
        return id(l); const d = Ba(c, a, o, n); Fa(c, d); const f = n.subTree, p = f && Fv(f); let v = !1; const { getTransitionKey: m } = c.type; if (m) {
        const h = m();
        r === void 0 ? r = h : h !== r && (r = h, v = !0);
    } if (p && p.type !== Wn && (!Cs(c, p) || v)) {
        const h = Ba(p, a, o, n);
        if (Fa(p, h), u === "out-in")
            return o.isLeaving = !0, h.afterLeave = () => { o.isLeaving = !1, n.update.active !== !1 && n.update(); }, id(l);
        u === "in-out" && c.type !== Wn && (h.delayLeave = (g, y, C) => { const b = Gy(o, p); b[String(p.key)] = p, g._leaveCb = () => { y(), g._leaveCb = void 0, delete d.delayedLeave; }, d.delayedLeave = C; });
    } return l; }; } }, hk = pk;
function Gy(e, t) { const { leavingVNodes: n } = e; let o = n.get(t.type); return o || (o = Object.create(null), n.set(t.type, o)), o; }
function Ba(e, t, n, o) { const { appear: r, mode: s, persisted: l = !1, onBeforeEnter: a, onEnter: u, onAfterEnter: c, onEnterCancelled: d, onBeforeLeave: f, onLeave: p, onAfterLeave: v, onLeaveCancelled: m, onBeforeAppear: h, onAppear: g, onAfterAppear: y, onAppearCancelled: C } = t, b = String(e.key), w = Gy(n, e), T = (I, L) => { I && So(I, o, 9, L); }, E = (I, L) => { const B = L[1]; T(I, L), qe(I) ? I.every(F => F.length <= 1) && B() : I.length <= 1 && B(); }, x = { mode: s, persisted: l, beforeEnter(I) { let L = a; if (!n.isMounted)
        if (r)
            L = h || a;
        else
            return; I._leaveCb && I._leaveCb(!0); const B = w[b]; B && Cs(e, B) && B.el._leaveCb && B.el._leaveCb(), T(L, [I]); }, enter(I) { let L = u, B = c, F = d; if (!n.isMounted)
        if (r)
            L = g || u, B = y || c, F = C || d;
        else
            return; let V = !1; const R = I._enterCb = K => { V || (V = !0, K ? T(F, [I]) : T(B, [I]), x.delayedLeave && x.delayedLeave(), I._enterCb = void 0); }; L ? E(L, [I, R]) : R(); }, leave(I, L) { const B = String(e.key); if (I._enterCb && I._enterCb(!0), n.isUnmounting)
        return L(); T(f, [I]); let F = !1; const V = I._leaveCb = R => { F || (F = !0, L(), R ? T(m, [I]) : T(v, [I]), I._leaveCb = void 0, w[B] === e && delete w[B]); }; w[B] = e, p ? E(p, [I, V]) : V(); }, clone(I) { return Ba(I, t, n, o); } }; return x; }
function id(e) { if (hc(e))
    return e = Sr(e), e.children = null, e; }
function Fv(e) { return hc(e) ? e.children ? e.children[0] : void 0 : e; }
function Fa(e, t) { e.shapeFlag & 6 && e.component ? Fa(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t; }
function Ap(e, t = !1, n) { let o = [], r = 0; for (let s = 0; s < e.length; s++) {
    let l = e[s];
    const a = n == null ? l.key : String(n) + String(l.key != null ? l.key : s);
    l.type === Qe ? (l.patchFlag & 128 && r++, o = o.concat(Ap(l.children, t, a))) : (t || l.type !== Wn) && o.push(a != null ? Sr(l, { key: a }) : l);
} if (r > 1)
    for (let s = 0; s < o.length; s++)
        o[s].patchFlag = -2; return o; }
function ae(e, t) { return at(e) ? (() => Cn({ name: e.name }, t, { setup: e }))() : e; }
const ga = e => !!e.type.__asyncLoader, hc = e => e.type.__isKeepAlive;
function vk(e, t) { Jy(e, "a", t); }
function Xy(e, t) { Jy(e, "da", t); }
function Jy(e, t, n = In) { const o = e.__wdc || (e.__wdc = () => { let r = n; for (; r;) {
    if (r.isDeactivated)
        return;
    r = r.parent;
} return e(); }); if (vc(t, o, n), n) {
    let r = n.parent;
    for (; r && r.parent;)
        hc(r.parent.vnode) && mk(o, t, n, r), r = r.parent;
} }
function mk(e, t, n, o) { const r = vc(t, e, o, !0); rs(() => { gp(o[t], r); }, n); }
function vc(e, t, n = In, o = !1) { if (n) {
    const r = n[e] || (n[e] = []), s = t.__weh || (t.__weh = (...l) => { if (n.isUnmounted)
        return; Kl(), _l(n); const a = So(t, n, e, l); return Ps(), jl(), a; });
    return o ? r.unshift(s) : r.push(s), s;
} }
const kr = e => (t, n = In) => (!Ha || e === "sp") && vc(e, (...o) => t(...o), n), mc = kr("bm"), ft = kr("m"), Zy = kr("bu"), Er = kr("u"), on = kr("bum"), rs = kr("um"), gk = kr("sp"), yk = kr("rtg"), bk = kr("rtc");
function wk(e, t = In) { vc("ec", e, t); }
const Mp = "components", Ck = "directives";
function ct(e, t) { return Np(Mp, e, !0, t) || e; }
const Qy = Symbol.for("v-ndc");
function kt(e) { return it(e) ? Np(Mp, e, !1) || e : e || Qy; }
function Va(e) { return Np(Ck, e); }
function Np(e, t, n = !0, o = !1) { const r = Rn || In; if (r) {
    const s = r.type;
    if (e === Mp) {
        const a = Xk(s, !1);
        if (a && (a === t || a === Eo(t) || a === vi(Eo(t))))
            return s;
    }
    const l = Vv(r[e] || s[e], t) || Vv(r.appContext[e], t);
    return !l && o ? s : l;
} }
function Vv(e, t) { return e && (e[t] || e[Eo(t)] || e[vi(Eo(t))]); }
function Et(e, t, n, o) { let r; const s = n && n[o]; if (qe(e) || it(e)) {
    r = new Array(e.length);
    for (let l = 0, a = e.length; l < a; l++)
        r[l] = t(e[l], l, void 0, s && s[l]);
}
else if (typeof e == "number") {
    r = new Array(e);
    for (let l = 0; l < e; l++)
        r[l] = t(l + 1, l, void 0, s && s[l]);
}
else if (yt(e))
    if (e[Symbol.iterator])
        r = Array.from(e, (l, a) => t(l, a, void 0, s && s[a]));
    else {
        const l = Object.keys(e);
        r = new Array(l.length);
        for (let a = 0, u = l.length; a < u; a++) {
            const c = l[a];
            r[a] = t(e[c], c, a, s && s[a]);
        }
    }
else
    r = []; return n && (n[o] = r), r; }
function Cr(e, t) { for (let n = 0; n < t.length; n++) {
    const o = t[n];
    if (qe(o))
        for (let r = 0; r < o.length; r++)
            e[o[r].name] = o[r].fn;
    else
        o && (e[o.name] = o.key ? (...r) => { const s = o.fn(...r); return s && (s.key = o.key), s; } : o.fn);
} return e; }
function ke(e, t, n = {}, o, r) { if (Rn.isCE || Rn.parent && ga(Rn.parent) && Rn.parent.isCE)
    return t !== "default" && (n.name = t), ee("slot", n, o && o()); let s = e[t]; s && s._c && (s._d = !1), k(); const l = s && eb(s(n)), a = ge(Qe, { key: n.key || l && l.key || `_${t}` }, l || (o ? o() : []), l && e._ === 1 ? 64 : -2); return !r && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), s && s._c && (s._d = !0), a; }
function eb(e) { return e.some(t => un(t) ? !(t.type === Wn || t.type === Qe && !eb(t.children)) : !0) ? e : null; }
function Sk(e, t) { const n = {}; for (const o in e)
    n[t && /[A-Z]/.test(o) ? `on:${o}` : su(o)] = e[o]; return n; }
const Xd = e => e ? fb(e) ? bc(e) || e.proxy : Xd(e.parent) : null, ya = Cn(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => Xd(e.parent), $root: e => Xd(e.root), $emit: e => e.emit, $options: e => Pp(e), $forceUpdate: e => e.f || (e.f = () => Ip(e.update)), $nextTick: e => e.n || (e.n = Xe.bind(e.proxy)), $watch: e => fk.bind(e) }), ud = (e, t) => e !== vn && !e.__isScriptSetup && Tt(e, t), _k = { get({ _: e }, t) { const { ctx: n, setupState: o, data: r, props: s, accessCache: l, type: a, appContext: u } = e; let c; if (t[0] !== "$") {
        const v = l[t];
        if (v !== void 0)
            switch (v) {
                case 1: return o[t];
                case 2: return r[t];
                case 4: return n[t];
                case 3: return s[t];
            }
        else {
            if (ud(o, t))
                return l[t] = 1, o[t];
            if (r !== vn && Tt(r, t))
                return l[t] = 2, r[t];
            if ((c = e.propsOptions[0]) && Tt(c, t))
                return l[t] = 3, s[t];
            if (n !== vn && Tt(n, t))
                return l[t] = 4, n[t];
            Jd && (l[t] = 0);
        }
    } const d = ya[t]; let f, p; if (d)
        return t === "$attrs" && io(e, "get", t), d(e); if ((f = a.__cssModules) && (f = f[t]))
        return f; if (n !== vn && Tt(n, t))
        return l[t] = 4, n[t]; if (p = u.config.globalProperties, Tt(p, t))
        return p[t]; }, set({ _: e }, t, n) { const { data: o, setupState: r, ctx: s } = e; return ud(r, t) ? (r[t] = n, !0) : o !== vn && Tt(o, t) ? (o[t] = n, !0) : Tt(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (s[t] = n, !0); }, has({ _: { data: e, setupState: t, accessCache: n, ctx: o, appContext: r, propsOptions: s } }, l) { let a; return !!n[l] || e !== vn && Tt(e, l) || ud(t, l) || (a = s[0]) && Tt(a, l) || Tt(o, l) || Tt(ya, l) || Tt(r.config.globalProperties, l); }, defineProperty(e, t, n) { return n.get != null ? e._.accessCache[t] = 0 : Tt(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n); } };
function An() { return tb().slots; }
function js() { return tb().attrs; }
function tb() { const e = ht(); return e.setupContext || (e.setupContext = hb(e)); }
function zv(e) { return qe(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e; }
let Jd = !0;
function kk(e) { const t = Pp(e), n = e.proxy, o = e.ctx; Jd = !1, t.beforeCreate && Hv(t.beforeCreate, e, "bc"); const { data: r, computed: s, methods: l, watch: a, provide: u, inject: c, created: d, beforeMount: f, mounted: p, beforeUpdate: v, updated: m, activated: h, deactivated: g, beforeDestroy: y, beforeUnmount: C, destroyed: b, unmounted: w, render: T, renderTracked: E, renderTriggered: x, errorCaptured: I, serverPrefetch: L, expose: B, inheritAttrs: F, components: V, directives: R, filters: K } = t; if (c && Ek(c, o, null), l)
    for (const D in l) {
        const j = l[D];
        at(j) && (o[D] = j.bind(n));
    } if (r) {
    const D = r.call(n, n);
    yt(D) && (e.data = Lt(D));
} if (Jd = !0, s)
    for (const D in s) {
        const j = s[D], A = at(j) ? j.bind(n, n) : at(j.get) ? j.get.bind(n, n) : Wt, G = !at(j) && at(j.set) ? j.set.bind(n) : Wt, se = S({ get: A, set: G });
        Object.defineProperty(o, D, { enumerable: !0, configurable: !0, get: () => se.value, set: Z => se.value = Z });
    } if (a)
    for (const D in a)
        nb(a[D], o, n, D); if (u) {
    const D = at(u) ? u.call(n) : u;
    Reflect.ownKeys(D).forEach(j => { St(j, D[j]); });
} d && Hv(d, e, "c"); function U(D, j) { qe(j) ? j.forEach(A => D(A.bind(n))) : j && D(j.bind(n)); } if (U(mc, f), U(ft, p), U(Zy, v), U(Er, m), U(vk, h), U(Xy, g), U(wk, I), U(bk, E), U(yk, x), U(on, C), U(rs, w), U(gk, L), qe(B))
    if (B.length) {
        const D = e.exposed || (e.exposed = {});
        B.forEach(j => { Object.defineProperty(D, j, { get: () => n[j], set: A => n[j] = A }); });
    }
    else
        e.exposed || (e.exposed = {}); T && e.render === Wt && (e.render = T), F != null && (e.inheritAttrs = F), V && (e.components = V), R && (e.directives = R); }
function Ek(e, t, n = Wt) { qe(e) && (e = Zd(e)); for (const o in e) {
    const r = e[o];
    let s;
    yt(r) ? "default" in r ? s = Ye(r.from || o, r.default, !0) : s = Ye(r.from || o) : s = Ye(r), Jt(s) ? Object.defineProperty(t, o, { enumerable: !0, configurable: !0, get: () => s.value, set: l => s.value = l }) : t[o] = s;
} }
function Hv(e, t, n) { So(qe(e) ? e.map(o => o.bind(t.proxy)) : e.bind(t.proxy), t, n); }
function nb(e, t, n, o) { const r = o.includes(".") ? Uy(n, o) : () => n[o]; if (it(e)) {
    const s = t[e];
    at(s) && Oe(r, s);
}
else if (at(e))
    Oe(r, e.bind(n));
else if (yt(e))
    if (qe(e))
        e.forEach(s => nb(s, t, n, o));
    else {
        const s = at(e.handler) ? e.handler.bind(n) : t[e.handler];
        at(s) && Oe(r, s, e);
    } }
function Pp(e) { const t = e.type, { mixins: n, extends: o } = t, { mixins: r, optionsCache: s, config: { optionMergeStrategies: l } } = e.appContext, a = s.get(t); let u; return a ? u = a : !r.length && !n && !o ? u = t : (u = {}, r.length && r.forEach(c => Lu(u, c, l, !0)), Lu(u, t, l)), yt(t) && s.set(t, u), u; }
function Lu(e, t, n, o = !1) { const { mixins: r, extends: s } = t; s && Lu(e, s, n, !0), r && r.forEach(l => Lu(e, l, n, !0)); for (const l in t)
    if (!(o && l === "expose")) {
        const a = $k[l] || n && n[l];
        e[l] = a ? a(e[l], t[l]) : t[l];
    } return e; }
const $k = { data: Kv, props: jv, emits: jv, methods: ha, computed: ha, beforeCreate: jn, created: jn, beforeMount: jn, mounted: jn, beforeUpdate: jn, updated: jn, beforeDestroy: jn, beforeUnmount: jn, destroyed: jn, unmounted: jn, activated: jn, deactivated: jn, errorCaptured: jn, serverPrefetch: jn, components: ha, directives: ha, watch: Ok, provide: Kv, inject: Tk };
function Kv(e, t) { return t ? e ? function () { return Cn(at(e) ? e.call(this, this) : e, at(t) ? t.call(this, this) : t); } : t : e; }
function Tk(e, t) { return ha(Zd(e), Zd(t)); }
function Zd(e) { if (qe(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++)
        t[e[n]] = e[n];
    return t;
} return e; }
function jn(e, t) { return e ? [...new Set([].concat(e, t))] : t; }
function ha(e, t) { return e ? Cn(Object.create(null), e, t) : t; }
function jv(e, t) { return e ? qe(e) && qe(t) ? [...new Set([...e, ...t])] : Cn(Object.create(null), zv(e), zv(t ?? {})) : t; }
function Ok(e, t) { if (!e)
    return t; if (!t)
    return e; const n = Cn(Object.create(null), e); for (const o in t)
    n[o] = jn(e[o], t[o]); return n; }
function ob() { return { app: null, config: { isNativeTag: r_, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap }; }
let Ik = 0;
function xk(e, t) { return function (o, r = null) { at(o) || (o = Cn({}, o)), r != null && !yt(r) && (r = null); const s = ob(), l = new Set; let a = !1; const u = s.app = { _uid: Ik++, _component: o, _props: r, _container: null, _context: s, _instance: null, version: eE, get config() { return s.config; }, set config(c) { }, use(c, ...d) { return l.has(c) || (c && at(c.install) ? (l.add(c), c.install(u, ...d)) : at(c) && (l.add(c), c(u, ...d))), u; }, mixin(c) { return s.mixins.includes(c) || s.mixins.push(c), u; }, component(c, d) { return d ? (s.components[c] = d, u) : s.components[c]; }, directive(c, d) { return d ? (s.directives[c] = d, u) : s.directives[c]; }, mount(c, d, f) { if (!a) {
        const p = ee(o, r);
        return p.appContext = s, d && t ? t(p, c) : e(p, c, f), a = !0, u._container = c, c.__vue_app__ = u, bc(p.component) || p.component.proxy;
    } }, unmount() { a && (e(null, u._container), delete u._container.__vue_app__); }, provide(c, d) { return s.provides[c] = d, u; }, runWithContext(c) { Du = u; try {
        return c();
    }
    finally {
        Du = null;
    } } }; return u; }; }
let Du = null;
function St(e, t) { if (In) {
    let n = In.provides;
    const o = In.parent && In.parent.provides;
    o === n && (n = In.provides = Object.create(o)), n[e] = t;
} }
function Ye(e, t, n = !1) { const o = In || Rn; if (o || Du) {
    const r = o ? o.parent == null ? o.vnode.appContext && o.vnode.appContext.provides : o.parent.provides : Du._context.provides;
    if (r && e in r)
        return r[e];
    if (arguments.length > 1)
        return n && at(t) ? t.call(o && o.proxy) : t;
} }
function Ak(e, t, n, o = !1) { const r = {}, s = {}; Mu(s, gc, 1), e.propsDefaults = Object.create(null), rb(e, t, r, s); for (const l in e.propsOptions[0])
    l in r || (r[l] = void 0); n ? e.props = o ? r : kp(r) : e.type.props ? e.props = r : e.props = s, e.attrs = s; }
function Mk(e, t, n, o) { const { props: r, attrs: s, vnode: { patchFlag: l } } = e, a = Bt(r), [u] = e.propsOptions; let c = !1; if ((o || l > 0) && !(l & 16)) {
    if (l & 8) {
        const d = e.vnode.dynamicProps;
        for (let f = 0; f < d.length; f++) {
            let p = d[f];
            if (fc(e.emitsOptions, p))
                continue;
            const v = t[p];
            if (u)
                if (Tt(s, p))
                    v !== s[p] && (s[p] = v, c = !0);
                else {
                    const m = Eo(p);
                    r[m] = Qd(u, a, m, v, e, !1);
                }
            else
                v !== s[p] && (s[p] = v, c = !0);
        }
    }
}
else {
    rb(e, t, r, s) && (c = !0);
    let d;
    for (const f in a)
        (!t || !Tt(t, f) && ((d = os(f)) === f || !Tt(t, d))) && (u ? n && (n[f] !== void 0 || n[d] !== void 0) && (r[f] = Qd(u, a, f, void 0, e, !0)) : delete r[f]);
    if (s !== a)
        for (const f in s)
            (!t || !Tt(t, f)) && (delete s[f], c = !0);
} c && wr(e, "set", "$attrs"); }
function rb(e, t, n, o) { const [r, s] = e.propsOptions; let l = !1, a; if (t)
    for (let u in t) {
        if (ru(u))
            continue;
        const c = t[u];
        let d;
        r && Tt(r, d = Eo(u)) ? !s || !s.includes(d) ? n[d] = c : (a || (a = {}))[d] = c : fc(e.emitsOptions, u) || (!(u in o) || c !== o[u]) && (o[u] = c, l = !0);
    } if (s) {
    const u = Bt(n), c = a || vn;
    for (let d = 0; d < s.length; d++) {
        const f = s[d];
        n[f] = Qd(r, u, f, c[f], e, !Tt(c, f));
    }
} return l; }
function Qd(e, t, n, o, r, s) { const l = e[n]; if (l != null) {
    const a = Tt(l, "default");
    if (a && o === void 0) {
        const u = l.default;
        if (l.type !== Function && !l.skipFactory && at(u)) {
            const { propsDefaults: c } = r;
            n in c ? o = c[n] : (_l(r), o = c[n] = u.call(null, t), Ps());
        }
        else
            o = u;
    }
    l[0] && (s && !a ? o = !1 : l[1] && (o === "" || o === os(n)) && (o = !0));
} return o; }
function sb(e, t, n = !1) { const o = t.propsCache, r = o.get(e); if (r)
    return r; const s = e.props, l = {}, a = []; let u = !1; if (!at(e)) {
    const d = f => { u = !0; const [p, v] = sb(f, t, !0); Cn(l, p), v && a.push(...v); };
    !n && t.mixins.length && t.mixins.forEach(d), e.extends && d(e.extends), e.mixins && e.mixins.forEach(d);
} if (!s && !u)
    return yt(e) && o.set(e, dl), dl; if (qe(s))
    for (let d = 0; d < s.length; d++) {
        const f = Eo(s[d]);
        Wv(f) && (l[f] = vn);
    }
else if (s)
    for (const d in s) {
        const f = Eo(d);
        if (Wv(f)) {
            const p = s[d], v = l[f] = qe(p) || at(p) ? { type: p } : Cn({}, p);
            if (v) {
                const m = Yv(Boolean, v.type), h = Yv(String, v.type);
                v[0] = m > -1, v[1] = h < 0 || m < h, (m > -1 || Tt(v, "default")) && a.push(f);
            }
        }
    } const c = [l, a]; return yt(e) && o.set(e, c), c; }
function Wv(e) { return e[0] !== "$"; }
function Uv(e) { const t = e && e.toString().match(/^\s*(function|class) (\w+)/); return t ? t[2] : e === null ? "null" : ""; }
function qv(e, t) { return Uv(e) === Uv(t); }
function Yv(e, t) { return qe(t) ? t.findIndex(n => qv(n, e)) : at(t) && qv(t, e) ? 0 : -1; }
const lb = e => e[0] === "_" || e === "$stable", Rp = e => qe(e) ? e.map(Yo) : [Yo(e)], Nk = (e, t, n) => { if (t._n)
    return t; const o = ie((...r) => Rp(t(...r)), n); return o._c = !1, o; }, ab = (e, t, n) => { const o = e._ctx; for (const r in e) {
    if (lb(r))
        continue;
    const s = e[r];
    if (at(s))
        t[r] = Nk(r, s, o);
    else if (s != null) {
        const l = Rp(s);
        t[r] = () => l;
    }
} }, ib = (e, t) => { const n = Rp(t); e.slots.default = () => n; }, Pk = (e, t) => { if (e.vnode.shapeFlag & 32) {
    const n = t._;
    n ? (e.slots = Bt(t), Mu(t, "_", n)) : ab(t, e.slots = {});
}
else
    e.slots = {}, t && ib(e, t); Mu(e.slots, gc, 1); }, Rk = (e, t, n) => { const { vnode: o, slots: r } = e; let s = !0, l = vn; if (o.shapeFlag & 32) {
    const a = t._;
    a ? n && a === 1 ? s = !1 : (Cn(r, t), !n && a === 1 && delete r._) : (s = !t.$stable, ab(t, r)), l = t;
}
else
    t && (ib(e, t), l = { default: 1 }); if (s)
    for (const a in r)
        !lb(a) && !(a in l) && delete r[a]; };
function ef(e, t, n, o, r = !1) { if (qe(e)) {
    e.forEach((p, v) => ef(p, t && (qe(t) ? t[v] : t), n, o, r));
    return;
} if (ga(o) && !r)
    return; const s = o.shapeFlag & 4 ? bc(o.component) || o.component.proxy : o.el, l = r ? null : s, { i: a, r: u } = e, c = t && t.r, d = a.refs === vn ? a.refs = {} : a.refs, f = a.setupState; if (c != null && c !== u && (it(c) ? (d[c] = null, Tt(f, c) && (f[c] = null)) : Jt(c) && (c.value = null)), at(u))
    qr(u, a, 12, [l, d]);
else {
    const p = it(u), v = Jt(u);
    if (p || v) {
        const m = () => { if (e.f) {
            const h = p ? Tt(f, u) ? f[u] : d[u] : u.value;
            r ? qe(h) && gp(h, s) : qe(h) ? h.includes(s) || h.push(s) : p ? (d[u] = [s], Tt(f, u) && (f[u] = d[u])) : (u.value = [s], e.k && (d[e.k] = u.value));
        }
        else
            p ? (d[u] = l, Tt(f, u) && (f[u] = l)) : v && (u.value = l, e.k && (d[e.k] = l)); };
        l ? (m.id = -1, oo(m, n)) : m();
    }
} }
const oo = dk;
function Lk(e) { return Dk(e); }
function Dk(e, t) { const n = Wd(); n.__VUE__ = !0; const { insert: o, remove: r, patchProp: s, createElement: l, createText: a, createComment: u, setText: c, setElementText: d, parentNode: f, nextSibling: p, setScopeId: v = Wt, insertStaticContent: m } = e, h = (q, re, he, Ee = null, Ne = null, Se = null, De = !1, Me = null, $e = !!re.dynamicChildren) => { if (q === re)
    return; q && !Cs(q, re) && (Ee = le(q), Z(q, Ne, Se, !0), q = null), re.patchFlag === -2 && ($e = !1, re.dynamicChildren = null); const { type: Pe, ref: He, shapeFlag: je } = re; switch (Pe) {
    case Ul:
        g(q, re, he, Ee);
        break;
    case Wn:
        y(q, re, he, Ee);
        break;
    case cd:
        q == null && C(re, he, Ee, De);
        break;
    case Qe:
        V(q, re, he, Ee, Ne, Se, De, Me, $e);
        break;
    default: je & 1 ? T(q, re, he, Ee, Ne, Se, De, Me, $e) : je & 6 ? R(q, re, he, Ee, Ne, Se, De, Me, $e) : (je & 64 || je & 128) && Pe.process(q, re, he, Ee, Ne, Se, De, Me, $e, fe);
} He != null && Ne && ef(He, q && q.ref, Se, re || q, !re); }, g = (q, re, he, Ee) => { if (q == null)
    o(re.el = a(re.children), he, Ee);
else {
    const Ne = re.el = q.el;
    re.children !== q.children && c(Ne, re.children);
} }, y = (q, re, he, Ee) => { q == null ? o(re.el = u(re.children || ""), he, Ee) : re.el = q.el; }, C = (q, re, he, Ee) => { [q.el, q.anchor] = m(q.children, re, he, Ee, q.el, q.anchor); }, b = ({ el: q, anchor: re }, he, Ee) => { let Ne; for (; q && q !== re;)
    Ne = p(q), o(q, he, Ee), q = Ne; o(re, he, Ee); }, w = ({ el: q, anchor: re }) => { let he; for (; q && q !== re;)
    he = p(q), r(q), q = he; r(re); }, T = (q, re, he, Ee, Ne, Se, De, Me, $e) => { De = De || re.type === "svg", q == null ? E(re, he, Ee, Ne, Se, De, Me, $e) : L(q, re, Ne, Se, De, Me, $e); }, E = (q, re, he, Ee, Ne, Se, De, Me) => { let $e, Pe; const { type: He, props: je, shapeFlag: Ue, transition: Te, dirs: Ge } = q; if ($e = q.el = l(q.type, Se, je && je.is, je), Ue & 8 ? d($e, q.children) : Ue & 16 && I(q.children, $e, null, Ee, Ne, Se && He !== "foreignObject", De, Me), Ge && hs(q, null, Ee, "created"), x($e, q, q.scopeId, De, Ee), je) {
    for (const X in je)
        X !== "value" && !ru(X) && s($e, X, null, je[X], Se, q.children, Ee, Ne, me);
    "value" in je && s($e, "value", null, je.value), (Pe = je.onVnodeBeforeMount) && qo(Pe, Ee, q);
} Ge && hs(q, null, Ee, "beforeMount"); const W = (!Ne || Ne && !Ne.pendingBranch) && Te && !Te.persisted; W && Te.beforeEnter($e), o($e, re, he), ((Pe = je && je.onVnodeMounted) || W || Ge) && oo(() => { Pe && qo(Pe, Ee, q), W && Te.enter($e), Ge && hs(q, null, Ee, "mounted"); }, Ne); }, x = (q, re, he, Ee, Ne) => { if (he && v(q, he), Ee)
    for (let Se = 0; Se < Ee.length; Se++)
        v(q, Ee[Se]); if (Ne) {
    let Se = Ne.subTree;
    if (re === Se) {
        const De = Ne.vnode;
        x(q, De, De.scopeId, De.slotScopeIds, Ne.parent);
    }
} }, I = (q, re, he, Ee, Ne, Se, De, Me, $e = 0) => { for (let Pe = $e; Pe < q.length; Pe++) {
    const He = q[Pe] = Me ? Vr(q[Pe]) : Yo(q[Pe]);
    h(null, He, re, he, Ee, Ne, Se, De, Me);
} }, L = (q, re, he, Ee, Ne, Se, De) => { const Me = re.el = q.el; let { patchFlag: $e, dynamicChildren: Pe, dirs: He } = re; $e |= q.patchFlag & 16; const je = q.props || vn, Ue = re.props || vn; let Te; he && vs(he, !1), (Te = Ue.onVnodeBeforeUpdate) && qo(Te, he, re, q), He && hs(re, q, he, "beforeUpdate"), he && vs(he, !0); const Ge = Ne && re.type !== "foreignObject"; if (Pe ? B(q.dynamicChildren, Pe, Me, he, Ee, Ge, Se) : De || j(q, re, Me, null, he, Ee, Ge, Se, !1), $e > 0) {
    if ($e & 16)
        F(Me, re, je, Ue, he, Ee, Ne);
    else if ($e & 2 && je.class !== Ue.class && s(Me, "class", null, Ue.class, Ne), $e & 4 && s(Me, "style", je.style, Ue.style, Ne), $e & 8) {
        const W = re.dynamicProps;
        for (let X = 0; X < W.length; X++) {
            const $ = W[X], Y = je[$], H = Ue[$];
            (H !== Y || $ === "value") && s(Me, $, Y, H, Ne, q.children, he, Ee, me);
        }
    }
    $e & 1 && q.children !== re.children && d(Me, re.children);
}
else
    !De && Pe == null && F(Me, re, je, Ue, he, Ee, Ne); ((Te = Ue.onVnodeUpdated) || He) && oo(() => { Te && qo(Te, he, re, q), He && hs(re, q, he, "updated"); }, Ee); }, B = (q, re, he, Ee, Ne, Se, De) => { for (let Me = 0; Me < re.length; Me++) {
    const $e = q[Me], Pe = re[Me], He = $e.el && ($e.type === Qe || !Cs($e, Pe) || $e.shapeFlag & 70) ? f($e.el) : he;
    h($e, Pe, He, null, Ee, Ne, Se, De, !0);
} }, F = (q, re, he, Ee, Ne, Se, De) => { if (he !== Ee) {
    if (he !== vn)
        for (const Me in he)
            !ru(Me) && !(Me in Ee) && s(q, Me, he[Me], null, De, re.children, Ne, Se, me);
    for (const Me in Ee) {
        if (ru(Me))
            continue;
        const $e = Ee[Me], Pe = he[Me];
        $e !== Pe && Me !== "value" && s(q, Me, Pe, $e, De, re.children, Ne, Se, me);
    }
    "value" in Ee && s(q, "value", he.value, Ee.value);
} }, V = (q, re, he, Ee, Ne, Se, De, Me, $e) => { const Pe = re.el = q ? q.el : a(""), He = re.anchor = q ? q.anchor : a(""); let { patchFlag: je, dynamicChildren: Ue, slotScopeIds: Te } = re; Te && (Me = Me ? Me.concat(Te) : Te), q == null ? (o(Pe, he, Ee), o(He, he, Ee), I(re.children, he, He, Ne, Se, De, Me, $e)) : je > 0 && je & 64 && Ue && q.dynamicChildren ? (B(q.dynamicChildren, Ue, he, Ne, Se, De, Me), (re.key != null || Ne && re === Ne.subTree) && Lp(q, re, !0)) : j(q, re, he, He, Ne, Se, De, Me, $e); }, R = (q, re, he, Ee, Ne, Se, De, Me, $e) => { re.slotScopeIds = Me, q == null ? re.shapeFlag & 512 ? Ne.ctx.activate(re, he, Ee, De, $e) : K(re, he, Ee, Ne, Se, De, $e) : te(q, re, $e); }, K = (q, re, he, Ee, Ne, Se, De) => { const Me = q.component = Uk(q, Ee, Ne); if (hc(q) && (Me.ctx.renderer = fe), qk(Me), Me.asyncDep) {
    if (Ne && Ne.registerDep(Me, U), !q.el) {
        const $e = Me.subTree = ee(Wn);
        y(null, $e, re, he);
    }
    return;
} U(Me, q, re, he, Ne, Se, De); }, te = (q, re, he) => { const Ee = re.component = q.component; if (ik(q, re, he))
    if (Ee.asyncDep && !Ee.asyncResolved) {
        D(Ee, re, he);
        return;
    }
    else
        Ee.next = re, ek(Ee.update), Ee.update();
else
    re.el = q.el, Ee.vnode = re; }, U = (q, re, he, Ee, Ne, Se, De) => { const Me = () => { if (q.isMounted) {
    let { next: He, bu: je, u: Ue, parent: Te, vnode: Ge } = q, W = He, X;
    vs(q, !1), He ? (He.el = Ge.el, D(q, He, De)) : He = Ge, je && lu(je), (X = He.props && He.props.onVnodeBeforeUpdate) && qo(X, Te, He, Ge), vs(q, !0);
    const $ = ad(q), Y = q.subTree;
    q.subTree = $, h(Y, $, f(Y.el), le(Y), q, Ne, Se), He.el = $.el, W === null && uk(q, $.el), Ue && oo(Ue, Ne), (X = He.props && He.props.onVnodeUpdated) && oo(() => qo(X, Te, He, Ge), Ne);
}
else {
    let He;
    const { el: je, props: Ue } = re, { bm: Te, m: Ge, parent: W } = q, X = ga(re);
    if (vs(q, !1), Te && lu(Te), !X && (He = Ue && Ue.onVnodeBeforeMount) && qo(He, W, re), vs(q, !0), je && Ae) {
        const $ = () => { q.subTree = ad(q), Ae(je, q.subTree, q, Ne, null); };
        X ? re.type.__asyncLoader().then(() => !q.isUnmounted && $()) : $();
    }
    else {
        const $ = q.subTree = ad(q);
        h(null, $, he, Ee, q, Ne, Se), re.el = $.el;
    }
    if (Ge && oo(Ge, Ne), !X && (He = Ue && Ue.onVnodeMounted)) {
        const $ = re;
        oo(() => qo(He, W, $), Ne);
    }
    (re.shapeFlag & 256 || W && ga(W.vnode) && W.vnode.shapeFlag & 256) && q.a && oo(q.a, Ne), q.isMounted = !0, re = he = Ee = null;
} }, $e = q.effect = new wp(Me, () => Ip(Pe), q.scope), Pe = q.update = () => $e.run(); Pe.id = q.uid, vs(q, !0), Pe(); }, D = (q, re, he) => { re.component = q; const Ee = q.vnode.props; q.vnode = re, q.next = null, Mk(q, re.props, Ee, he), Rk(q, re.children, he), Kl(), Dv(), jl(); }, j = (q, re, he, Ee, Ne, Se, De, Me, $e = !1) => { const Pe = q && q.children, He = q ? q.shapeFlag : 0, je = re.children, { patchFlag: Ue, shapeFlag: Te } = re; if (Ue > 0) {
    if (Ue & 128) {
        G(Pe, je, he, Ee, Ne, Se, De, Me, $e);
        return;
    }
    else if (Ue & 256) {
        A(Pe, je, he, Ee, Ne, Se, De, Me, $e);
        return;
    }
} Te & 8 ? (He & 16 && me(Pe, Ne, Se), je !== Pe && d(he, je)) : He & 16 ? Te & 16 ? G(Pe, je, he, Ee, Ne, Se, De, Me, $e) : me(Pe, Ne, Se, !0) : (He & 8 && d(he, ""), Te & 16 && I(je, he, Ee, Ne, Se, De, Me, $e)); }, A = (q, re, he, Ee, Ne, Se, De, Me, $e) => { q = q || dl, re = re || dl; const Pe = q.length, He = re.length, je = Math.min(Pe, He); let Ue; for (Ue = 0; Ue < je; Ue++) {
    const Te = re[Ue] = $e ? Vr(re[Ue]) : Yo(re[Ue]);
    h(q[Ue], Te, he, null, Ne, Se, De, Me, $e);
} Pe > He ? me(q, Ne, Se, !0, !1, je) : I(re, he, Ee, Ne, Se, De, Me, $e, je); }, G = (q, re, he, Ee, Ne, Se, De, Me, $e) => { let Pe = 0; const He = re.length; let je = q.length - 1, Ue = He - 1; for (; Pe <= je && Pe <= Ue;) {
    const Te = q[Pe], Ge = re[Pe] = $e ? Vr(re[Pe]) : Yo(re[Pe]);
    if (Cs(Te, Ge))
        h(Te, Ge, he, null, Ne, Se, De, Me, $e);
    else
        break;
    Pe++;
} for (; Pe <= je && Pe <= Ue;) {
    const Te = q[je], Ge = re[Ue] = $e ? Vr(re[Ue]) : Yo(re[Ue]);
    if (Cs(Te, Ge))
        h(Te, Ge, he, null, Ne, Se, De, Me, $e);
    else
        break;
    je--, Ue--;
} if (Pe > je) {
    if (Pe <= Ue) {
        const Te = Ue + 1, Ge = Te < He ? re[Te].el : Ee;
        for (; Pe <= Ue;)
            h(null, re[Pe] = $e ? Vr(re[Pe]) : Yo(re[Pe]), he, Ge, Ne, Se, De, Me, $e), Pe++;
    }
}
else if (Pe > Ue)
    for (; Pe <= je;)
        Z(q[Pe], Ne, Se, !0), Pe++;
else {
    const Te = Pe, Ge = Pe, W = new Map;
    for (Pe = Ge; Pe <= Ue; Pe++) {
        const J = re[Pe] = $e ? Vr(re[Pe]) : Yo(re[Pe]);
        J.key != null && W.set(J.key, Pe);
    }
    let X, $ = 0;
    const Y = Ue - Ge + 1;
    let H = !1, ue = 0;
    const de = new Array(Y);
    for (Pe = 0; Pe < Y; Pe++)
        de[Pe] = 0;
    for (Pe = Te; Pe <= je; Pe++) {
        const J = q[Pe];
        if ($ >= Y) {
            Z(J, Ne, Se, !0);
            continue;
        }
        let we;
        if (J.key != null)
            we = W.get(J.key);
        else
            for (X = Ge; X <= Ue; X++)
                if (de[X - Ge] === 0 && Cs(J, re[X])) {
                    we = X;
                    break;
                }
        we === void 0 ? Z(J, Ne, Se, !0) : (de[we - Ge] = Pe + 1, we >= ue ? ue = we : H = !0, h(J, re[we], he, null, Ne, Se, De, Me, $e), $++);
    }
    const be = H ? Bk(de) : dl;
    for (X = be.length - 1, Pe = Y - 1; Pe >= 0; Pe--) {
        const J = Ge + Pe, we = re[J], Ke = J + 1 < He ? re[J + 1].el : Ee;
        de[Pe] === 0 ? h(null, we, he, Ke, Ne, Se, De, Me, $e) : H && (X < 0 || Pe !== be[X] ? se(we, he, Ke, 2) : X--);
    }
} }, se = (q, re, he, Ee, Ne = null) => { const { el: Se, type: De, transition: Me, children: $e, shapeFlag: Pe } = q; if (Pe & 6) {
    se(q.component.subTree, re, he, Ee);
    return;
} if (Pe & 128) {
    q.suspense.move(re, he, Ee);
    return;
} if (Pe & 64) {
    De.move(q, re, he, fe);
    return;
} if (De === Qe) {
    o(Se, re, he);
    for (let je = 0; je < $e.length; je++)
        se($e[je], re, he, Ee);
    o(q.anchor, re, he);
    return;
} if (De === cd) {
    b(q, re, he);
    return;
} if (Ee !== 2 && Pe & 1 && Me)
    if (Ee === 0)
        Me.beforeEnter(Se), o(Se, re, he), oo(() => Me.enter(Se), Ne);
    else {
        const { leave: je, delayLeave: Ue, afterLeave: Te } = Me, Ge = () => o(Se, re, he), W = () => { je(Se, () => { Ge(), Te && Te(); }); };
        Ue ? Ue(Se, Ge, W) : W();
    }
else
    o(Se, re, he); }, Z = (q, re, he, Ee = !1, Ne = !1) => { const { type: Se, props: De, ref: Me, children: $e, dynamicChildren: Pe, shapeFlag: He, patchFlag: je, dirs: Ue } = q; if (Me != null && ef(Me, null, he, q, !0), He & 256) {
    re.ctx.deactivate(q);
    return;
} const Te = He & 1 && Ue, Ge = !ga(q); let W; if (Ge && (W = De && De.onVnodeBeforeUnmount) && qo(W, re, q), He & 6)
    Re(q.component, he, Ee);
else {
    if (He & 128) {
        q.suspense.unmount(he, Ee);
        return;
    }
    Te && hs(q, null, re, "beforeUnmount"), He & 64 ? q.type.remove(q, re, he, Ne, fe, Ee) : Pe && (Se !== Qe || je > 0 && je & 64) ? me(Pe, re, he, !1, !0) : (Se === Qe && je & 384 || !Ne && He & 16) && me($e, re, he), Ee && ce(q);
} (Ge && (W = De && De.onVnodeUnmounted) || Te) && oo(() => { W && qo(W, re, q), Te && hs(q, null, re, "unmounted"); }, he); }, ce = q => { const { type: re, el: he, anchor: Ee, transition: Ne } = q; if (re === Qe) {
    ye(he, Ee);
    return;
} if (re === cd) {
    w(q);
    return;
} const Se = () => { r(he), Ne && !Ne.persisted && Ne.afterLeave && Ne.afterLeave(); }; if (q.shapeFlag & 1 && Ne && !Ne.persisted) {
    const { leave: De, delayLeave: Me } = Ne, $e = () => De(he, Se);
    Me ? Me(q.el, Se, $e) : $e();
}
else
    Se(); }, ye = (q, re) => { let he; for (; q !== re;)
    he = p(q), r(q), q = he; r(re); }, Re = (q, re, he) => { const { bum: Ee, scope: Ne, update: Se, subTree: De, um: Me } = q; Ee && lu(Ee), Ne.stop(), Se && (Se.active = !1, Z(De, q, re, he)), Me && oo(Me, re), oo(() => { q.isUnmounted = !0; }, re), re && re.pendingBranch && !re.isUnmounted && q.asyncDep && !q.asyncResolved && q.suspenseId === re.pendingId && (re.deps--, re.deps === 0 && re.resolve()); }, me = (q, re, he, Ee = !1, Ne = !1, Se = 0) => { for (let De = Se; De < q.length; De++)
    Z(q[De], re, he, Ee, Ne); }, le = q => q.shapeFlag & 6 ? le(q.component.subTree) : q.shapeFlag & 128 ? q.suspense.next() : p(q.anchor || q.el), oe = (q, re, he) => { q == null ? re._vnode && Z(re._vnode, null, null, !0) : h(re._vnode || null, q, re, null, null, null, he), Dv(), Ky(), re._vnode = q; }, fe = { p: h, um: Z, m: se, r: ce, mt: K, mc: I, pc: j, pbc: B, n: le, o: e }; let Ce, Ae; return t && ([Ce, Ae] = t(fe)), { render: oe, hydrate: Ce, createApp: xk(oe, Ce) }; }
function vs({ effect: e, update: t }, n) { e.allowRecurse = t.allowRecurse = n; }
function Lp(e, t, n = !1) { const o = e.children, r = t.children; if (qe(o) && qe(r))
    for (let s = 0; s < o.length; s++) {
        const l = o[s];
        let a = r[s];
        a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = r[s] = Vr(r[s]), a.el = l.el), n || Lp(l, a)), a.type === Ul && (a.el = l.el);
    } }
function Bk(e) { const t = e.slice(), n = [0]; let o, r, s, l, a; const u = e.length; for (o = 0; o < u; o++) {
    const c = e[o];
    if (c !== 0) {
        if (r = n[n.length - 1], e[r] < c) {
            t[o] = r, n.push(o);
            continue;
        }
        for (s = 0, l = n.length - 1; s < l;)
            a = s + l >> 1, e[n[a]] < c ? s = a + 1 : l = a;
        c < e[n[s]] && (s > 0 && (t[o] = n[s - 1]), n[s] = o);
    }
} for (s = n.length, l = n[s - 1]; s-- > 0;)
    n[s] = l, l = t[l]; return n; }
const Fk = e => e.__isTeleport, ba = e => e && (e.disabled || e.disabled === ""), Gv = e => typeof SVGElement < "u" && e instanceof SVGElement, tf = (e, t) => { const n = e && e.to; return it(n) ? t ? t(n) : null : n; }, Vk = { __isTeleport: !0, process(e, t, n, o, r, s, l, a, u, c) { const { mc: d, pc: f, pbc: p, o: { insert: v, querySelector: m, createText: h, createComment: g } } = c, y = ba(t.props); let { shapeFlag: C, children: b, dynamicChildren: w } = t; if (e == null) {
        const T = t.el = h(""), E = t.anchor = h("");
        v(T, n, o), v(E, n, o);
        const x = t.target = tf(t.props, m), I = t.targetAnchor = h("");
        x && (v(I, x), l = l || Gv(x));
        const L = (B, F) => { C & 16 && d(b, B, F, r, s, l, a, u); };
        y ? L(n, E) : x && L(x, I);
    }
    else {
        t.el = e.el;
        const T = t.anchor = e.anchor, E = t.target = e.target, x = t.targetAnchor = e.targetAnchor, I = ba(e.props), L = I ? n : E, B = I ? T : x;
        if (l = l || Gv(E), w ? (p(e.dynamicChildren, w, L, r, s, l, a), Lp(e, t, !0)) : u || f(e, t, L, B, r, s, l, a, !1), y)
            I || Fi(t, n, T, c, 1);
        else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
            const F = t.target = tf(t.props, m);
            F && Fi(t, F, null, c, 0);
        }
        else
            I && Fi(t, E, x, c, 1);
    } ub(t); }, remove(e, t, n, o, { um: r, o: { remove: s } }, l) { const { shapeFlag: a, children: u, anchor: c, targetAnchor: d, target: f, props: p } = e; if (f && s(d), (l || !ba(p)) && (s(c), a & 16))
        for (let v = 0; v < u.length; v++) {
            const m = u[v];
            r(m, t, n, !0, !!m.dynamicChildren);
        } }, move: Fi, hydrate: zk };
function Fi(e, t, n, { o: { insert: o }, m: r }, s = 2) { s === 0 && o(e.targetAnchor, t, n); const { el: l, anchor: a, shapeFlag: u, children: c, props: d } = e, f = s === 2; if (f && o(l, t, n), (!f || ba(d)) && u & 16)
    for (let p = 0; p < c.length; p++)
        r(c[p], t, n, 2); f && o(a, t, n); }
function zk(e, t, n, o, r, s, { o: { nextSibling: l, parentNode: a, querySelector: u } }, c) { const d = t.target = tf(t.props, u); if (d) {
    const f = d._lpa || d.firstChild;
    if (t.shapeFlag & 16)
        if (ba(t.props))
            t.anchor = c(l(e), t, a(e), n, o, r, s), t.targetAnchor = f;
        else {
            t.anchor = l(e);
            let p = f;
            for (; p;)
                if (p = l(p), p && p.nodeType === 8 && p.data === "teleport anchor") {
                    t.targetAnchor = p, d._lpa = t.targetAnchor && l(t.targetAnchor);
                    break;
                }
            c(f, t, d, n, o, r, s);
        }
    ub(t);
} return t.anchor && l(t.anchor); }
const mi = Vk;
function ub(e) { const t = e.ctx; if (t && t.ut) {
    let n = e.children[0].el;
    for (; n !== e.targetAnchor;)
        n.nodeType === 1 && n.setAttribute("data-v-owner", t.uid), n = n.nextSibling;
    t.ut();
} }
const Qe = Symbol.for("v-fgt"), Ul = Symbol.for("v-txt"), Wn = Symbol.for("v-cmt"), cd = Symbol.for("v-stc"), wa = [];
let Do = null;
function k(e = !1) { wa.push(Do = e ? null : []); }
exports.o = k;
function Hk() { wa.pop(), Do = wa[wa.length - 1] || null; }
let za = 1;
function Xv(e) { za += e; }
function cb(e) { return e.dynamicChildren = za > 0 ? Do || dl : null, Hk(), za > 0 && Do && Do.push(e), e; }
function z(e, t, n, o, r, s) { return cb(Q(e, t, n, o, r, s, !0)); }
exports.c = z;
function ge(e, t, n, o, r) { return cb(ee(e, t, n, o, r, !0)); }
function un(e) { return e ? e.__v_isVNode === !0 : !1; }
function Cs(e, t) { return e.type === t.type && e.key === t.key; }
const gc = "__vInternal", db = ({ key: e }) => e ?? null, au = ({ ref: e, ref_key: t, ref_for: n }) => (typeof e == "number" && (e = "" + e), e != null ? it(e) || Jt(e) || at(e) ? { i: Rn, r: e, k: t, f: !!n } : e : null);
function Q(e, t = null, n = null, o = 0, r = null, s = e === Qe ? 0 : 1, l = !1, a = !1) { const u = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && db(t), ref: t && au(t), scopeId: pc, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag: s, patchFlag: o, dynamicProps: r, dynamicChildren: null, appContext: null, ctx: Rn }; return a ? (Dp(u, n), s & 128 && e.normalize(u)) : n && (u.shapeFlag |= it(n) ? 8 : 16), za > 0 && !l && Do && (u.patchFlag > 0 || s & 6) && u.patchFlag !== 32 && Do.push(u), u; }
exports.a = Q;
const ee = Kk;
function Kk(e, t = null, n = null, o = 0, r = null, s = !1) { if ((!e || e === Qy) && (e = Wn), un(e)) {
    const a = Sr(e, t, !0);
    return n && Dp(a, n), za > 0 && !s && Do && (a.shapeFlag & 6 ? Do[Do.indexOf(e)] = a : Do.push(a)), a.patchFlag |= -2, a;
} if (Jk(e) && (e = e.__vccOpts), t) {
    t = yc(t);
    let { class: a, style: u } = t;
    a && !it(a) && (t.class = O(a)), yt(u) && (Ry(u) && !qe(u) && (u = Cn({}, u)), t.style = et(u));
} const l = it(e) ? 1 : ck(e) ? 128 : Fk(e) ? 64 : yt(e) ? 4 : at(e) ? 2 : 0; return Q(e, t, n, o, r, l, s, !0); }
function yc(e) { return e ? Ry(e) || gc in e ? Cn({}, e) : e : null; }
function Sr(e, t, n = !1) { const { props: o, ref: r, patchFlag: s, children: l } = e, a = t ? Ct(o || {}, t) : o; return { __v_isVNode: !0, __v_skip: !0, type: e.type, props: a, key: a && db(a), ref: t && t.ref ? n && r ? qe(r) ? r.concat(au(t)) : [r, au(t)] : au(t) : r, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: l, target: e.target, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== Qe ? s === -1 ? 16 : s | 16 : s, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: e.transition, component: e.component, suspense: e.suspense, ssContent: e.ssContent && Sr(e.ssContent), ssFallback: e.ssFallback && Sr(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce }; }
function Ot(e = " ", t = 0) { return ee(Ul, null, e, t); }
function pe(e = "", t = !1) { return t ? (k(), ge(Wn, null, e)) : ee(Wn, null, e); }
function Yo(e) { return e == null || typeof e == "boolean" ? ee(Wn) : qe(e) ? ee(Qe, null, e.slice()) : typeof e == "object" ? Vr(e) : ee(Ul, null, String(e)); }
function Vr(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : Sr(e); }
function Dp(e, t) { let n = 0; const { shapeFlag: o } = e; if (t == null)
    t = null;
else if (qe(t))
    n = 16;
else if (typeof t == "object")
    if (o & 65) {
        const r = t.default;
        r && (r._c && (r._d = !1), Dp(e, r()), r._c && (r._d = !0));
        return;
    }
    else {
        n = 32;
        const r = t._;
        !r && !(gc in t) ? t._ctx = Rn : r === 3 && Rn && (Rn.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024));
    }
else
    at(t) ? (t = { default: t, _ctx: Rn }, n = 32) : (t = String(t), o & 64 ? (n = 16, t = [Ot(t)]) : n = 8); e.children = t, e.shapeFlag |= n; }
function Ct(...e) { const t = {}; for (let n = 0; n < e.length; n++) {
    const o = e[n];
    for (const r in o)
        if (r === "class")
            t.class !== o.class && (t.class = O([t.class, o.class]));
        else if (r === "style")
            t.style = et([t.style, o.style]);
        else if (lc(r)) {
            const s = t[r], l = o[r];
            l && s !== l && !(qe(s) && s.includes(l)) && (t[r] = s ? [].concat(s, l) : l);
        }
        else
            r !== "" && (t[r] = o[r]);
} return t; }
function qo(e, t, n, o = null) { So(e, t, 7, [n, o]); }
const jk = ob();
let Wk = 0;
function Uk(e, t, n) { const o = e.type, r = (t ? t.appContext : e.appContext) || jk, s = { uid: Wk++, vnode: e, type: o, parent: t, appContext: r, root: null, next: null, subTree: null, effect: null, update: null, scope: new Sy(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(r.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: sb(o, r), emitsOptions: Wy(o, r), emit: null, emitted: null, propsDefaults: vn, inheritAttrs: o.inheritAttrs, ctx: vn, data: vn, props: vn, attrs: vn, slots: vn, refs: vn, setupState: vn, setupContext: null, attrsProxy: null, slotsProxy: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return s.ctx = { _: s }, s.root = t ? t.root : s, s.emit = ok.bind(null, s), e.ce && e.ce(s), s; }
let In = null;
const ht = () => In || Rn;
let Bp, Js, Jv = "__VUE_INSTANCE_SETTERS__";
(Js = Wd()[Jv]) || (Js = Wd()[Jv] = []), Js.push(e => In = e), Bp = e => { Js.length > 1 ? Js.forEach(t => t(e)) : Js[0](e); };
const _l = e => { Bp(e), e.scope.on(); }, Ps = () => { In && In.scope.off(), Bp(null); };
function fb(e) { return e.vnode.shapeFlag & 4; }
let Ha = !1;
function qk(e, t = !1) { Ha = t; const { props: n, children: o } = e.vnode, r = fb(e); Ak(e, n, r, t), Pk(e, o); const s = r ? Yk(e, t) : void 0; return Ha = !1, s; }
function Yk(e, t) { const n = e.type; e.accessCache = Object.create(null), e.proxy = Ns(new Proxy(e.ctx, _k)); const { setup: o } = n; if (o) {
    const r = e.setupContext = o.length > 1 ? hb(e) : null;
    _l(e), Kl();
    const s = qr(o, e, 0, [e.props, r]);
    if (jl(), Ps(), Na(s)) {
        if (s.then(Ps, Ps), t)
            return s.then(l => { Zv(e, l, t); }).catch(l => { dc(l, e, 0); });
        e.asyncDep = s;
    }
    else
        Zv(e, s, t);
}
else
    pb(e, t); }
function Zv(e, t, n) { at(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : yt(t) && (e.setupState = By(t)), pb(e, n); }
let Qv;
function pb(e, t, n) { const o = e.type; if (!e.render) {
    if (!t && Qv && !o.render) {
        const r = o.template || Pp(e).template;
        if (r) {
            const { isCustomElement: s, compilerOptions: l } = e.appContext.config, { delimiters: a, compilerOptions: u } = o, c = Cn(Cn({ isCustomElement: s, delimiters: a }, l), u);
            o.render = Qv(r, c);
        }
    }
    e.render = o.render || Wt;
} _l(e), Kl(), kk(e), jl(), Ps(); }
function Gk(e) { return e.attrsProxy || (e.attrsProxy = new Proxy(e.attrs, { get(t, n) { return io(e, "get", "$attrs"), t[n]; } })); }
function hb(e) { const t = n => { e.exposed = n || {}; }; return { get attrs() { return Gk(e); }, slots: e.slots, emit: e.emit, expose: t }; }
function bc(e) { if (e.exposed)
    return e.exposeProxy || (e.exposeProxy = new Proxy(By(Ns(e.exposed)), { get(t, n) { if (n in t)
            return t[n]; if (n in ya)
            return ya[n](e); }, has(t, n) { return n in t || n in ya; } })); }
function Xk(e, t = !0) { return at(e) ? e.displayName || e.name : e.name || t && e.__name; }
function Jk(e) { return at(e) && "__vccOpts" in e; }
const S = (e, t) => Vy(e, t, Ha);
function nt(e, t, n) { const o = arguments.length; return o === 2 ? yt(t) && !qe(t) ? un(t) ? ee(e, null, [t]) : ee(e, t) : ee(e, null, t) : (o > 3 ? n = Array.prototype.slice.call(arguments, 2) : o === 3 && un(n) && (n = [n]), ee(e, t, n)); }
const Zk = Symbol.for("v-scx"), Qk = () => Ye(Zk), eE = "3.3.4", tE = "http://www.w3.org/2000/svg", Ss = typeof document < "u" ? document : null, em = Ss && Ss.createElement("template"), nE = { insert: (e, t, n) => { t.insertBefore(e, n || null); }, remove: e => { const t = e.parentNode; t && t.removeChild(e); }, createElement: (e, t, n, o) => { const r = t ? Ss.createElementNS(tE, e) : Ss.createElement(e, n ? { is: n } : void 0); return e === "select" && o && o.multiple != null && r.setAttribute("multiple", o.multiple), r; }, createText: e => Ss.createTextNode(e), createComment: e => Ss.createComment(e), setText: (e, t) => { e.nodeValue = t; }, setElementText: (e, t) => { e.textContent = t; }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => Ss.querySelector(e), setScopeId(e, t) { e.setAttribute(t, ""); }, insertStaticContent(e, t, n, o, r, s) { const l = n ? n.previousSibling : t.lastChild; if (r && (r === s || r.nextSibling))
        for (; t.insertBefore(r.cloneNode(!0), n), !(r === s || !(r = r.nextSibling));)
            ;
    else {
        em.innerHTML = o ? `<svg>${e}</svg>` : e;
        const a = em.content;
        if (o) {
            const u = a.firstChild;
            for (; u.firstChild;)
                a.appendChild(u.firstChild);
            a.removeChild(u);
        }
        t.insertBefore(a, n);
    } return [l ? l.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]; } };
function oE(e, t, n) { const o = e._vtc; o && (t = (t ? [t, ...o] : [...o]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t; }
function rE(e, t, n) { const o = e.style, r = it(n); if (n && !r) {
    if (t && !it(t))
        for (const s in t)
            n[s] == null && nf(o, s, "");
    for (const s in n)
        nf(o, s, n[s]);
}
else {
    const s = o.display;
    r ? t !== n && (o.cssText = n) : t && e.removeAttribute("style"), "_vod" in e && (o.display = s);
} }
const tm = /\s*!important$/;
function nf(e, t, n) { if (qe(n))
    n.forEach(o => nf(e, t, o));
else if (n == null && (n = ""), t.startsWith("--"))
    e.setProperty(t, n);
else {
    const o = sE(e, t);
    tm.test(n) ? e.setProperty(os(o), n.replace(tm, ""), "important") : e[o] = n;
} }
const nm = ["Webkit", "Moz", "ms"], dd = {};
function sE(e, t) { const n = dd[t]; if (n)
    return n; let o = Eo(t); if (o !== "filter" && o in e)
    return dd[t] = o; o = vi(o); for (let r = 0; r < nm.length; r++) {
    const s = nm[r] + o;
    if (s in e)
        return dd[t] = s;
} return t; }
const om = "http://www.w3.org/1999/xlink";
function lE(e, t, n, o, r) { if (o && t.startsWith("xlink:"))
    n == null ? e.removeAttributeNS(om, t.slice(6, t.length)) : e.setAttributeNS(om, t, n);
else {
    const s = v_(t);
    n == null || s && !by(n) ? e.removeAttribute(t) : e.setAttribute(t, s ? "" : n);
} }
function aE(e, t, n, o, r, s, l) { if (t === "innerHTML" || t === "textContent") {
    o && l(o, r, s), e[t] = n ?? "";
    return;
} const a = e.tagName; if (t === "value" && a !== "PROGRESS" && !a.includes("-")) {
    e._value = n;
    const c = a === "OPTION" ? e.getAttribute("value") : e.value, d = n ?? "";
    c !== d && (e.value = d), n == null && e.removeAttribute(t);
    return;
} let u = !1; if (n === "" || n == null) {
    const c = typeof e[t];
    c === "boolean" ? n = by(n) : n == null && c === "string" ? (n = "", u = !0) : c === "number" && (n = 0, u = !0);
} try {
    e[t] = n;
}
catch { } u && e.removeAttribute(t); }
function Hr(e, t, n, o) { e.addEventListener(t, n, o); }
function iE(e, t, n, o) { e.removeEventListener(t, n, o); }
function uE(e, t, n, o, r = null) { const s = e._vei || (e._vei = {}), l = s[t]; if (o && l)
    l.value = o;
else {
    const [a, u] = cE(t);
    if (o) {
        const c = s[t] = pE(o, r);
        Hr(e, a, c, u);
    }
    else
        l && (iE(e, a, l, u), s[t] = void 0);
} }
const rm = /(?:Once|Passive|Capture)$/;
function cE(e) { let t; if (rm.test(e)) {
    t = {};
    let o;
    for (; o = e.match(rm);)
        e = e.slice(0, e.length - o[0].length), t[o[0].toLowerCase()] = !0;
} return [e[2] === ":" ? e.slice(3) : os(e.slice(2)), t]; }
let fd = 0;
const dE = Promise.resolve(), fE = () => fd || (dE.then(() => fd = 0), fd = Date.now());
function pE(e, t) { const n = o => { if (!o._vts)
    o._vts = Date.now();
else if (o._vts <= n.attached)
    return; So(hE(o, n.value), t, 5, [o]); }; return n.value = e, n.attached = fE(), n; }
function hE(e, t) { if (qe(t)) {
    const n = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => { n.call(e), e._stopped = !0; }, t.map(o => r => !r._stopped && o && o(r));
}
else
    return t; }
const sm = /^on[a-z]/, vE = (e, t, n, o, r = !1, s, l, a, u) => { t === "class" ? oE(e, o, r) : t === "style" ? rE(e, n, o) : lc(t) ? mp(t) || uE(e, t, n, o, l) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : mE(e, t, o, r)) ? aE(e, t, o, s, l, a, u) : (t === "true-value" ? e._trueValue = o : t === "false-value" && (e._falseValue = o), lE(e, t, o, r)); };
function mE(e, t, n, o) { return o ? !!(t === "innerHTML" || t === "textContent" || t in e && sm.test(t) && at(n)) : t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA" || sm.test(t) && it(n) ? !1 : t in e; }
const Nr = "transition", ra = "animation", yn = (e, { slots: t }) => nt(hk, mb(e), t);
yn.displayName = "Transition";
const vb = { name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }, gE = yn.props = Cn({}, Yy, vb), ms = (e, t = []) => { qe(e) ? e.forEach(n => n(...t)) : e && e(...t); }, lm = e => e ? qe(e) ? e.some(t => t.length > 1) : e.length > 1 : !1;
function mb(e) { const t = {}; for (const V in e)
    V in vb || (t[V] = e[V]); if (e.css === !1)
    return t; const { name: n = "v", type: o, duration: r, enterFromClass: s = `${n}-enter-from`, enterActiveClass: l = `${n}-enter-active`, enterToClass: a = `${n}-enter-to`, appearFromClass: u = s, appearActiveClass: c = l, appearToClass: d = a, leaveFromClass: f = `${n}-leave-from`, leaveActiveClass: p = `${n}-leave-active`, leaveToClass: v = `${n}-leave-to` } = e, m = yE(r), h = m && m[0], g = m && m[1], { onBeforeEnter: y, onEnter: C, onEnterCancelled: b, onLeave: w, onLeaveCancelled: T, onBeforeAppear: E = y, onAppear: x = C, onAppearCancelled: I = b } = t, L = (V, R, K) => { Lr(V, R ? d : a), Lr(V, R ? c : l), K && K(); }, B = (V, R) => { V._isLeaving = !1, Lr(V, f), Lr(V, v), Lr(V, p), R && R(); }, F = V => (R, K) => { const te = V ? x : C, U = () => L(R, V, K); ms(te, [R, U]), am(() => { Lr(R, V ? u : s), fr(R, V ? d : a), lm(te) || im(R, o, h, U); }); }; return Cn(t, { onBeforeEnter(V) { ms(y, [V]), fr(V, s), fr(V, l); }, onBeforeAppear(V) { ms(E, [V]), fr(V, u), fr(V, c); }, onEnter: F(!1), onAppear: F(!0), onLeave(V, R) { V._isLeaving = !0; const K = () => B(V, R); fr(V, f), yb(), fr(V, p), am(() => { V._isLeaving && (Lr(V, f), fr(V, v), lm(w) || im(V, o, g, K)); }), ms(w, [V, K]); }, onEnterCancelled(V) { L(V, !1), ms(b, [V]); }, onAppearCancelled(V) { L(V, !0), ms(I, [V]); }, onLeaveCancelled(V) { B(V), ms(T, [V]); } }); }
function yE(e) { if (e == null)
    return null; if (yt(e))
    return [pd(e.enter), pd(e.leave)]; {
    const t = pd(e);
    return [t, t];
} }
function pd(e) { return u_(e); }
function fr(e, t) { t.split(/\s+/).forEach(n => n && e.classList.add(n)), (e._vtc || (e._vtc = new Set)).add(t); }
function Lr(e, t) { t.split(/\s+/).forEach(o => o && e.classList.remove(o)); const { _vtc: n } = e; n && (n.delete(t), n.size || (e._vtc = void 0)); }
function am(e) { requestAnimationFrame(() => { requestAnimationFrame(e); }); }
let bE = 0;
function im(e, t, n, o) { const r = e._endId = ++bE, s = () => { r === e._endId && o(); }; if (n)
    return setTimeout(s, n); const { type: l, timeout: a, propCount: u } = gb(e, t); if (!l)
    return o(); const c = l + "end"; let d = 0; const f = () => { e.removeEventListener(c, p), s(); }, p = v => { v.target === e && ++d >= u && f(); }; setTimeout(() => { d < u && f(); }, a + 1), e.addEventListener(c, p); }
function gb(e, t) { const n = window.getComputedStyle(e), o = m => (n[m] || "").split(", "), r = o(`${Nr}Delay`), s = o(`${Nr}Duration`), l = um(r, s), a = o(`${ra}Delay`), u = o(`${ra}Duration`), c = um(a, u); let d = null, f = 0, p = 0; t === Nr ? l > 0 && (d = Nr, f = l, p = s.length) : t === ra ? c > 0 && (d = ra, f = c, p = u.length) : (f = Math.max(l, c), d = f > 0 ? l > c ? Nr : ra : null, p = d ? d === Nr ? s.length : u.length : 0); const v = d === Nr && /\b(transform|all)(,|$)/.test(o(`${Nr}Property`).toString()); return { type: d, timeout: f, propCount: p, hasTransform: v }; }
function um(e, t) { for (; e.length < t.length;)
    e = e.concat(e); return Math.max(...t.map((n, o) => cm(n) + cm(e[o]))); }
function cm(e) { return Number(e.slice(0, -1).replace(",", ".")) * 1e3; }
function yb() { return document.body.offsetHeight; }
const bb = new WeakMap, wb = new WeakMap, Cb = { name: "TransitionGroup", props: Cn({}, gE, { tag: String, moveClass: String }), setup(e, { slots: t }) { const n = ht(), o = qy(); let r, s; return Er(() => { if (!r.length)
        return; const l = e.moveClass || `${e.name || "v"}-move`; if (!kE(r[0].el, n.vnode.el, l))
        return; r.forEach(CE), r.forEach(SE); const a = r.filter(_E); yb(), a.forEach(u => { const c = u.el, d = c.style; fr(c, l), d.transform = d.webkitTransform = d.transitionDuration = ""; const f = c._moveCb = p => { p && p.target !== c || (!p || /transform$/.test(p.propertyName)) && (c.removeEventListener("transitionend", f), c._moveCb = null, Lr(c, l)); }; c.addEventListener("transitionend", f); }); }), () => { const l = Bt(e), a = mb(l); let u = l.tag || Qe; r = s, s = t.default ? Ap(t.default()) : []; for (let c = 0; c < s.length; c++) {
        const d = s[c];
        d.key != null && Fa(d, Ba(d, a, o, n));
    } if (r)
        for (let c = 0; c < r.length; c++) {
            const d = r[c];
            Fa(d, Ba(d, a, o, n)), bb.set(d, d.el.getBoundingClientRect());
        } return ee(u, null, s); }; } }, wE = e => delete e.mode;
Cb.props;
const Sb = Cb;
function CE(e) { const t = e.el; t._moveCb && t._moveCb(), t._enterCb && t._enterCb(); }
function SE(e) { wb.set(e, e.el.getBoundingClientRect()); }
function _E(e) { const t = bb.get(e), n = wb.get(e), o = t.left - n.left, r = t.top - n.top; if (o || r) {
    const s = e.el.style;
    return s.transform = s.webkitTransform = `translate(${o}px,${r}px)`, s.transitionDuration = "0s", e;
} }
function kE(e, t, n) { const o = e.cloneNode(); e._vtc && e._vtc.forEach(l => { l.split(/\s+/).forEach(a => a && o.classList.remove(a)); }), n.split(/\s+/).forEach(l => l && o.classList.add(l)), o.style.display = "none"; const r = t.nodeType === 1 ? t : t.parentNode; r.appendChild(o); const { hasTransform: s } = gb(o); return r.removeChild(o), s; }
const kl = e => { const t = e.props["onUpdate:modelValue"] || !1; return qe(t) ? n => lu(t, n) : t; };
function EE(e) { e.target.composing = !0; }
function dm(e) { const t = e.target; t.composing && (t.composing = !1, t.dispatchEvent(new Event("input"))); }
const Fp = { created(e, { modifiers: { lazy: t, trim: n, number: o } }, r) { e._assign = kl(r); const s = o || r.props && r.props.type === "number"; Hr(e, t ? "change" : "input", l => { if (l.target.composing)
        return; let a = e.value; n && (a = a.trim()), s && (a = jd(a)), e._assign(a); }), n && Hr(e, "change", () => { e.value = e.value.trim(); }), t || (Hr(e, "compositionstart", EE), Hr(e, "compositionend", dm), Hr(e, "change", dm)); }, mounted(e, { value: t }) { e.value = t ?? ""; }, beforeUpdate(e, { value: t, modifiers: { lazy: n, trim: o, number: r } }, s) { if (e._assign = kl(s), e.composing || document.activeElement === e && e.type !== "range" && (n || o && e.value.trim() === t || (r || e.type === "number") && jd(e.value) === t))
        return; const l = t ?? ""; e.value !== l && (e.value = l); } }, Bu = { deep: !0, created(e, t, n) { e._assign = kl(n), Hr(e, "change", () => { const o = e._modelValue, r = kb(e), s = e.checked, l = e._assign; if (qe(o)) {
        const a = wy(o, r), u = a !== -1;
        if (s && !u)
            l(o.concat(r));
        else if (!s && u) {
            const c = [...o];
            c.splice(a, 1), l(c);
        }
    }
    else if (ac(o)) {
        const a = new Set(o);
        s ? a.add(r) : a.delete(r), l(a);
    }
    else
        l(Eb(e, s)); }); }, mounted: fm, beforeUpdate(e, t, n) { e._assign = kl(n), fm(e, t, n); } };
function fm(e, { value: t, oldValue: n }, o) { e._modelValue = t, qe(t) ? e.checked = wy(t, o.props.value) > -1 : ac(t) ? e.checked = t.has(o.props.value) : t !== n && (e.checked = Cl(t, Eb(e, !0))); }
const _b = { created(e, { value: t }, n) { e.checked = Cl(t, n.props.value), e._assign = kl(n), Hr(e, "change", () => { e._assign(kb(e)); }); }, beforeUpdate(e, { value: t, oldValue: n }, o) { e._assign = kl(o), t !== n && (e.checked = Cl(t, o.props.value)); } };
function kb(e) { return "_value" in e ? e._value : e.value; }
function Eb(e, t) { const n = t ? "_trueValue" : "_falseValue"; return n in e ? e[n] : t; }
const $E = ["ctrl", "shift", "alt", "meta"], TE = { stop: e => e.stopPropagation(), prevent: e => e.preventDefault(), self: e => e.target !== e.currentTarget, ctrl: e => !e.ctrlKey, shift: e => !e.shiftKey, alt: e => !e.altKey, meta: e => !e.metaKey, left: e => "button" in e && e.button !== 0, middle: e => "button" in e && e.button !== 1, right: e => "button" in e && e.button !== 2, exact: (e, t) => $E.some(n => e[`${n}Key`] && !t.includes(n)) }, st = (e, t) => (n, ...o) => { for (let r = 0; r < t.length; r++) {
    const s = TE[t[r]];
    if (s && s(n, t))
        return;
} return e(n, ...o); }, OE = { esc: "escape", space: " ", up: "arrow-up", left: "arrow-left", right: "arrow-right", down: "arrow-down", delete: "backspace" }, Mt = (e, t) => n => { if (!("key" in n))
    return; const o = os(n.key); if (t.some(r => r === o || OE[r] === o))
    return e(n); }, Pt = { beforeMount(e, { value: t }, { transition: n }) { e._vod = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : sa(e, t); }, mounted(e, { value: t }, { transition: n }) { n && t && n.enter(e); }, updated(e, { value: t, oldValue: n }, { transition: o }) { !t != !n && (o ? t ? (o.beforeEnter(e), sa(e, !0), o.enter(e)) : o.leave(e, () => { sa(e, !1); }) : sa(e, t)); }, beforeUnmount(e, { value: t }) { sa(e, t); } };
function sa(e, t) { e.style.display = t ? e._vod : "none"; }
const IE = Cn({ patchProp: vE }, nE);
let pm;
function $b() { return pm || (pm = Lk(IE)); }
const El = (...e) => { $b().render(...e); }, Tb = (...e) => { const t = $b().createApp(...e), { mount: n } = t; return t.mount = o => { const r = xE(o); if (!r)
    return; const s = t._component; !at(s) && !s.render && !s.template && (s.template = r.innerHTML), r.innerHTML = ""; const l = n(r, !1, r instanceof SVGElement); return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), l; }, t; };
function xE(e) { return it(e) ? document.querySelector(e) : e; }
const AE = "modulepreload", ME = function (e) { return "/" + e; }, hm = {}, NE = function (t, n, o) { if (!n || n.length === 0)
    return t(); const r = document.getElementsByTagName("link"); return Promise.all(n.map(s => { if (s = ME(s), s in hm)
    return; hm[s] = !0; const l = s.endsWith(".css"), a = l ? '[rel="stylesheet"]' : ""; if (!!o)
    for (let d = r.length - 1; d >= 0; d--) {
        const f = r[d];
        if (f.href === s && (!l || f.rel === "stylesheet"))
            return;
    }
else if (document.querySelector(`link[href="${s}"]${a}`))
    return; const c = document.createElement("link"); if (c.rel = l ? "stylesheet" : AE, l || (c.as = "script", c.crossOrigin = ""), c.href = s, document.head.appendChild(c), l)
    return new Promise((d, f) => { c.addEventListener("load", d), c.addEventListener("error", () => f(new Error(`Unable to preload CSS for ${s}`))); }); })).then(() => t()).catch(s => { const l = new Event("vite:preloadError", { cancelable: !0 }); if (l.payload = s, window.dispatchEvent(l), !l.defaultPrevented)
    throw s; }); }; /*!
  * vue-router v4.2.4
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
const nl = typeof window < "u";
function PE(e) { return e.__esModule || e[Symbol.toStringTag] === "Module"; }
const tn = Object.assign;
function hd(e, t) { const n = {}; for (const o in t) {
    const r = t[o];
    n[o] = zo(r) ? r.map(e) : e(r);
} return n; }
const Ca = () => { }, zo = Array.isArray, RE = /\/$/, LE = e => e.replace(RE, "");
function vd(e, t, n = "/") { let o, r = {}, s = "", l = ""; const a = t.indexOf("#"); let u = t.indexOf("?"); return a < u && a >= 0 && (u = -1), u > -1 && (o = t.slice(0, u), s = t.slice(u + 1, a > -1 ? a : t.length), r = e(s)), a > -1 && (o = o || t.slice(0, a), l = t.slice(a, t.length)), o = VE(o ?? t, n), { fullPath: o + (s && "?") + s + l, path: o, query: r, hash: l }; }
function DE(e, t) { const n = t.query ? e(t.query) : ""; return t.path + (n && "?") + n + (t.hash || ""); }
function vm(e, t) { return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/"; }
function BE(e, t, n) { const o = t.matched.length - 1, r = n.matched.length - 1; return o > -1 && o === r && $l(t.matched[o], n.matched[r]) && Ob(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash; }
function $l(e, t) { return (e.aliasOf || e) === (t.aliasOf || t); }
function Ob(e, t) { if (Object.keys(e).length !== Object.keys(t).length)
    return !1; for (const n in e)
    if (!FE(e[n], t[n]))
        return !1; return !0; }
function FE(e, t) { return zo(e) ? mm(e, t) : zo(t) ? mm(t, e) : e === t; }
function mm(e, t) { return zo(t) ? e.length === t.length && e.every((n, o) => n === t[o]) : e.length === 1 && e[0] === t; }
function VE(e, t) { if (e.startsWith("/"))
    return e; if (!e)
    return t; const n = t.split("/"), o = e.split("/"), r = o[o.length - 1]; (r === ".." || r === ".") && o.push(""); let s = n.length - 1, l, a; for (l = 0; l < o.length; l++)
    if (a = o[l], a !== ".")
        if (a === "..")
            s > 1 && s--;
        else
            break; return n.slice(0, s).join("/") + "/" + o.slice(l - (l === o.length ? 1 : 0)).join("/"); }
var Ka;
(function (e) { e.pop = "pop", e.push = "push"; })(Ka || (Ka = {}));
var Sa;
(function (e) { e.back = "back", e.forward = "forward", e.unknown = ""; })(Sa || (Sa = {}));
function zE(e) { if (!e)
    if (nl) {
        const t = document.querySelector("base");
        e = t && t.getAttribute("href") || "/", e = e.replace(/^\w+:\/\/[^\/]+/, "");
    }
    else
        e = "/"; return e[0] !== "/" && e[0] !== "#" && (e = "/" + e), LE(e); }
const HE = /^[^#]+#/;
function KE(e, t) { return e.replace(HE, "#") + t; }
function jE(e, t) { const n = document.documentElement.getBoundingClientRect(), o = e.getBoundingClientRect(); return { behavior: t.behavior, left: o.left - n.left - (t.left || 0), top: o.top - n.top - (t.top || 0) }; }
const wc = () => ({ left: window.pageXOffset, top: window.pageYOffset });
function WE(e) { let t; if ("el" in e) {
    const n = e.el, o = typeof n == "string" && n.startsWith("#"), r = typeof n == "string" ? o ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
    if (!r)
        return;
    t = jE(r, e);
}
else
    t = e; "scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.pageXOffset, t.top != null ? t.top : window.pageYOffset); }
function gm(e, t) { return (history.state ? history.state.position - t : -1) + e; }
const of = new Map;
function UE(e, t) { of.set(e, t); }
function qE(e) { const t = of.get(e); return of.delete(e), t; }
let YE = () => location.protocol + "//" + location.host;
function Ib(e, t) { const { pathname: n, search: o, hash: r } = t, s = e.indexOf("#"); if (s > -1) {
    let a = r.includes(e.slice(s)) ? e.slice(s).length : 1, u = r.slice(a);
    return u[0] !== "/" && (u = "/" + u), vm(u, "");
} return vm(n, e) + o + r; }
function GE(e, t, n, o) { let r = [], s = [], l = null; const a = ({ state: p }) => { const v = Ib(e, location), m = n.value, h = t.value; let g = 0; if (p) {
    if (n.value = v, t.value = p, l && l === m) {
        l = null;
        return;
    }
    g = h ? p.position - h.position : 0;
}
else
    o(v); r.forEach(y => { y(n.value, m, { delta: g, type: Ka.pop, direction: g ? g > 0 ? Sa.forward : Sa.back : Sa.unknown }); }); }; function u() { l = n.value; } function c(p) { r.push(p); const v = () => { const m = r.indexOf(p); m > -1 && r.splice(m, 1); }; return s.push(v), v; } function d() { const { history: p } = window; p.state && p.replaceState(tn({}, p.state, { scroll: wc() }), ""); } function f() { for (const p of s)
    p(); s = [], window.removeEventListener("popstate", a), window.removeEventListener("beforeunload", d); } return window.addEventListener("popstate", a), window.addEventListener("beforeunload", d, { passive: !0 }), { pauseListeners: u, listen: c, destroy: f }; }
function ym(e, t, n, o = !1, r = !1) { return { back: e, current: t, forward: n, replaced: o, position: window.history.length, scroll: r ? wc() : null }; }
function XE(e) { const { history: t, location: n } = window, o = { value: Ib(e, n) }, r = { value: t.state }; r.value || s(o.value, { back: null, current: o.value, forward: null, position: t.length - 1, replaced: !0, scroll: null }, !0); function s(u, c, d) { const f = e.indexOf("#"), p = f > -1 ? (n.host && document.querySelector("base") ? e : e.slice(f)) + u : YE() + e + u; try {
    t[d ? "replaceState" : "pushState"](c, "", p), r.value = c;
}
catch (v) {
    console.error(v), n[d ? "replace" : "assign"](p);
} } function l(u, c) { const d = tn({}, t.state, ym(r.value.back, u, r.value.forward, !0), c, { position: r.value.position }); s(u, d, !0), o.value = u; } function a(u, c) { const d = tn({}, r.value, t.state, { forward: u, scroll: wc() }); s(d.current, d, !0); const f = tn({}, ym(o.value, u, null), { position: d.position + 1 }, c); s(u, f, !1), o.value = u; } return { location: o, state: r, push: a, replace: l }; }
function JE(e) { e = zE(e); const t = XE(e), n = GE(e, t.state, t.location, t.replace); function o(s, l = !0) { l || n.pauseListeners(), history.go(s); } const r = tn({ location: "", base: e, go: o, createHref: KE.bind(null, e) }, t, n); return Object.defineProperty(r, "location", { enumerable: !0, get: () => t.location.value }), Object.defineProperty(r, "state", { enumerable: !0, get: () => t.state.value }), r; }
function ZE(e) { return typeof e == "string" || e && typeof e == "object"; }
function xb(e) { return typeof e == "string" || typeof e == "symbol"; }
const Pr = { path: "/", name: void 0, params: {}, query: {}, hash: "", fullPath: "/", matched: [], meta: {}, redirectedFrom: void 0 }, Ab = Symbol("");
var bm;
(function (e) { e[e.aborted = 4] = "aborted", e[e.cancelled = 8] = "cancelled", e[e.duplicated = 16] = "duplicated"; })(bm || (bm = {}));
function Tl(e, t) { return tn(new Error, { type: e, [Ab]: !0 }, t); }
function cr(e, t) { return e instanceof Error && Ab in e && (t == null || !!(e.type & t)); }
const wm = "[^/]+?", QE = { sensitive: !1, strict: !1, start: !0, end: !0 }, e$ = /[.+*?^${}()[\]/\\]/g;
function t$(e, t) { const n = tn({}, QE, t), o = []; let r = n.start ? "^" : ""; const s = []; for (const c of e) {
    const d = c.length ? [] : [90];
    n.strict && !c.length && (r += "/");
    for (let f = 0; f < c.length; f++) {
        const p = c[f];
        let v = 40 + (n.sensitive ? .25 : 0);
        if (p.type === 0)
            f || (r += "/"), r += p.value.replace(e$, "\\$&"), v += 40;
        else if (p.type === 1) {
            const { value: m, repeatable: h, optional: g, regexp: y } = p;
            s.push({ name: m, repeatable: h, optional: g });
            const C = y || wm;
            if (C !== wm) {
                v += 10;
                try {
                    new RegExp(`(${C})`);
                }
                catch (w) {
                    throw new Error(`Invalid custom RegExp for param "${m}" (${C}): ` + w.message);
                }
            }
            let b = h ? `((?:${C})(?:/(?:${C}))*)` : `(${C})`;
            f || (b = g && c.length < 2 ? `(?:/${b})` : "/" + b), g && (b += "?"), r += b, v += 20, g && (v += -8), h && (v += -20), C === ".*" && (v += -50);
        }
        d.push(v);
    }
    o.push(d);
} if (n.strict && n.end) {
    const c = o.length - 1;
    o[c][o[c].length - 1] += .7000000000000001;
} n.strict || (r += "/?"), n.end ? r += "$" : n.strict && (r += "(?:/|$)"); const l = new RegExp(r, n.sensitive ? "" : "i"); function a(c) { const d = c.match(l), f = {}; if (!d)
    return null; for (let p = 1; p < d.length; p++) {
    const v = d[p] || "", m = s[p - 1];
    f[m.name] = v && m.repeatable ? v.split("/") : v;
} return f; } function u(c) { let d = "", f = !1; for (const p of e) {
    (!f || !d.endsWith("/")) && (d += "/"), f = !1;
    for (const v of p)
        if (v.type === 0)
            d += v.value;
        else if (v.type === 1) {
            const { value: m, repeatable: h, optional: g } = v, y = m in c ? c[m] : "";
            if (zo(y) && !h)
                throw new Error(`Provided param "${m}" is an array but it is not repeatable (* or + modifiers)`);
            const C = zo(y) ? y.join("/") : y;
            if (!C)
                if (g)
                    p.length < 2 && (d.endsWith("/") ? d = d.slice(0, -1) : f = !0);
                else
                    throw new Error(`Missing required param "${m}"`);
            d += C;
        }
} return d || "/"; } return { re: l, score: o, keys: s, parse: a, stringify: u }; }
function n$(e, t) { let n = 0; for (; n < e.length && n < t.length;) {
    const o = t[n] - e[n];
    if (o)
        return o;
    n++;
} return e.length < t.length ? e.length === 1 && e[0] === 40 + 40 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 40 + 40 ? 1 : -1 : 0; }
function o$(e, t) { let n = 0; const o = e.score, r = t.score; for (; n < o.length && n < r.length;) {
    const s = n$(o[n], r[n]);
    if (s)
        return s;
    n++;
} if (Math.abs(r.length - o.length) === 1) {
    if (Cm(o))
        return 1;
    if (Cm(r))
        return -1;
} return r.length - o.length; }
function Cm(e) { const t = e[e.length - 1]; return e.length > 0 && t[t.length - 1] < 0; }
const r$ = { type: 0, value: "" }, s$ = /[a-zA-Z0-9_]/;
function l$(e) { if (!e)
    return [[]]; if (e === "/")
    return [[r$]]; if (!e.startsWith("/"))
    throw new Error(`Invalid path "${e}"`); function t(v) { throw new Error(`ERR (${n})/"${c}": ${v}`); } let n = 0, o = n; const r = []; let s; function l() { s && r.push(s), s = []; } let a = 0, u, c = "", d = ""; function f() { c && (n === 0 ? s.push({ type: 0, value: c }) : n === 1 || n === 2 || n === 3 ? (s.length > 1 && (u === "*" || u === "+") && t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`), s.push({ type: 1, value: c, regexp: d, repeatable: u === "*" || u === "+", optional: u === "*" || u === "?" })) : t("Invalid state to consume buffer"), c = ""); } function p() { c += u; } for (; a < e.length;) {
    if (u = e[a++], u === "\\" && n !== 2) {
        o = n, n = 4;
        continue;
    }
    switch (n) {
        case 0:
            u === "/" ? (c && f(), l()) : u === ":" ? (f(), n = 1) : p();
            break;
        case 4:
            p(), n = o;
            break;
        case 1:
            u === "(" ? n = 2 : s$.test(u) ? p() : (f(), n = 0, u !== "*" && u !== "?" && u !== "+" && a--);
            break;
        case 2:
            u === ")" ? d[d.length - 1] == "\\" ? d = d.slice(0, -1) + u : n = 3 : d += u;
            break;
        case 3:
            f(), n = 0, u !== "*" && u !== "?" && u !== "+" && a--, d = "";
            break;
        default:
            t("Unknown state");
            break;
    }
} return n === 2 && t(`Unfinished custom RegExp for param "${c}"`), f(), l(), r; }
function a$(e, t, n) { const o = t$(l$(e.path), n), r = tn(o, { record: e, parent: t, children: [], alias: [] }); return t && !r.record.aliasOf == !t.record.aliasOf && t.children.push(r), r; }
function i$(e, t) { const n = [], o = new Map; t = km({ strict: !1, end: !0, sensitive: !1 }, t); function r(d) { return o.get(d); } function s(d, f, p) { const v = !p, m = u$(d); m.aliasOf = p && p.record; const h = km(t, d), g = [m]; if ("alias" in d) {
    const b = typeof d.alias == "string" ? [d.alias] : d.alias;
    for (const w of b)
        g.push(tn({}, m, { components: p ? p.record.components : m.components, path: w, aliasOf: p ? p.record : m }));
} let y, C; for (const b of g) {
    const { path: w } = b;
    if (f && w[0] !== "/") {
        const T = f.record.path, E = T[T.length - 1] === "/" ? "" : "/";
        b.path = f.record.path + (w && E + w);
    }
    if (y = a$(b, f, h), p ? p.alias.push(y) : (C = C || y, C !== y && C.alias.push(y), v && d.name && !_m(y) && l(d.name)), m.children) {
        const T = m.children;
        for (let E = 0; E < T.length; E++)
            s(T[E], y, p && p.children[E]);
    }
    p = p || y, (y.record.components && Object.keys(y.record.components).length || y.record.name || y.record.redirect) && u(y);
} return C ? () => { l(C); } : Ca; } function l(d) { if (xb(d)) {
    const f = o.get(d);
    f && (o.delete(d), n.splice(n.indexOf(f), 1), f.children.forEach(l), f.alias.forEach(l));
}
else {
    const f = n.indexOf(d);
    f > -1 && (n.splice(f, 1), d.record.name && o.delete(d.record.name), d.children.forEach(l), d.alias.forEach(l));
} } function a() { return n; } function u(d) { let f = 0; for (; f < n.length && o$(d, n[f]) >= 0 && (d.record.path !== n[f].record.path || !Mb(d, n[f]));)
    f++; n.splice(f, 0, d), d.record.name && !_m(d) && o.set(d.record.name, d); } function c(d, f) { let p, v = {}, m, h; if ("name" in d && d.name) {
    if (p = o.get(d.name), !p)
        throw Tl(1, { location: d });
    h = p.record.name, v = tn(Sm(f.params, p.keys.filter(C => !C.optional).map(C => C.name)), d.params && Sm(d.params, p.keys.map(C => C.name))), m = p.stringify(v);
}
else if ("path" in d)
    m = d.path, p = n.find(C => C.re.test(m)), p && (v = p.parse(m), h = p.record.name);
else {
    if (p = f.name ? o.get(f.name) : n.find(C => C.re.test(f.path)), !p)
        throw Tl(1, { location: d, currentLocation: f });
    h = p.record.name, v = tn({}, f.params, d.params), m = p.stringify(v);
} const g = []; let y = p; for (; y;)
    g.unshift(y.record), y = y.parent; return { name: h, path: m, params: v, matched: g, meta: d$(g) }; } return e.forEach(d => s(d)), { addRoute: s, resolve: c, removeRoute: l, getRoutes: a, getRecordMatcher: r }; }
function Sm(e, t) { const n = {}; for (const o of t)
    o in e && (n[o] = e[o]); return n; }
function u$(e) { return { path: e.path, redirect: e.redirect, name: e.name, meta: e.meta || {}, aliasOf: void 0, beforeEnter: e.beforeEnter, props: c$(e), children: e.children || [], instances: {}, leaveGuards: new Set, updateGuards: new Set, enterCallbacks: {}, components: "components" in e ? e.components || null : e.component && { default: e.component } }; }
function c$(e) { const t = {}, n = e.props || !1; if ("component" in e)
    t.default = n;
else
    for (const o in e.components)
        t[o] = typeof n == "object" ? n[o] : n; return t; }
function _m(e) { for (; e;) {
    if (e.record.aliasOf)
        return !0;
    e = e.parent;
} return !1; }
function d$(e) { return e.reduce((t, n) => tn(t, n.meta), {}); }
function km(e, t) { const n = {}; for (const o in e)
    n[o] = o in t ? t[o] : e[o]; return n; }
function Mb(e, t) { return t.children.some(n => n === e || Mb(e, n)); }
const Nb = /#/g, f$ = /&/g, p$ = /\//g, h$ = /=/g, v$ = /\?/g, Pb = /\+/g, m$ = /%5B/g, g$ = /%5D/g, Rb = /%5E/g, y$ = /%60/g, Lb = /%7B/g, b$ = /%7C/g, Db = /%7D/g, w$ = /%20/g;
function Vp(e) { return encodeURI("" + e).replace(b$, "|").replace(m$, "[").replace(g$, "]"); }
function C$(e) { return Vp(e).replace(Lb, "{").replace(Db, "}").replace(Rb, "^"); }
function rf(e) { return Vp(e).replace(Pb, "%2B").replace(w$, "+").replace(Nb, "%23").replace(f$, "%26").replace(y$, "`").replace(Lb, "{").replace(Db, "}").replace(Rb, "^"); }
function S$(e) { return rf(e).replace(h$, "%3D"); }
function _$(e) { return Vp(e).replace(Nb, "%23").replace(v$, "%3F"); }
function k$(e) { return e == null ? "" : _$(e).replace(p$, "%2F"); }
function Fu(e) { try {
    return decodeURIComponent("" + e);
}
catch { } return "" + e; }
function E$(e) { const t = {}; if (e === "" || e === "?")
    return t; const o = (e[0] === "?" ? e.slice(1) : e).split("&"); for (let r = 0; r < o.length; ++r) {
    const s = o[r].replace(Pb, " "), l = s.indexOf("="), a = Fu(l < 0 ? s : s.slice(0, l)), u = l < 0 ? null : Fu(s.slice(l + 1));
    if (a in t) {
        let c = t[a];
        zo(c) || (c = t[a] = [c]), c.push(u);
    }
    else
        t[a] = u;
} return t; }
function Em(e) { let t = ""; for (let n in e) {
    const o = e[n];
    if (n = S$(n), o == null) {
        o !== void 0 && (t += (t.length ? "&" : "") + n);
        continue;
    }
    (zo(o) ? o.map(s => s && rf(s)) : [o && rf(o)]).forEach(s => { s !== void 0 && (t += (t.length ? "&" : "") + n, s != null && (t += "=" + s)); });
} return t; }
function $$(e) { const t = {}; for (const n in e) {
    const o = e[n];
    o !== void 0 && (t[n] = zo(o) ? o.map(r => r == null ? null : "" + r) : o == null ? o : "" + o);
} return t; }
const T$ = Symbol(""), $m = Symbol(""), zp = Symbol(""), Bb = Symbol(""), sf = Symbol("");
function la() { let e = []; function t(o) { return e.push(o), () => { const r = e.indexOf(o); r > -1 && e.splice(r, 1); }; } function n() { e = []; } return { add: t, list: () => e.slice(), reset: n }; }
function zr(e, t, n, o, r) { const s = o && (o.enterCallbacks[r] = o.enterCallbacks[r] || []); return () => new Promise((l, a) => { const u = f => { f === !1 ? a(Tl(4, { from: n, to: t })) : f instanceof Error ? a(f) : ZE(f) ? a(Tl(2, { from: t, to: f })) : (s && o.enterCallbacks[r] === s && typeof f == "function" && s.push(f), l()); }, c = e.call(o && o.instances[r], t, n, u); let d = Promise.resolve(c); e.length < 3 && (d = d.then(u)), d.catch(f => a(f)); }); }
function md(e, t, n, o) { const r = []; for (const s of e)
    for (const l in s.components) {
        let a = s.components[l];
        if (!(t !== "beforeRouteEnter" && !s.instances[l]))
            if (O$(a)) {
                const c = (a.__vccOpts || a)[t];
                c && r.push(zr(c, n, o, s, l));
            }
            else {
                let u = a();
                r.push(() => u.then(c => { if (!c)
                    return Promise.reject(new Error(`Couldn't resolve component "${l}" at "${s.path}"`)); const d = PE(c) ? c.default : c; s.components[l] = d; const p = (d.__vccOpts || d)[t]; return p && zr(p, n, o, s, l)(); }));
            }
    } return r; }
function O$(e) { return typeof e == "object" || "displayName" in e || "props" in e || "__vccOpts" in e; }
function Tm(e) { const t = Ye(zp), n = Ye(Bb), o = S(() => t.resolve(i(e.to))), r = S(() => { const { matched: u } = o.value, { length: c } = u, d = u[c - 1], f = n.matched; if (!d || !f.length)
    return -1; const p = f.findIndex($l.bind(null, d)); if (p > -1)
    return p; const v = Om(u[c - 2]); return c > 1 && Om(d) === v && f[f.length - 1].path !== v ? f.findIndex($l.bind(null, u[c - 2])) : p; }), s = S(() => r.value > -1 && A$(n.params, o.value.params)), l = S(() => r.value > -1 && r.value === n.matched.length - 1 && Ob(n.params, o.value.params)); function a(u = {}) { return x$(u) ? t[i(e.replace) ? "replace" : "push"](i(e.to)).catch(Ca) : Promise.resolve(); } return { route: o, href: S(() => o.value.href), isActive: s, isExactActive: l, navigate: a }; }
const I$ = ae({ name: "RouterLink", compatConfig: { MODE: 3 }, props: { to: { type: [String, Object], required: !0 }, replace: Boolean, activeClass: String, exactActiveClass: String, custom: Boolean, ariaCurrentValue: { type: String, default: "page" } }, useLink: Tm, setup(e, { slots: t }) { const n = Lt(Tm(e)), { options: o } = Ye(zp), r = S(() => ({ [Im(e.activeClass, o.linkActiveClass, "router-link-active")]: n.isActive, [Im(e.exactActiveClass, o.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive })); return () => { const s = t.default && t.default(n); return e.custom ? s : nt("a", { "aria-current": n.isExactActive ? e.ariaCurrentValue : null, href: n.href, onClick: n.navigate, class: r.value }, s); }; } }), lf = I$;
function x$(e) { if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
    if (e.currentTarget && e.currentTarget.getAttribute) {
        const t = e.currentTarget.getAttribute("target");
        if (/\b_blank\b/i.test(t))
            return;
    }
    return e.preventDefault && e.preventDefault(), !0;
} }
function A$(e, t) { for (const n in t) {
    const o = t[n], r = e[n];
    if (typeof o == "string") {
        if (o !== r)
            return !1;
    }
    else if (!zo(r) || r.length !== o.length || o.some((s, l) => s !== r[l]))
        return !1;
} return !0; }
function Om(e) { return e ? e.aliasOf ? e.aliasOf.path : e.path : ""; }
const Im = (e, t, n) => e ?? t ?? n, M$ = ae({ name: "RouterView", inheritAttrs: !1, props: { name: { type: String, default: "default" }, route: Object }, compatConfig: { MODE: 3 }, setup(e, { attrs: t, slots: n }) { const o = Ye(sf), r = S(() => e.route || o.value), s = Ye($m, 0), l = S(() => { let c = i(s); const { matched: d } = r.value; let f; for (; (f = d[c]) && !f.components;)
        c++; return c; }), a = S(() => r.value.matched[l.value]); St($m, S(() => l.value + 1)), St(T$, a), St(sf, r); const u = M(); return Oe(() => [u.value, a.value, e.name], ([c, d, f], [p, v, m]) => { d && (d.instances[f] = c, v && v !== d && c && c === p && (d.leaveGuards.size || (d.leaveGuards = v.leaveGuards), d.updateGuards.size || (d.updateGuards = v.updateGuards))), c && d && (!v || !$l(d, v) || !p) && (d.enterCallbacks[f] || []).forEach(h => h(c)); }, { flush: "post" }), () => { const c = r.value, d = e.name, f = a.value, p = f && f.components[d]; if (!p)
        return xm(n.default, { Component: p, route: c }); const v = f.props[d], m = v ? v === !0 ? c.params : typeof v == "function" ? v(c) : v : null, g = nt(p, tn({}, m, t, { onVnodeUnmounted: y => { y.component.isUnmounted && (f.instances[d] = null); }, ref: u })); return xm(n.default, { Component: g, route: c }) || g; }; } });
function xm(e, t) { if (!e)
    return null; const n = e(t); return n.length === 1 ? n[0] : n; }
const Fb = M$;
function N$(e) { const t = i$(e.routes, e), n = e.parseQuery || E$, o = e.stringifyQuery || Em, r = e.history, s = la(), l = la(), a = la(), u = Xt(Pr); let c = Pr; nl && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual"); const d = hd.bind(null, le => "" + le), f = hd.bind(null, k$), p = hd.bind(null, Fu); function v(le, oe) { let fe, Ce; return xb(le) ? (fe = t.getRecordMatcher(le), Ce = oe) : Ce = le, t.addRoute(Ce, fe); } function m(le) { const oe = t.getRecordMatcher(le); oe && t.removeRoute(oe); } function h() { return t.getRoutes().map(le => le.record); } function g(le) { return !!t.getRecordMatcher(le); } function y(le, oe) { if (oe = tn({}, oe || u.value), typeof le == "string") {
    const he = vd(n, le, oe.path), Ee = t.resolve({ path: he.path }, oe), Ne = r.createHref(he.fullPath);
    return tn(he, Ee, { params: p(Ee.params), hash: Fu(he.hash), redirectedFrom: void 0, href: Ne });
} let fe; if ("path" in le)
    fe = tn({}, le, { path: vd(n, le.path, oe.path).path });
else {
    const he = tn({}, le.params);
    for (const Ee in he)
        he[Ee] == null && delete he[Ee];
    fe = tn({}, le, { params: f(he) }), oe.params = f(oe.params);
} const Ce = t.resolve(fe, oe), Ae = le.hash || ""; Ce.params = d(p(Ce.params)); const q = DE(o, tn({}, le, { hash: C$(Ae), path: Ce.path })), re = r.createHref(q); return tn({ fullPath: q, hash: Ae, query: o === Em ? $$(le.query) : le.query || {} }, Ce, { redirectedFrom: void 0, href: re }); } function C(le) { return typeof le == "string" ? vd(n, le, u.value.path) : tn({}, le); } function b(le, oe) { if (c !== le)
    return Tl(8, { from: oe, to: le }); } function w(le) { return x(le); } function T(le) { return w(tn(C(le), { replace: !0 })); } function E(le) { const oe = le.matched[le.matched.length - 1]; if (oe && oe.redirect) {
    const { redirect: fe } = oe;
    let Ce = typeof fe == "function" ? fe(le) : fe;
    return typeof Ce == "string" && (Ce = Ce.includes("?") || Ce.includes("#") ? Ce = C(Ce) : { path: Ce }, Ce.params = {}), tn({ query: le.query, hash: le.hash, params: "path" in Ce ? {} : le.params }, Ce);
} } function x(le, oe) { const fe = c = y(le), Ce = u.value, Ae = le.state, q = le.force, re = le.replace === !0, he = E(fe); if (he)
    return x(tn(C(he), { state: typeof he == "object" ? tn({}, Ae, he.state) : Ae, force: q, replace: re }), oe || fe); const Ee = fe; Ee.redirectedFrom = oe; let Ne; return !q && BE(o, Ce, fe) && (Ne = Tl(16, { to: Ee, from: Ce }), se(Ce, Ce, !0, !1)), (Ne ? Promise.resolve(Ne) : B(Ee, Ce)).catch(Se => cr(Se) ? cr(Se, 2) ? Se : G(Se) : j(Se, Ee, Ce)).then(Se => { if (Se) {
    if (cr(Se, 2))
        return x(tn({ replace: re }, C(Se.to), { state: typeof Se.to == "object" ? tn({}, Ae, Se.to.state) : Ae, force: q }), oe || Ee);
}
else
    Se = V(Ee, Ce, !0, re, Ae); return F(Ee, Ce, Se), Se; }); } function I(le, oe) { const fe = b(le, oe); return fe ? Promise.reject(fe) : Promise.resolve(); } function L(le) { const oe = ye.values().next().value; return oe && typeof oe.runWithContext == "function" ? oe.runWithContext(le) : le(); } function B(le, oe) { let fe; const [Ce, Ae, q] = P$(le, oe); fe = md(Ce.reverse(), "beforeRouteLeave", le, oe); for (const he of Ce)
    he.leaveGuards.forEach(Ee => { fe.push(zr(Ee, le, oe)); }); const re = I.bind(null, le, oe); return fe.push(re), me(fe).then(() => { fe = []; for (const he of s.list())
    fe.push(zr(he, le, oe)); return fe.push(re), me(fe); }).then(() => { fe = md(Ae, "beforeRouteUpdate", le, oe); for (const he of Ae)
    he.updateGuards.forEach(Ee => { fe.push(zr(Ee, le, oe)); }); return fe.push(re), me(fe); }).then(() => { fe = []; for (const he of q)
    if (he.beforeEnter)
        if (zo(he.beforeEnter))
            for (const Ee of he.beforeEnter)
                fe.push(zr(Ee, le, oe));
        else
            fe.push(zr(he.beforeEnter, le, oe)); return fe.push(re), me(fe); }).then(() => (le.matched.forEach(he => he.enterCallbacks = {}), fe = md(q, "beforeRouteEnter", le, oe), fe.push(re), me(fe))).then(() => { fe = []; for (const he of l.list())
    fe.push(zr(he, le, oe)); return fe.push(re), me(fe); }).catch(he => cr(he, 8) ? he : Promise.reject(he)); } function F(le, oe, fe) { a.list().forEach(Ce => L(() => Ce(le, oe, fe))); } function V(le, oe, fe, Ce, Ae) { const q = b(le, oe); if (q)
    return q; const re = oe === Pr, he = nl ? history.state : {}; fe && (Ce || re ? r.replace(le.fullPath, tn({ scroll: re && he && he.scroll }, Ae)) : r.push(le.fullPath, Ae)), u.value = le, se(le, oe, fe, re), G(); } let R; function K() { R || (R = r.listen((le, oe, fe) => { if (!Re.listening)
    return; const Ce = y(le), Ae = E(Ce); if (Ae) {
    x(tn(Ae, { replace: !0 }), Ce).catch(Ca);
    return;
} c = Ce; const q = u.value; nl && UE(gm(q.fullPath, fe.delta), wc()), B(Ce, q).catch(re => cr(re, 12) ? re : cr(re, 2) ? (x(re.to, Ce).then(he => { cr(he, 20) && !fe.delta && fe.type === Ka.pop && r.go(-1, !1); }).catch(Ca), Promise.reject()) : (fe.delta && r.go(-fe.delta, !1), j(re, Ce, q))).then(re => { re = re || V(Ce, q, !1), re && (fe.delta && !cr(re, 8) ? r.go(-fe.delta, !1) : fe.type === Ka.pop && cr(re, 20) && r.go(-1, !1)), F(Ce, q, re); }).catch(Ca); })); } let te = la(), U = la(), D; function j(le, oe, fe) { G(le); const Ce = U.list(); return Ce.length ? Ce.forEach(Ae => Ae(le, oe, fe)) : console.error(le), Promise.reject(le); } function A() { return D && u.value !== Pr ? Promise.resolve() : new Promise((le, oe) => { te.add([le, oe]); }); } function G(le) { return D || (D = !le, K(), te.list().forEach(([oe, fe]) => le ? fe(le) : oe()), te.reset()), le; } function se(le, oe, fe, Ce) { const { scrollBehavior: Ae } = e; if (!nl || !Ae)
    return Promise.resolve(); const q = !fe && qE(gm(le.fullPath, 0)) || (Ce || !fe) && history.state && history.state.scroll || null; return Xe().then(() => Ae(le, oe, q)).then(re => re && WE(re)).catch(re => j(re, le, oe)); } const Z = le => r.go(le); let ce; const ye = new Set, Re = { currentRoute: u, listening: !0, addRoute: v, removeRoute: m, hasRoute: g, getRoutes: h, resolve: y, options: e, push: w, replace: T, go: Z, back: () => Z(-1), forward: () => Z(1), beforeEach: s.add, beforeResolve: l.add, afterEach: a.add, onError: U.add, isReady: A, install(le) { const oe = this; le.component("RouterLink", lf), le.component("RouterView", Fb), le.config.globalProperties.$router = oe, Object.defineProperty(le.config.globalProperties, "$route", { enumerable: !0, get: () => i(u) }), nl && !ce && u.value === Pr && (ce = !0, w(r.location).catch(Ae => { })); const fe = {}; for (const Ae in Pr)
        Object.defineProperty(fe, Ae, { get: () => u.value[Ae], enumerable: !0 }); le.provide(zp, oe), le.provide(Bb, kp(fe)), le.provide(sf, u); const Ce = le.unmount; ye.add(le), le.unmount = function () { ye.delete(le), ye.size < 1 && (c = Pr, R && R(), R = null, u.value = Pr, ce = !1, D = !1), Ce(); }; } }; function me(le) { return le.reduce((oe, fe) => oe.then(() => L(fe)), Promise.resolve()); } return Re; }
function P$(e, t) { const n = [], o = [], r = [], s = Math.max(t.matched.length, e.matched.length); for (let l = 0; l < s; l++) {
    const a = t.matched[l];
    a && (e.matched.find(c => $l(c, a)) ? o.push(a) : n.push(a));
    const u = e.matched[l];
    u && (t.matched.find(c => $l(c, u)) || r.push(u));
} return [n, o, r]; }
const R$ = 'a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])', L$ = e => getComputedStyle(e).position === "fixed" ? !1 : e.offsetParent !== null, Am = e => Array.from(e.querySelectorAll(R$)).filter(t => D$(t) && L$(t)), D$ = e => { if (e.tabIndex > 0 || e.tabIndex === 0 && e.getAttribute("tabIndex") !== null)
    return !0; if (e.disabled)
    return !1; switch (e.nodeName) {
    case "A": return !!e.href && e.rel !== "ignore";
    case "INPUT": return !(e.type === "hidden" || e.type === "file");
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA": return !0;
    default: return !1;
} }, iu = function (e, t, ...n) { let o; t.includes("mouse") || t.includes("click") ? o = "MouseEvents" : t.includes("key") ? o = "KeyboardEvent" : o = "HTMLEvents"; const r = document.createEvent(o); return r.initEvent(t, ...n), e.dispatchEvent(r), e; }, Vb = e => !e.getAttribute("aria-owns"), zb = (e, t, n) => { const { parentNode: o } = e; if (!o)
    return null; const r = o.querySelectorAll(n), s = Array.prototype.indexOf.call(r, e); return r[s + t] || null; }, uu = e => { e && (e.focus(), !Vb(e) && e.click()); }, fn = (e, t, { checkForDefaultPrevented: n = !0 } = {}) => r => { const s = e == null ? void 0 : e(r); if (n === !1 || !s)
    return t == null ? void 0 : t(r); }, Mm = e => t => t.pointerType === "mouse" ? e(t) : void 0;
var B$ = Object.defineProperty, F$ = Object.defineProperties, V$ = Object.getOwnPropertyDescriptors, Nm = Object.getOwnPropertySymbols, z$ = Object.prototype.hasOwnProperty, H$ = Object.prototype.propertyIsEnumerable, Pm = (e, t, n) => t in e ? B$(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, K$ = (e, t) => { for (var n in t || (t = {}))
    z$.call(t, n) && Pm(e, n, t[n]); if (Nm)
    for (var n of Nm(t))
        H$.call(t, n) && Pm(e, n, t[n]); return e; }, j$ = (e, t) => F$(e, V$(t));
function Rm(e, t) { var n; const o = Xt(); return mo(() => { o.value = e(); }, j$(K$({}, t), { flush: (n = t == null ? void 0 : t.flush) != null ? n : "sync" })), Wl(o); }
var Lm;
const At = typeof window < "u", W$ = e => typeof e < "u", U$ = e => typeof e == "function", q$ = e => typeof e == "string", Ol = () => { }, Hb = At && ((Lm = window == null ? void 0 : window.navigator) == null ? void 0 : Lm.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function Jr(e) { return typeof e == "function" ? e() : i(e); }
function Kb(e, t) { function n(...o) { return new Promise((r, s) => { Promise.resolve(e(() => t.apply(this, o), { fn: t, thisArg: this, args: o })).then(r).catch(s); }); } return n; }
function Y$(e, t = {}) { let n, o, r = Ol; const s = a => { clearTimeout(a), r(), r = Ol; }; return a => { const u = Jr(e), c = Jr(t.maxWait); return n && s(n), u <= 0 || c !== void 0 && c <= 0 ? (o && (s(o), o = null), Promise.resolve(a())) : new Promise((d, f) => { r = t.rejectOnCancel ? f : d, c && !o && (o = setTimeout(() => { n && s(n), o = null, d(a()); }, c)), n = setTimeout(() => { o && s(o), o = null, d(a()); }, u); }); }; }
function G$(e, t = !0, n = !0, o = !1) { let r = 0, s, l = !0, a = Ol, u; const c = () => { s && (clearTimeout(s), s = void 0, a(), a = Ol); }; return f => { const p = Jr(e), v = Date.now() - r, m = () => u = f(); return c(), p <= 0 ? (r = Date.now(), m()) : (v > p && (n || !l) ? (r = Date.now(), m()) : t && (u = new Promise((h, g) => { a = o ? g : h, s = setTimeout(() => { r = Date.now(), l = !0, h(m()), c(); }, Math.max(0, p - v)); })), !n && !s && (s = setTimeout(() => l = !0, p)), l = !1, u); }; }
function X$(e) { return e; }
function Cc(e) { return _y() ? (ky(e), !0) : !1; }
function J$(e, t = 200, n = {}) { return Kb(Y$(t, n), e); }
function Z$(e, t = 200, n = {}) { const o = M(e.value), r = J$(() => { o.value = e.value; }, t, n); return Oe(e, () => r()), o; }
function jb(e, t = 200, n = !1, o = !0, r = !1) { return Kb(G$(t, n, o, r), e); }
function Hp(e, t = !0) { ht() ? ft(e) : t ? e() : Xe(e); }
function Vs(e, t, n = {}) { const { immediate: o = !0 } = n, r = M(!1); let s = null; function l() { s && (clearTimeout(s), s = null); } function a() { r.value = !1, l(); } function u(...c) { l(), r.value = !0, s = setTimeout(() => { r.value = !1, s = null, e(...c); }, Jr(t)); } return o && (r.value = !0, At && u()), Cc(a), { isPending: Wl(r), start: u, stop: a }; }
function po(e) { var t; const n = Jr(e); return (t = n == null ? void 0 : n.$el) != null ? t : n; }
const ql = At ? window : void 0, Q$ = At ? window.document : void 0;
function nn(...e) { let t, n, o, r; if (q$(e[0]) || Array.isArray(e[0]) ? ([n, o, r] = e, t = ql) : [t, n, o, r] = e, !t)
    return Ol; Array.isArray(n) || (n = [n]), Array.isArray(o) || (o = [o]); const s = [], l = () => { s.forEach(d => d()), s.length = 0; }, a = (d, f, p, v) => (d.addEventListener(f, p, v), () => d.removeEventListener(f, p, v)), u = Oe(() => [po(t), Jr(r)], ([d, f]) => { l(), d && s.push(...n.flatMap(p => o.map(v => a(d, p, v, f)))); }, { immediate: !0, flush: "post" }), c = () => { u(), l(); }; return Cc(c), c; }
let Dm = !1;
function Kp(e, t, n = {}) { const { window: o = ql, ignore: r = [], capture: s = !0, detectIframe: l = !1 } = n; if (!o)
    return; Hb && !Dm && (Dm = !0, Array.from(o.document.body.children).forEach(p => p.addEventListener("click", Ol))); let a = !0; const u = p => r.some(v => { if (typeof v == "string")
    return Array.from(o.document.querySelectorAll(v)).some(m => m === p.target || p.composedPath().includes(m)); {
    const m = po(v);
    return m && (p.target === m || p.composedPath().includes(m));
} }), d = [nn(o, "click", p => { const v = po(e); if (!(!v || v === p.target || p.composedPath().includes(v))) {
        if (p.detail === 0 && (a = !u(p)), !a) {
            a = !0;
            return;
        }
        t(p);
    } }, { passive: !0, capture: s }), nn(o, "pointerdown", p => { const v = po(e); v && (a = !p.composedPath().includes(v) && !u(p)); }, { passive: !0 }), l && nn(o, "blur", p => { var v; const m = po(e); ((v = o.document.activeElement) == null ? void 0 : v.tagName) === "IFRAME" && !(m != null && m.contains(o.document.activeElement)) && t(p); })].filter(Boolean); return () => d.forEach(p => p()); }
function eT(e, t = !1) { const n = M(), o = () => n.value = !!e(); return o(), Hp(o, t), n; }
function tT(e) { return JSON.parse(JSON.stringify(e)); }
const Bm = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Fm = "__vueuse_ssr_handlers__";
Bm[Fm] = Bm[Fm] || {};
function nT(e, t, { window: n = ql, initialValue: o = "" } = {}) { const r = M(o), s = S(() => { var l; return po(t) || ((l = n == null ? void 0 : n.document) == null ? void 0 : l.documentElement); }); return Oe([s, () => Jr(e)], ([l, a]) => { var u; if (l && n) {
    const c = (u = n.getComputedStyle(l).getPropertyValue(a)) == null ? void 0 : u.trim();
    r.value = c || o;
} }, { immediate: !0 }), Oe(r, l => { var a; (a = s.value) != null && a.style && s.value.style.setProperty(Jr(e), l); }), r; }
function oT({ document: e = Q$ } = {}) { if (!e)
    return M("visible"); const t = M(e.visibilityState); return nn(e, "visibilitychange", () => { t.value = e.visibilityState; }), t; }
var Vm = Object.getOwnPropertySymbols, rT = Object.prototype.hasOwnProperty, sT = Object.prototype.propertyIsEnumerable, lT = (e, t) => { var n = {}; for (var o in e)
    rT.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]); if (e != null && Vm)
    for (var o of Vm(e))
        t.indexOf(o) < 0 && sT.call(e, o) && (n[o] = e[o]); return n; };
function Vn(e, t, n = {}) { const o = n, { window: r = ql } = o, s = lT(o, ["window"]); let l; const a = eT(() => r && "ResizeObserver" in r), u = () => { l && (l.disconnect(), l = void 0); }, c = Oe(() => po(e), f => { u(), a.value && r && f && (l = new ResizeObserver(t), l.observe(f, s)); }, { immediate: !0, flush: "post" }), d = () => { u(), c(); }; return Cc(d), { isSupported: a, stop: d }; }
function zm(e, t = {}) { const { reset: n = !0, windowResize: o = !0, windowScroll: r = !0, immediate: s = !0 } = t, l = M(0), a = M(0), u = M(0), c = M(0), d = M(0), f = M(0), p = M(0), v = M(0); function m() { const h = po(e); if (!h) {
    n && (l.value = 0, a.value = 0, u.value = 0, c.value = 0, d.value = 0, f.value = 0, p.value = 0, v.value = 0);
    return;
} const g = h.getBoundingClientRect(); l.value = g.height, a.value = g.bottom, u.value = g.left, c.value = g.right, d.value = g.top, f.value = g.width, p.value = g.x, v.value = g.y; } return Vn(e, m), Oe(() => po(e), h => !h && m()), r && nn("scroll", m, { capture: !0, passive: !0 }), o && nn("resize", m, { passive: !0 }), Hp(() => { s && m(); }), { height: l, bottom: a, left: u, right: c, top: d, width: f, x: p, y: v, update: m }; }
var Hm;
(function (e) { e.UP = "UP", e.RIGHT = "RIGHT", e.DOWN = "DOWN", e.LEFT = "LEFT", e.NONE = "NONE"; })(Hm || (Hm = {}));
var aT = Object.defineProperty, Km = Object.getOwnPropertySymbols, iT = Object.prototype.hasOwnProperty, uT = Object.prototype.propertyIsEnumerable, jm = (e, t, n) => t in e ? aT(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, cT = (e, t) => { for (var n in t || (t = {}))
    iT.call(t, n) && jm(e, n, t[n]); if (Km)
    for (var n of Km(t))
        uT.call(t, n) && jm(e, n, t[n]); return e; };
const dT = { easeInSine: [.12, 0, .39, 0], easeOutSine: [.61, 1, .88, 1], easeInOutSine: [.37, 0, .63, 1], easeInQuad: [.11, 0, .5, 0], easeOutQuad: [.5, 1, .89, 1], easeInOutQuad: [.45, 0, .55, 1], easeInCubic: [.32, 0, .67, 0], easeOutCubic: [.33, 1, .68, 1], easeInOutCubic: [.65, 0, .35, 1], easeInQuart: [.5, 0, .75, 0], easeOutQuart: [.25, 1, .5, 1], easeInOutQuart: [.76, 0, .24, 1], easeInQuint: [.64, 0, .78, 0], easeOutQuint: [.22, 1, .36, 1], easeInOutQuint: [.83, 0, .17, 1], easeInExpo: [.7, 0, .84, 0], easeOutExpo: [.16, 1, .3, 1], easeInOutExpo: [.87, 0, .13, 1], easeInCirc: [.55, 0, 1, .45], easeOutCirc: [0, .55, .45, 1], easeInOutCirc: [.85, 0, .15, 1], easeInBack: [.36, 0, .66, -.56], easeOutBack: [.34, 1.56, .64, 1], easeInOutBack: [.68, -.6, .32, 1.6] };
cT({ linear: X$ }, dT);
function fT(e, t, n, o = {}) { var r, s, l; const { clone: a = !1, passive: u = !1, eventName: c, deep: d = !1, defaultValue: f } = o, p = ht(), v = n || (p == null ? void 0 : p.emit) || ((r = p == null ? void 0 : p.$emit) == null ? void 0 : r.bind(p)) || ((l = (s = p == null ? void 0 : p.proxy) == null ? void 0 : s.$emit) == null ? void 0 : l.bind(p == null ? void 0 : p.proxy)); let m = c; t || (t = "modelValue"), m = c || m || `update:${t.toString()}`; const h = y => a ? U$(a) ? a(y) : tT(y) : y, g = () => W$(e[t]) ? h(e[t]) : f; if (u) {
    const y = g(), C = M(y);
    return Oe(() => e[t], b => C.value = h(b)), Oe(C, b => { (b !== e[t] || d) && v(m, b); }, { deep: d }), C;
}
else
    return S({ get() { return g(); }, set(y) { v(m, y); } }); }
function pT({ window: e = ql } = {}) { if (!e)
    return M(!1); const t = M(e.document.hasFocus()); return nn(e, "blur", () => { t.value = !1; }), nn(e, "focus", () => { t.value = !0; }), t; }
function hT(e = {}) { const { window: t = ql, initialWidth: n = 1 / 0, initialHeight: o = 1 / 0, listenOrientation: r = !0, includeScrollbar: s = !0 } = e, l = M(n), a = M(o), u = () => { t && (s ? (l.value = t.innerWidth, a.value = t.innerHeight) : (l.value = t.document.documentElement.clientWidth, a.value = t.document.documentElement.clientHeight)); }; return u(), Hp(u), nn("resize", u, { passive: !0 }), r && nn("orientationchange", u, { passive: !0 }), { width: l, height: a }; }
const Wb = () => At && /firefox/i.test(window.navigator.userAgent), vT = (e, t) => { if (!At || !e || !t)
    return !1; const n = e.getBoundingClientRect(); let o; return t instanceof Element ? o = t.getBoundingClientRect() : o = { top: 0, right: window.innerWidth, bottom: window.innerHeight, left: 0 }, n.top < o.bottom && n.bottom > o.top && n.right > o.left && n.left < o.right; }, Wm = e => { let t = 0, n = e; for (; n;)
    t += n.offsetTop, n = n.offsetParent; return t; }, mT = (e, t) => Math.abs(Wm(e) - Wm(t)), jp = e => { let t, n; return e.type === "touchend" ? (n = e.changedTouches[0].clientY, t = e.changedTouches[0].clientX) : e.type.startsWith("touch") ? (n = e.touches[0].clientY, t = e.touches[0].clientX) : (n = e.clientY, t = e.clientX), { clientX: t, clientY: n }; };
var gT = typeof global == "object" && global && global.Object === Object && global;
const Ub = gT;
var yT = typeof self == "object" && self && self.Object === Object && self, bT = Ub || yT || Function("return this")();
const jo = bT;
var wT = jo.Symbol;
const $o = wT;
var qb = Object.prototype, CT = qb.hasOwnProperty, ST = qb.toString, aa = $o ? $o.toStringTag : void 0;
function _T(e) { var t = CT.call(e, aa), n = e[aa]; try {
    e[aa] = void 0;
    var o = !0;
}
catch { } var r = ST.call(e); return o && (t ? e[aa] = n : delete e[aa]), r; }
var kT = Object.prototype, ET = kT.toString;
function $T(e) { return ET.call(e); }
var TT = "[object Null]", OT = "[object Undefined]", Um = $o ? $o.toStringTag : void 0;
function Ws(e) { return e == null ? e === void 0 ? OT : TT : Um && Um in Object(e) ? _T(e) : $T(e); }
function er(e) { return e != null && typeof e == "object"; }
var IT = "[object Symbol]";
function Sc(e) { return typeof e == "symbol" || er(e) && Ws(e) == IT; }
function Yb(e, t) { for (var n = -1, o = e == null ? 0 : e.length, r = Array(o); ++n < o;)
    r[n] = t(e[n], n, e); return r; }
var xT = Array.isArray;
const Yn = xT;
var AT = 1 / 0, qm = $o ? $o.prototype : void 0, Ym = qm ? qm.toString : void 0;
function Gb(e) { if (typeof e == "string")
    return e; if (Yn(e))
    return Yb(e, Gb) + ""; if (Sc(e))
    return Ym ? Ym.call(e) : ""; var t = e + ""; return t == "0" && 1 / e == -AT ? "-0" : t; }
var MT = /\s/;
function NT(e) { for (var t = e.length; t-- && MT.test(e.charAt(t));)
    ; return t; }
var PT = /^\s+/;
function RT(e) { return e && e.slice(0, NT(e) + 1).replace(PT, ""); }
function Gn(e) { var t = typeof e; return e != null && (t == "object" || t == "function"); }
var Gm = 0 / 0, LT = /^[-+]0x[0-9a-f]+$/i, DT = /^0b[01]+$/i, BT = /^0o[0-7]+$/i, FT = parseInt;
function Xm(e) { if (typeof e == "number")
    return e; if (Sc(e))
    return Gm; if (Gn(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Gn(t) ? t + "" : t;
} if (typeof e != "string")
    return e === 0 ? e : +e; e = RT(e); var n = DT.test(e); return n || BT.test(e) ? FT(e.slice(2), n ? 2 : 8) : LT.test(e) ? Gm : +e; }
function Wp(e) { return e; }
var VT = "[object AsyncFunction]", zT = "[object Function]", HT = "[object GeneratorFunction]", KT = "[object Proxy]";
function Up(e) { if (!Gn(e))
    return !1; var t = Ws(e); return t == zT || t == HT || t == VT || t == KT; }
var jT = jo["__core-js_shared__"];
const gd = jT;
var Jm = function () { var e = /[^.]+$/.exec(gd && gd.keys && gd.keys.IE_PROTO || ""); return e ? "Symbol(src)_1." + e : ""; }();
function WT(e) { return !!Jm && Jm in e; }
var UT = Function.prototype, qT = UT.toString;
function Us(e) { if (e != null) {
    try {
        return qT.call(e);
    }
    catch { }
    try {
        return e + "";
    }
    catch { }
} return ""; }
var YT = /[\\^$.*+?()[\]{}|]/g, GT = /^\[object .+?Constructor\]$/, XT = Function.prototype, JT = Object.prototype, ZT = XT.toString, QT = JT.hasOwnProperty, eO = RegExp("^" + ZT.call(QT).replace(YT, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function tO(e) { if (!Gn(e) || WT(e))
    return !1; var t = Up(e) ? eO : GT; return t.test(Us(e)); }
function nO(e, t) { return e == null ? void 0 : e[t]; }
function qs(e, t) { var n = nO(e, t); return tO(n) ? n : void 0; }
var oO = qs(jo, "WeakMap");
const af = oO;
var Zm = Object.create, rO = function () { function e() { } return function (t) { if (!Gn(t))
    return {}; if (Zm)
    return Zm(t); e.prototype = t; var n = new e; return e.prototype = void 0, n; }; }();
const sO = rO;
function lO(e, t, n) { switch (n.length) {
    case 0: return e.call(t);
    case 1: return e.call(t, n[0]);
    case 2: return e.call(t, n[0], n[1]);
    case 3: return e.call(t, n[0], n[1], n[2]);
} return e.apply(t, n); }
function aO() { }
function Xb(e, t) { var n = -1, o = e.length; for (t || (t = Array(o)); ++n < o;)
    t[n] = e[n]; return t; }
var iO = 800, uO = 16, cO = Date.now;
function dO(e) { var t = 0, n = 0; return function () { var o = cO(), r = uO - (o - n); if (n = o, r > 0) {
    if (++t >= iO)
        return arguments[0];
}
else
    t = 0; return e.apply(void 0, arguments); }; }
function fO(e) { return function () { return e; }; }
var pO = function () { try {
    var e = qs(Object, "defineProperty");
    return e({}, "", {}), e;
}
catch { } }();
const Vu = pO;
var hO = Vu ? function (e, t) { return Vu(e, "toString", { configurable: !0, enumerable: !1, value: fO(t), writable: !0 }); } : Wp;
const vO = hO;
var mO = dO(vO);
const Jb = mO;
function gO(e, t) { for (var n = -1, o = e == null ? 0 : e.length; ++n < o && t(e[n], n, e) !== !1;)
    ; return e; }
function yO(e, t, n, o) { for (var r = e.length, s = n + (o ? 1 : -1); o ? s-- : ++s < r;)
    if (t(e[s], s, e))
        return s; return -1; }
function bO(e) { return e !== e; }
function wO(e, t, n) { for (var o = n - 1, r = e.length; ++o < r;)
    if (e[o] === t)
        return o; return -1; }
function CO(e, t, n) { return t === t ? wO(e, t, n) : yO(e, bO, n); }
function SO(e, t) { var n = e == null ? 0 : e.length; return !!n && CO(e, t, 0) > -1; }
var _O = 9007199254740991, kO = /^(?:0|[1-9]\d*)$/;
function _c(e, t) { var n = typeof e; return t = t ?? _O, !!t && (n == "number" || n != "symbol" && kO.test(e)) && e > -1 && e % 1 == 0 && e < t; }
function qp(e, t, n) { t == "__proto__" && Vu ? Vu(e, t, { configurable: !0, enumerable: !0, value: n, writable: !0 }) : e[t] = n; }
function gi(e, t) { return e === t || e !== e && t !== t; }
var EO = Object.prototype, $O = EO.hasOwnProperty;
function Yp(e, t, n) { var o = e[t]; (!($O.call(e, t) && gi(o, n)) || n === void 0 && !(t in e)) && qp(e, t, n); }
function yi(e, t, n, o) { var r = !n; n || (n = {}); for (var s = -1, l = t.length; ++s < l;) {
    var a = t[s], u = o ? o(n[a], e[a], a, n, e) : void 0;
    u === void 0 && (u = e[a]), r ? qp(n, a, u) : Yp(n, a, u);
} return n; }
var Qm = Math.max;
function Zb(e, t, n) { return t = Qm(t === void 0 ? e.length - 1 : t, 0), function () { for (var o = arguments, r = -1, s = Qm(o.length - t, 0), l = Array(s); ++r < s;)
    l[r] = o[t + r]; r = -1; for (var a = Array(t + 1); ++r < t;)
    a[r] = o[r]; return a[t] = n(l), lO(e, this, a); }; }
function Qb(e, t) { return Jb(Zb(e, t, Wp), e + ""); }
var TO = 9007199254740991;
function Gp(e) { return typeof e == "number" && e > -1 && e % 1 == 0 && e <= TO; }
function Yl(e) { return e != null && Gp(e.length) && !Up(e); }
function OO(e, t, n) { if (!Gn(n))
    return !1; var o = typeof t; return (o == "number" ? Yl(n) && _c(t, n.length) : o == "string" && t in n) ? gi(n[t], e) : !1; }
function IO(e) { return Qb(function (t, n) { var o = -1, r = n.length, s = r > 1 ? n[r - 1] : void 0, l = r > 2 ? n[2] : void 0; for (s = e.length > 3 && typeof s == "function" ? (r--, s) : void 0, l && OO(n[0], n[1], l) && (s = r < 3 ? void 0 : s, r = 1), t = Object(t); ++o < r;) {
    var a = n[o];
    a && e(t, a, o, s);
} return t; }); }
var xO = Object.prototype;
function Xp(e) { var t = e && e.constructor, n = typeof t == "function" && t.prototype || xO; return e === n; }
function AO(e, t) { for (var n = -1, o = Array(e); ++n < e;)
    o[n] = t(n); return o; }
var MO = "[object Arguments]";
function eg(e) { return er(e) && Ws(e) == MO; }
var e1 = Object.prototype, NO = e1.hasOwnProperty, PO = e1.propertyIsEnumerable, RO = eg(function () { return arguments; }()) ? eg : function (e) { return er(e) && NO.call(e, "callee") && !PO.call(e, "callee"); };
const ja = RO;
function LO() { return !1; }
var t1 = typeof exports == "object" && exports && !exports.nodeType && exports, tg = t1 && typeof module == "object" && module && !module.nodeType && module, DO = tg && tg.exports === t1, ng = DO ? jo.Buffer : void 0, BO = ng ? ng.isBuffer : void 0, FO = BO || LO;
const Wa = FO;
var VO = "[object Arguments]", zO = "[object Array]", HO = "[object Boolean]", KO = "[object Date]", jO = "[object Error]", WO = "[object Function]", UO = "[object Map]", qO = "[object Number]", YO = "[object Object]", GO = "[object RegExp]", XO = "[object Set]", JO = "[object String]", ZO = "[object WeakMap]", QO = "[object ArrayBuffer]", eI = "[object DataView]", tI = "[object Float32Array]", nI = "[object Float64Array]", oI = "[object Int8Array]", rI = "[object Int16Array]", sI = "[object Int32Array]", lI = "[object Uint8Array]", aI = "[object Uint8ClampedArray]", iI = "[object Uint16Array]", uI = "[object Uint32Array]", hn = {};
hn[tI] = hn[nI] = hn[oI] = hn[rI] = hn[sI] = hn[lI] = hn[aI] = hn[iI] = hn[uI] = !0;
hn[VO] = hn[zO] = hn[QO] = hn[HO] = hn[eI] = hn[KO] = hn[jO] = hn[WO] = hn[UO] = hn[qO] = hn[YO] = hn[GO] = hn[XO] = hn[JO] = hn[ZO] = !1;
function cI(e) { return er(e) && Gp(e.length) && !!hn[Ws(e)]; }
function Jp(e) { return function (t) { return e(t); }; }
var n1 = typeof exports == "object" && exports && !exports.nodeType && exports, _a = n1 && typeof module == "object" && module && !module.nodeType && module, dI = _a && _a.exports === n1, yd = dI && Ub.process, fI = function () { try {
    var e = _a && _a.require && _a.require("util").types;
    return e || yd && yd.binding && yd.binding("util");
}
catch { } }();
const Il = fI;
var og = Il && Il.isTypedArray, pI = og ? Jp(og) : cI;
const Zp = pI;
var hI = Object.prototype, vI = hI.hasOwnProperty;
function o1(e, t) { var n = Yn(e), o = !n && ja(e), r = !n && !o && Wa(e), s = !n && !o && !r && Zp(e), l = n || o || r || s, a = l ? AO(e.length, String) : [], u = a.length; for (var c in e)
    (t || vI.call(e, c)) && !(l && (c == "length" || r && (c == "offset" || c == "parent") || s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || _c(c, u))) && a.push(c); return a; }
function r1(e, t) { return function (n) { return e(t(n)); }; }
var mI = r1(Object.keys, Object);
const gI = mI;
var yI = Object.prototype, bI = yI.hasOwnProperty;
function wI(e) { if (!Xp(e))
    return gI(e); var t = []; for (var n in Object(e))
    bI.call(e, n) && n != "constructor" && t.push(n); return t; }
function bi(e) { return Yl(e) ? o1(e) : wI(e); }
function CI(e) { var t = []; if (e != null)
    for (var n in Object(e))
        t.push(n); return t; }
var SI = Object.prototype, _I = SI.hasOwnProperty;
function kI(e) { if (!Gn(e))
    return CI(e); var t = Xp(e), n = []; for (var o in e)
    o == "constructor" && (t || !_I.call(e, o)) || n.push(o); return n; }
function wi(e) { return Yl(e) ? o1(e, !0) : kI(e); }
var EI = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, $I = /^\w*$/;
function Qp(e, t) { if (Yn(e))
    return !1; var n = typeof e; return n == "number" || n == "symbol" || n == "boolean" || e == null || Sc(e) ? !0 : $I.test(e) || !EI.test(e) || t != null && e in Object(t); }
var TI = qs(Object, "create");
const Ua = TI;
function OI() { this.__data__ = Ua ? Ua(null) : {}, this.size = 0; }
function II(e) { var t = this.has(e) && delete this.__data__[e]; return this.size -= t ? 1 : 0, t; }
var xI = "__lodash_hash_undefined__", AI = Object.prototype, MI = AI.hasOwnProperty;
function NI(e) { var t = this.__data__; if (Ua) {
    var n = t[e];
    return n === xI ? void 0 : n;
} return MI.call(t, e) ? t[e] : void 0; }
var PI = Object.prototype, RI = PI.hasOwnProperty;
function LI(e) { var t = this.__data__; return Ua ? t[e] !== void 0 : RI.call(t, e); }
var DI = "__lodash_hash_undefined__";
function BI(e, t) { var n = this.__data__; return this.size += this.has(e) ? 0 : 1, n[e] = Ua && t === void 0 ? DI : t, this; }
function zs(e) { var t = -1, n = e == null ? 0 : e.length; for (this.clear(); ++t < n;) {
    var o = e[t];
    this.set(o[0], o[1]);
} }
zs.prototype.clear = OI;
zs.prototype.delete = II;
zs.prototype.get = NI;
zs.prototype.has = LI;
zs.prototype.set = BI;
function FI() { this.__data__ = [], this.size = 0; }
function kc(e, t) { for (var n = e.length; n--;)
    if (gi(e[n][0], t))
        return n; return -1; }
var VI = Array.prototype, zI = VI.splice;
function HI(e) { var t = this.__data__, n = kc(t, e); if (n < 0)
    return !1; var o = t.length - 1; return n == o ? t.pop() : zI.call(t, n, 1), --this.size, !0; }
function KI(e) { var t = this.__data__, n = kc(t, e); return n < 0 ? void 0 : t[n][1]; }
function jI(e) { return kc(this.__data__, e) > -1; }
function WI(e, t) { var n = this.__data__, o = kc(n, e); return o < 0 ? (++this.size, n.push([e, t])) : n[o][1] = t, this; }
function $r(e) { var t = -1, n = e == null ? 0 : e.length; for (this.clear(); ++t < n;) {
    var o = e[t];
    this.set(o[0], o[1]);
} }
$r.prototype.clear = FI;
$r.prototype.delete = HI;
$r.prototype.get = KI;
$r.prototype.has = jI;
$r.prototype.set = WI;
var UI = qs(jo, "Map");
const qa = UI;
function qI() { this.size = 0, this.__data__ = { hash: new zs, map: new (qa || $r), string: new zs }; }
function YI(e) { var t = typeof e; return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null; }
function Ec(e, t) { var n = e.__data__; return YI(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map; }
function GI(e) { var t = Ec(this, e).delete(e); return this.size -= t ? 1 : 0, t; }
function XI(e) { return Ec(this, e).get(e); }
function JI(e) { return Ec(this, e).has(e); }
function ZI(e, t) { var n = Ec(this, e), o = n.size; return n.set(e, t), this.size += n.size == o ? 0 : 1, this; }
function Tr(e) { var t = -1, n = e == null ? 0 : e.length; for (this.clear(); ++t < n;) {
    var o = e[t];
    this.set(o[0], o[1]);
} }
Tr.prototype.clear = qI;
Tr.prototype.delete = GI;
Tr.prototype.get = XI;
Tr.prototype.has = JI;
Tr.prototype.set = ZI;
var QI = "Expected a function";
function $c(e, t) { if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(QI); var n = function () { var o = arguments, r = t ? t.apply(this, o) : o[0], s = n.cache; if (s.has(r))
    return s.get(r); var l = e.apply(this, o); return n.cache = s.set(r, l) || s, l; }; return n.cache = new ($c.Cache || Tr), n; }
$c.Cache = Tr;
var ex = 500;
function tx(e) { var t = $c(e, function (o) { return n.size === ex && n.clear(), o; }), n = t.cache; return t; }
var nx = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, ox = /\\(\\)?/g, rx = tx(function (e) { var t = []; return e.charCodeAt(0) === 46 && t.push(""), e.replace(nx, function (n, o, r, s) { t.push(r ? s.replace(ox, "$1") : o || n); }), t; });
const sx = rx;
function lx(e) { return e == null ? "" : Gb(e); }
function Tc(e, t) { return Yn(e) ? e : Qp(e, t) ? [e] : sx(lx(e)); }
var ax = 1 / 0;
function Ci(e) { if (typeof e == "string" || Sc(e))
    return e; var t = e + ""; return t == "0" && 1 / e == -ax ? "-0" : t; }
function eh(e, t) { t = Tc(t, e); for (var n = 0, o = t.length; e != null && n < o;)
    e = e[Ci(t[n++])]; return n && n == o ? e : void 0; }
function sn(e, t, n) { var o = e == null ? void 0 : eh(e, t); return o === void 0 ? n : o; }
function th(e, t) { for (var n = -1, o = t.length, r = e.length; ++n < o;)
    e[r + n] = t[n]; return e; }
var rg = $o ? $o.isConcatSpreadable : void 0;
function ix(e) { return Yn(e) || ja(e) || !!(rg && e && e[rg]); }
function Si(e, t, n, o, r) { var s = -1, l = e.length; for (n || (n = ix), r || (r = []); ++s < l;) {
    var a = e[s];
    t > 0 && n(a) ? t > 1 ? Si(a, t - 1, n, o, r) : th(r, a) : o || (r[r.length] = a);
} return r; }
function s1(e) { var t = e == null ? 0 : e.length; return t ? Si(e, 1) : []; }
function ux(e) { return Jb(Zb(e, void 0, s1), e + ""); }
var cx = r1(Object.getPrototypeOf, Object);
const nh = cx;
var dx = "[object Object]", fx = Function.prototype, px = Object.prototype, l1 = fx.toString, hx = px.hasOwnProperty, vx = l1.call(Object);
function mx(e) { if (!er(e) || Ws(e) != dx)
    return !1; var t = nh(e); if (t === null)
    return !0; var n = hx.call(t, "constructor") && t.constructor; return typeof n == "function" && n instanceof n && l1.call(n) == vx; }
function xl() { if (!arguments.length)
    return []; var e = arguments[0]; return Yn(e) ? e : [e]; }
function gx() { this.__data__ = new $r, this.size = 0; }
function yx(e) { var t = this.__data__, n = t.delete(e); return this.size = t.size, n; }
function bx(e) { return this.__data__.get(e); }
function wx(e) { return this.__data__.has(e); }
var Cx = 200;
function Sx(e, t) { var n = this.__data__; if (n instanceof $r) {
    var o = n.__data__;
    if (!qa || o.length < Cx - 1)
        return o.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new Tr(o);
} return n.set(e, t), this.size = n.size, this; }
function Fo(e) { var t = this.__data__ = new $r(e); this.size = t.size; }
Fo.prototype.clear = gx;
Fo.prototype.delete = yx;
Fo.prototype.get = bx;
Fo.prototype.has = wx;
Fo.prototype.set = Sx;
function _x(e, t) { return e && yi(t, bi(t), e); }
function kx(e, t) { return e && yi(t, wi(t), e); }
var a1 = typeof exports == "object" && exports && !exports.nodeType && exports, sg = a1 && typeof module == "object" && module && !module.nodeType && module, Ex = sg && sg.exports === a1, lg = Ex ? jo.Buffer : void 0, ag = lg ? lg.allocUnsafe : void 0;
function i1(e, t) { if (t)
    return e.slice(); var n = e.length, o = ag ? ag(n) : new e.constructor(n); return e.copy(o), o; }
function $x(e, t) { for (var n = -1, o = e == null ? 0 : e.length, r = 0, s = []; ++n < o;) {
    var l = e[n];
    t(l, n, e) && (s[r++] = l);
} return s; }
function u1() { return []; }
var Tx = Object.prototype, Ox = Tx.propertyIsEnumerable, ig = Object.getOwnPropertySymbols, Ix = ig ? function (e) { return e == null ? [] : (e = Object(e), $x(ig(e), function (t) { return Ox.call(e, t); })); } : u1;
const oh = Ix;
function xx(e, t) { return yi(e, oh(e), t); }
var Ax = Object.getOwnPropertySymbols, Mx = Ax ? function (e) { for (var t = []; e;)
    th(t, oh(e)), e = nh(e); return t; } : u1;
const c1 = Mx;
function Nx(e, t) { return yi(e, c1(e), t); }
function d1(e, t, n) { var o = t(e); return Yn(e) ? o : th(o, n(e)); }
function uf(e) { return d1(e, bi, oh); }
function Px(e) { return d1(e, wi, c1); }
var Rx = qs(jo, "DataView");
const cf = Rx;
var Lx = qs(jo, "Promise");
const df = Lx;
var Dx = qs(jo, "Set");
const vl = Dx;
var ug = "[object Map]", Bx = "[object Object]", cg = "[object Promise]", dg = "[object Set]", fg = "[object WeakMap]", pg = "[object DataView]", Fx = Us(cf), Vx = Us(qa), zx = Us(df), Hx = Us(vl), Kx = Us(af), bs = Ws;
(cf && bs(new cf(new ArrayBuffer(1))) != pg || qa && bs(new qa) != ug || df && bs(df.resolve()) != cg || vl && bs(new vl) != dg || af && bs(new af) != fg) && (bs = function (e) { var t = Ws(e), n = t == Bx ? e.constructor : void 0, o = n ? Us(n) : ""; if (o)
    switch (o) {
        case Fx: return pg;
        case Vx: return ug;
        case zx: return cg;
        case Hx: return dg;
        case Kx: return fg;
    } return t; });
const Ya = bs;
var jx = Object.prototype, Wx = jx.hasOwnProperty;
function Ux(e) { var t = e.length, n = new e.constructor(t); return t && typeof e[0] == "string" && Wx.call(e, "index") && (n.index = e.index, n.input = e.input), n; }
var qx = jo.Uint8Array;
const zu = qx;
function rh(e) { var t = new e.constructor(e.byteLength); return new zu(t).set(new zu(e)), t; }
function Yx(e, t) { var n = t ? rh(e.buffer) : e.buffer; return new e.constructor(n, e.byteOffset, e.byteLength); }
var Gx = /\w*$/;
function Xx(e) { var t = new e.constructor(e.source, Gx.exec(e)); return t.lastIndex = e.lastIndex, t; }
var hg = $o ? $o.prototype : void 0, vg = hg ? hg.valueOf : void 0;
function Jx(e) { return vg ? Object(vg.call(e)) : {}; }
function f1(e, t) { var n = t ? rh(e.buffer) : e.buffer; return new e.constructor(n, e.byteOffset, e.length); }
var Zx = "[object Boolean]", Qx = "[object Date]", e3 = "[object Map]", t3 = "[object Number]", n3 = "[object RegExp]", o3 = "[object Set]", r3 = "[object String]", s3 = "[object Symbol]", l3 = "[object ArrayBuffer]", a3 = "[object DataView]", i3 = "[object Float32Array]", u3 = "[object Float64Array]", c3 = "[object Int8Array]", d3 = "[object Int16Array]", f3 = "[object Int32Array]", p3 = "[object Uint8Array]", h3 = "[object Uint8ClampedArray]", v3 = "[object Uint16Array]", m3 = "[object Uint32Array]";
function g3(e, t, n) { var o = e.constructor; switch (t) {
    case l3: return rh(e);
    case Zx:
    case Qx: return new o(+e);
    case a3: return Yx(e, n);
    case i3:
    case u3:
    case c3:
    case d3:
    case f3:
    case p3:
    case h3:
    case v3:
    case m3: return f1(e, n);
    case e3: return new o;
    case t3:
    case r3: return new o(e);
    case n3: return Xx(e);
    case o3: return new o;
    case s3: return Jx(e);
} }
function p1(e) { return typeof e.constructor == "function" && !Xp(e) ? sO(nh(e)) : {}; }
var y3 = "[object Map]";
function b3(e) { return er(e) && Ya(e) == y3; }
var mg = Il && Il.isMap, w3 = mg ? Jp(mg) : b3;
const C3 = w3;
var S3 = "[object Set]";
function _3(e) { return er(e) && Ya(e) == S3; }
var gg = Il && Il.isSet, k3 = gg ? Jp(gg) : _3;
const E3 = k3;
var $3 = 1, T3 = 2, O3 = 4, h1 = "[object Arguments]", I3 = "[object Array]", x3 = "[object Boolean]", A3 = "[object Date]", M3 = "[object Error]", v1 = "[object Function]", N3 = "[object GeneratorFunction]", P3 = "[object Map]", R3 = "[object Number]", m1 = "[object Object]", L3 = "[object RegExp]", D3 = "[object Set]", B3 = "[object String]", F3 = "[object Symbol]", V3 = "[object WeakMap]", z3 = "[object ArrayBuffer]", H3 = "[object DataView]", K3 = "[object Float32Array]", j3 = "[object Float64Array]", W3 = "[object Int8Array]", U3 = "[object Int16Array]", q3 = "[object Int32Array]", Y3 = "[object Uint8Array]", G3 = "[object Uint8ClampedArray]", X3 = "[object Uint16Array]", J3 = "[object Uint32Array]", dn = {};
dn[h1] = dn[I3] = dn[z3] = dn[H3] = dn[x3] = dn[A3] = dn[K3] = dn[j3] = dn[W3] = dn[U3] = dn[q3] = dn[P3] = dn[R3] = dn[m1] = dn[L3] = dn[D3] = dn[B3] = dn[F3] = dn[Y3] = dn[G3] = dn[X3] = dn[J3] = !0;
dn[M3] = dn[v1] = dn[V3] = !1;
function ka(e, t, n, o, r, s) { var l, a = t & $3, u = t & T3, c = t & O3; if (n && (l = r ? n(e, o, r, s) : n(e)), l !== void 0)
    return l; if (!Gn(e))
    return e; var d = Yn(e); if (d) {
    if (l = Ux(e), !a)
        return Xb(e, l);
}
else {
    var f = Ya(e), p = f == v1 || f == N3;
    if (Wa(e))
        return i1(e, a);
    if (f == m1 || f == h1 || p && !r) {
        if (l = u || p ? {} : p1(e), !a)
            return u ? Nx(e, kx(l, e)) : xx(e, _x(l, e));
    }
    else {
        if (!dn[f])
            return r ? e : {};
        l = g3(e, f, a);
    }
} s || (s = new Fo); var v = s.get(e); if (v)
    return v; s.set(e, l), E3(e) ? e.forEach(function (g) { l.add(ka(g, t, n, g, e, s)); }) : C3(e) && e.forEach(function (g, y) { l.set(y, ka(g, t, n, y, e, s)); }); var m = c ? u ? Px : uf : u ? wi : bi, h = d ? void 0 : m(e); return gO(h || e, function (g, y) { h && (y = g, g = e[y]), Yp(l, y, ka(g, t, n, y, e, s)); }), l; }
var Z3 = 4;
function yg(e) { return ka(e, Z3); }
var Q3 = 1, eA = 4;
function Hu(e) { return ka(e, Q3 | eA); }
var tA = "__lodash_hash_undefined__";
function nA(e) { return this.__data__.set(e, tA), this; }
function oA(e) { return this.__data__.has(e); }
function Ga(e) { var t = -1, n = e == null ? 0 : e.length; for (this.__data__ = new Tr; ++t < n;)
    this.add(e[t]); }
Ga.prototype.add = Ga.prototype.push = nA;
Ga.prototype.has = oA;
function rA(e, t) { for (var n = -1, o = e == null ? 0 : e.length; ++n < o;)
    if (t(e[n], n, e))
        return !0; return !1; }
function g1(e, t) { return e.has(t); }
var sA = 1, lA = 2;
function y1(e, t, n, o, r, s) { var l = n & sA, a = e.length, u = t.length; if (a != u && !(l && u > a))
    return !1; var c = s.get(e), d = s.get(t); if (c && d)
    return c == t && d == e; var f = -1, p = !0, v = n & lA ? new Ga : void 0; for (s.set(e, t), s.set(t, e); ++f < a;) {
    var m = e[f], h = t[f];
    if (o)
        var g = l ? o(h, m, f, t, e, s) : o(m, h, f, e, t, s);
    if (g !== void 0) {
        if (g)
            continue;
        p = !1;
        break;
    }
    if (v) {
        if (!rA(t, function (y, C) { if (!g1(v, C) && (m === y || r(m, y, n, o, s)))
            return v.push(C); })) {
            p = !1;
            break;
        }
    }
    else if (!(m === h || r(m, h, n, o, s))) {
        p = !1;
        break;
    }
} return s.delete(e), s.delete(t), p; }
function aA(e) { var t = -1, n = Array(e.size); return e.forEach(function (o, r) { n[++t] = [r, o]; }), n; }
function sh(e) { var t = -1, n = Array(e.size); return e.forEach(function (o) { n[++t] = o; }), n; }
var iA = 1, uA = 2, cA = "[object Boolean]", dA = "[object Date]", fA = "[object Error]", pA = "[object Map]", hA = "[object Number]", vA = "[object RegExp]", mA = "[object Set]", gA = "[object String]", yA = "[object Symbol]", bA = "[object ArrayBuffer]", wA = "[object DataView]", bg = $o ? $o.prototype : void 0, bd = bg ? bg.valueOf : void 0;
function CA(e, t, n, o, r, s, l) { switch (n) {
    case wA:
        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
            return !1;
        e = e.buffer, t = t.buffer;
    case bA: return !(e.byteLength != t.byteLength || !s(new zu(e), new zu(t)));
    case cA:
    case dA:
    case hA: return gi(+e, +t);
    case fA: return e.name == t.name && e.message == t.message;
    case vA:
    case gA: return e == t + "";
    case pA: var a = aA;
    case mA:
        var u = o & iA;
        if (a || (a = sh), e.size != t.size && !u)
            return !1;
        var c = l.get(e);
        if (c)
            return c == t;
        o |= uA, l.set(e, t);
        var d = y1(a(e), a(t), o, r, s, l);
        return l.delete(e), d;
    case yA: if (bd)
        return bd.call(e) == bd.call(t);
} return !1; }
var SA = 1, _A = Object.prototype, kA = _A.hasOwnProperty;
function EA(e, t, n, o, r, s) { var l = n & SA, a = uf(e), u = a.length, c = uf(t), d = c.length; if (u != d && !l)
    return !1; for (var f = u; f--;) {
    var p = a[f];
    if (!(l ? p in t : kA.call(t, p)))
        return !1;
} var v = s.get(e), m = s.get(t); if (v && m)
    return v == t && m == e; var h = !0; s.set(e, t), s.set(t, e); for (var g = l; ++f < u;) {
    p = a[f];
    var y = e[p], C = t[p];
    if (o)
        var b = l ? o(C, y, p, t, e, s) : o(y, C, p, e, t, s);
    if (!(b === void 0 ? y === C || r(y, C, n, o, s) : b)) {
        h = !1;
        break;
    }
    g || (g = p == "constructor");
} if (h && !g) {
    var w = e.constructor, T = t.constructor;
    w != T && "constructor" in e && "constructor" in t && !(typeof w == "function" && w instanceof w && typeof T == "function" && T instanceof T) && (h = !1);
} return s.delete(e), s.delete(t), h; }
var $A = 1, wg = "[object Arguments]", Cg = "[object Array]", Vi = "[object Object]", TA = Object.prototype, Sg = TA.hasOwnProperty;
function OA(e, t, n, o, r, s) { var l = Yn(e), a = Yn(t), u = l ? Cg : Ya(e), c = a ? Cg : Ya(t); u = u == wg ? Vi : u, c = c == wg ? Vi : c; var d = u == Vi, f = c == Vi, p = u == c; if (p && Wa(e)) {
    if (!Wa(t))
        return !1;
    l = !0, d = !1;
} if (p && !d)
    return s || (s = new Fo), l || Zp(e) ? y1(e, t, n, o, r, s) : CA(e, t, u, n, o, r, s); if (!(n & $A)) {
    var v = d && Sg.call(e, "__wrapped__"), m = f && Sg.call(t, "__wrapped__");
    if (v || m) {
        var h = v ? e.value() : e, g = m ? t.value() : t;
        return s || (s = new Fo), r(h, g, n, o, s);
    }
} return p ? (s || (s = new Fo), EA(e, t, n, o, r, s)) : !1; }
function Oc(e, t, n, o, r) { return e === t ? !0 : e == null || t == null || !er(e) && !er(t) ? e !== e && t !== t : OA(e, t, n, o, Oc, r); }
var IA = 1, xA = 2;
function AA(e, t, n, o) { var r = n.length, s = r, l = !o; if (e == null)
    return !s; for (e = Object(e); r--;) {
    var a = n[r];
    if (l && a[2] ? a[1] !== e[a[0]] : !(a[0] in e))
        return !1;
} for (; ++r < s;) {
    a = n[r];
    var u = a[0], c = e[u], d = a[1];
    if (l && a[2]) {
        if (c === void 0 && !(u in e))
            return !1;
    }
    else {
        var f = new Fo;
        if (o)
            var p = o(c, d, u, e, t, f);
        if (!(p === void 0 ? Oc(d, c, IA | xA, o, f) : p))
            return !1;
    }
} return !0; }
function b1(e) { return e === e && !Gn(e); }
function MA(e) { for (var t = bi(e), n = t.length; n--;) {
    var o = t[n], r = e[o];
    t[n] = [o, r, b1(r)];
} return t; }
function w1(e, t) { return function (n) { return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n)); }; }
function NA(e) { var t = MA(e); return t.length == 1 && t[0][2] ? w1(t[0][0], t[0][1]) : function (n) { return n === e || AA(n, e, t); }; }
function PA(e, t) { return e != null && t in Object(e); }
function RA(e, t, n) { t = Tc(t, e); for (var o = -1, r = t.length, s = !1; ++o < r;) {
    var l = Ci(t[o]);
    if (!(s = e != null && n(e, l)))
        break;
    e = e[l];
} return s || ++o != r ? s : (r = e == null ? 0 : e.length, !!r && Gp(r) && _c(l, r) && (Yn(e) || ja(e))); }
function C1(e, t) { return e != null && RA(e, t, PA); }
var LA = 1, DA = 2;
function BA(e, t) { return Qp(e) && b1(t) ? w1(Ci(e), t) : function (n) { var o = sn(n, e); return o === void 0 && o === t ? C1(n, e) : Oc(t, o, LA | DA); }; }
function FA(e) { return function (t) { return t == null ? void 0 : t[e]; }; }
function VA(e) { return function (t) { return eh(t, e); }; }
function zA(e) { return Qp(e) ? FA(Ci(e)) : VA(e); }
function HA(e) { return typeof e == "function" ? e : e == null ? Wp : typeof e == "object" ? Yn(e) ? BA(e[0], e[1]) : NA(e) : zA(e); }
function KA(e) { return function (t, n, o) { for (var r = -1, s = Object(t), l = o(t), a = l.length; a--;) {
    var u = l[e ? a : ++r];
    if (n(s[u], u, s) === !1)
        break;
} return t; }; }
var jA = KA();
const S1 = jA;
function WA(e, t) { return e && S1(e, t, bi); }
function UA(e, t) { return function (n, o) { if (n == null)
    return n; if (!Yl(n))
    return e(n, o); for (var r = n.length, s = t ? r : -1, l = Object(n); (t ? s-- : ++s < r) && o(l[s], s, l) !== !1;)
    ; return n; }; }
var qA = UA(WA);
const YA = qA;
var GA = function () { return jo.Date.now(); };
const wd = GA;
var XA = "Expected a function", JA = Math.max, ZA = Math.min;
function Xn(e, t, n) { var o, r, s, l, a, u, c = 0, d = !1, f = !1, p = !0; if (typeof e != "function")
    throw new TypeError(XA); t = Xm(t) || 0, Gn(n) && (d = !!n.leading, f = "maxWait" in n, s = f ? JA(Xm(n.maxWait) || 0, t) : s, p = "trailing" in n ? !!n.trailing : p); function v(E) { var x = o, I = r; return o = r = void 0, c = E, l = e.apply(I, x), l; } function m(E) { return c = E, a = setTimeout(y, t), d ? v(E) : l; } function h(E) { var x = E - u, I = E - c, L = t - x; return f ? ZA(L, s - I) : L; } function g(E) { var x = E - u, I = E - c; return u === void 0 || x >= t || x < 0 || f && I >= s; } function y() { var E = wd(); if (g(E))
    return C(E); a = setTimeout(y, h(E)); } function C(E) { return a = void 0, p && o ? v(E) : (o = r = void 0, l); } function b() { a !== void 0 && clearTimeout(a), c = 0, o = u = r = a = void 0; } function w() { return a === void 0 ? l : C(wd()); } function T() { var E = wd(), x = g(E); if (o = arguments, r = this, u = E, x) {
    if (a === void 0)
        return m(u);
    if (f)
        return clearTimeout(a), a = setTimeout(y, t), v(u);
} return a === void 0 && (a = setTimeout(y, t)), l; } return T.cancel = b, T.flush = w, T; }
function ff(e, t, n) { (n !== void 0 && !gi(e[t], n) || n === void 0 && !(t in e)) && qp(e, t, n); }
function _1(e) { return er(e) && Yl(e); }
function pf(e, t) { if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t]; }
function QA(e) { return yi(e, wi(e)); }
function eM(e, t, n, o, r, s, l) { var a = pf(e, n), u = pf(t, n), c = l.get(u); if (c) {
    ff(e, n, c);
    return;
} var d = s ? s(a, u, n + "", e, t, l) : void 0, f = d === void 0; if (f) {
    var p = Yn(u), v = !p && Wa(u), m = !p && !v && Zp(u);
    d = u, p || v || m ? Yn(a) ? d = a : _1(a) ? d = Xb(a) : v ? (f = !1, d = i1(u, !0)) : m ? (f = !1, d = f1(u, !0)) : d = [] : mx(u) || ja(u) ? (d = a, ja(a) ? d = QA(a) : (!Gn(a) || Up(a)) && (d = p1(u))) : f = !1;
} f && (l.set(u, d), r(d, u, o, s, l), l.delete(u)), ff(e, n, d); }
function k1(e, t, n, o, r) { e !== t && S1(t, function (s, l) { if (r || (r = new Fo), Gn(s))
    eM(e, t, l, n, k1, o, r);
else {
    var a = o ? o(pf(e, l), s, l + "", e, t, r) : void 0;
    a === void 0 && (a = s), ff(e, l, a);
} }, wi); }
function tM(e, t, n) { for (var o = -1, r = e == null ? 0 : e.length; ++o < r;)
    if (n(t, e[o]))
        return !0; return !1; }
function nM(e, t) { var n = -1, o = Yl(e) ? Array(e.length) : []; return YA(e, function (r, s, l) { o[++n] = t(r, s, l); }), o; }
function oM(e, t) { var n = Yn(e) ? Yb : nM; return n(e, HA(t)); }
function rM(e, t) { return Si(oM(e, t), 1); }
var sM = 1 / 0;
function lM(e) { var t = e == null ? 0 : e.length; return t ? Si(e, sM) : []; }
function Ku(e) { for (var t = -1, n = e == null ? 0 : e.length, o = {}; ++t < n;) {
    var r = e[t];
    o[r[0]] = r[1];
} return o; }
function ro(e, t) { return Oc(e, t); }
function bn(e) { return e == null; }
function aM(e) { return e === void 0; }
var iM = IO(function (e, t, n) { k1(e, t, n); });
const E1 = iM;
function $1(e, t, n, o) { if (!Gn(e))
    return e; t = Tc(t, e); for (var r = -1, s = t.length, l = s - 1, a = e; a != null && ++r < s;) {
    var u = Ci(t[r]), c = n;
    if (u === "__proto__" || u === "constructor" || u === "prototype")
        return e;
    if (r != l) {
        var d = a[u];
        c = o ? o(d, u, a) : void 0, c === void 0 && (c = Gn(d) ? d : _c(t[r + 1]) ? [] : {});
    }
    Yp(a, u, c), a = a[u];
} return e; }
function uM(e, t, n) { for (var o = -1, r = t.length, s = {}; ++o < r;) {
    var l = t[o], a = eh(e, l);
    n(a, l) && $1(s, Tc(l, e), a);
} return s; }
function cM(e, t) { return uM(e, t, function (n, o) { return C1(e, o); }); }
var dM = ux(function (e, t) { return e == null ? {} : cM(e, t); });
const gr = dM;
function fM(e, t, n) { return e == null ? e : $1(e, t, n); }
var pM = "Expected a function";
function Rs(e, t, n) { var o = !0, r = !0; if (typeof e != "function")
    throw new TypeError(pM); return Gn(n) && (o = "leading" in n ? !!n.leading : o, r = "trailing" in n ? !!n.trailing : r), Xn(e, t, { leading: o, maxWait: t, trailing: r }); }
var hM = 1 / 0, vM = vl && 1 / sh(new vl([, -0]))[1] == hM ? function (e) { return new vl(e); } : aO;
const mM = vM;
var gM = 200;
function yM(e, t, n) { var o = -1, r = SO, s = e.length, l = !0, a = [], u = a; if (n)
    l = !1, r = tM;
else if (s >= gM) {
    var c = t ? null : mM(e);
    if (c)
        return sh(c);
    l = !1, r = g1, u = new Ga;
}
else
    u = t ? [] : a; e: for (; ++o < s;) {
    var d = e[o], f = t ? t(d) : d;
    if (d = n || d !== 0 ? d : 0, l && f === f) {
        for (var p = u.length; p--;)
            if (u[p] === f)
                continue e;
        t && u.push(f), a.push(d);
    }
    else
        r(u, f, n) || (u !== a && u.push(f), a.push(d));
} return a; }
var bM = Qb(function (e) { return yM(Si(e, 1, _1, !0)); });
const Cd = bM, En = e => e === void 0, wn = e => typeof e == "boolean", lt = e => typeof e == "number", wo = e => !e && e !== 0 || qe(e) && e.length === 0 || yt(e) && !Object.keys(e).length, To = e => typeof Element > "u" ? !1 : e instanceof Element, wM = e => bn(e), CM = e => it(e) ? !Number.isNaN(Number(e)) : !1, T1 = (e = "") => e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), Xo = e => vi(e), Xa = e => Object.keys(e), SM = e => Object.entries(e), cu = (e, t, n) => ({ get value() { return sn(e, t, n); }, set value(o) { fM(e, t, o); } });
class _M extends Error {
    constructor(t) { super(t), this.name = "ElementPlusError"; }
}
function _n(e, t) { throw new _M(`[${e}] ${t}`); }
const O1 = (e = "") => e.split(" ").filter(t => !!t.trim()), Vo = (e, t) => { if (!e || !t)
    return !1; if (t.includes(" "))
    throw new Error("className should not contain space."); return e.classList.contains(t); }, Jo = (e, t) => { !e || !t.trim() || e.classList.add(...O1(t)); }, so = (e, t) => { !e || !t.trim() || e.classList.remove(...O1(t)); }, Kr = (e, t) => { var n; if (!At || !e || !t)
    return ""; let o = Eo(t); o === "float" && (o = "cssFloat"); try {
    const r = e.style[o];
    if (r)
        return r;
    const s = (n = document.defaultView) == null ? void 0 : n.getComputedStyle(e, "");
    return s ? s[o] : "";
}
catch {
    return e.style[o];
} };
function gn(e, t = "px") { if (!e)
    return ""; if (lt(e) || CM(e))
    return `${e}${t}`; if (it(e))
    return e; }
const kM = (e, t) => { if (!At)
    return !1; const n = { undefined: "overflow", true: "overflow-y", false: "overflow-x" }[String(t)], o = Kr(e, n); return ["scroll", "auto", "overlay"].some(r => o.includes(r)); }, lh = (e, t) => { if (!At)
    return; let n = e; for (; n;) {
    if ([window, document, document.documentElement].includes(n))
        return window;
    if (kM(n, t))
        return n;
    n = n.parentNode;
} return n; };
let zi;
const I1 = e => { var t; if (!At)
    return 0; if (zi !== void 0)
    return zi; const n = document.createElement("div"); n.className = `${e}-scrollbar__wrap`, n.style.visibility = "hidden", n.style.width = "100px", n.style.position = "absolute", n.style.top = "-9999px", document.body.appendChild(n); const o = n.offsetWidth; n.style.overflow = "scroll"; const r = document.createElement("div"); r.style.width = "100%", n.appendChild(r); const s = r.offsetWidth; return (t = n.parentNode) == null || t.removeChild(n), zi = o - s, zi; };
function x1(e, t) { if (!At)
    return; if (!t) {
    e.scrollTop = 0;
    return;
} const n = []; let o = t.offsetParent; for (; o !== null && e !== o && e.contains(o);)
    n.push(o), o = o.offsetParent; const r = t.offsetTop + n.reduce((u, c) => u + c.offsetTop, 0), s = r + t.offsetHeight, l = e.scrollTop, a = l + e.clientHeight; r < l ? e.scrollTop = r : s > a && (e.scrollTop = s - e.clientHeight); } /*! Element Plus Icons Vue v2.1.0 */
var Dt = (e, t) => { let n = e.__vccOpts || e; for (let [o, r] of t)
    n[o] = r; return n; }, EM = { name: "ArrowDown" }, $M = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, TM = Q("path", { fill: "currentColor", d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z" }, null, -1), OM = [TM];
function IM(e, t, n, o, r, s) { return k(), z("svg", $M, OM); }
var ss = Dt(EM, [["render", IM], ["__file", "arrow-down.vue"]]), xM = { name: "ArrowLeft" }, AM = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, MM = Q("path", { fill: "currentColor", d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z" }, null, -1), NM = [MM];
function PM(e, t, n, o, r, s) { return k(), z("svg", AM, NM); }
var Zr = Dt(xM, [["render", PM], ["__file", "arrow-left.vue"]]), RM = { name: "ArrowRight" }, LM = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, DM = Q("path", { fill: "currentColor", d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z" }, null, -1), BM = [DM];
function FM(e, t, n, o, r, s) { return k(), z("svg", LM, BM); }
var Un = Dt(RM, [["render", FM], ["__file", "arrow-right.vue"]]), VM = { name: "ArrowUp" }, zM = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, HM = Q("path", { fill: "currentColor", d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z" }, null, -1), KM = [HM];
function jM(e, t, n, o, r, s) { return k(), z("svg", zM, KM); }
var Ic = Dt(VM, [["render", jM], ["__file", "arrow-up.vue"]]), WM = { name: "Back" }, UM = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, qM = Q("path", { fill: "currentColor", d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64z" }, null, -1), YM = Q("path", { fill: "currentColor", d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312L237.248 512z" }, null, -1), GM = [qM, YM];
function XM(e, t, n, o, r, s) { return k(), z("svg", UM, GM); }
var JM = Dt(WM, [["render", XM], ["__file", "back.vue"]]), ZM = { name: "Calendar" }, QM = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, e4 = Q("path", { fill: "currentColor", d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64H128zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0v32zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64z" }, null, -1), t4 = [e4];
function n4(e, t, n, o, r, s) { return k(), z("svg", QM, t4); }
var o4 = Dt(ZM, [["render", n4], ["__file", "calendar.vue"]]), r4 = { name: "CaretRight" }, s4 = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, l4 = Q("path", { fill: "currentColor", d: "M384 192v640l384-320.064z" }, null, -1), a4 = [l4];
function i4(e, t, n, o, r, s) { return k(), z("svg", s4, a4); }
var A1 = Dt(r4, [["render", i4], ["__file", "caret-right.vue"]]), u4 = { name: "CaretTop" }, c4 = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, d4 = Q("path", { fill: "currentColor", d: "M512 320 192 704h639.936z" }, null, -1), f4 = [d4];
function p4(e, t, n, o, r, s) { return k(), z("svg", c4, f4); }
var h4 = Dt(u4, [["render", p4], ["__file", "caret-top.vue"]]), v4 = { name: "Check" }, m4 = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, g4 = Q("path", { fill: "currentColor", d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z" }, null, -1), y4 = [g4];
function b4(e, t, n, o, r, s) { return k(), z("svg", m4, y4); }
var _i = Dt(v4, [["render", b4], ["__file", "check.vue"]]), w4 = { name: "CircleCheckFilled" }, C4 = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, S4 = Q("path", { fill: "currentColor", d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z" }, null, -1), _4 = [S4];
function k4(e, t, n, o, r, s) { return k(), z("svg", C4, _4); }
var E4 = Dt(w4, [["render", k4], ["__file", "circle-check-filled.vue"]]), $4 = { name: "CircleCheck" }, T4 = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, O4 = Q("path", { fill: "currentColor", d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z" }, null, -1), I4 = Q("path", { fill: "currentColor", d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z" }, null, -1), x4 = [O4, I4];
function A4(e, t, n, o, r, s) { return k(), z("svg", T4, x4); }
var ah = Dt($4, [["render", A4], ["__file", "circle-check.vue"]]), M4 = { name: "CircleCloseFilled" }, N4 = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, P4 = Q("path", { fill: "currentColor", d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z" }, null, -1), R4 = [P4];
function L4(e, t, n, o, r, s) { return k(), z("svg", N4, R4); }
var ih = Dt(M4, [["render", L4], ["__file", "circle-close-filled.vue"]]), D4 = { name: "CircleClose" }, B4 = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, F4 = Q("path", { fill: "currentColor", d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z" }, null, -1), V4 = Q("path", { fill: "currentColor", d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z" }, null, -1), z4 = [F4, V4];
function H4(e, t, n, o, r, s) { return k(), z("svg", B4, z4); }
var ls = Dt(D4, [["render", H4], ["__file", "circle-close.vue"]]), K4 = { name: "Clock" }, j4 = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, W4 = Q("path", { fill: "currentColor", d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z" }, null, -1), U4 = Q("path", { fill: "currentColor", d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32z" }, null, -1), q4 = Q("path", { fill: "currentColor", d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32z" }, null, -1), Y4 = [W4, U4, q4];
function G4(e, t, n, o, r, s) { return k(), z("svg", j4, Y4); }
var M1 = Dt(K4, [["render", G4], ["__file", "clock.vue"]]), X4 = { name: "Close" }, J4 = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, Z4 = Q("path", { fill: "currentColor", d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z" }, null, -1), Q4 = [Z4];
function eN(e, t, n, o, r, s) { return k(), z("svg", J4, Q4); }
var Ho = Dt(X4, [["render", eN], ["__file", "close.vue"]]), tN = { name: "DArrowLeft" }, nN = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, oN = Q("path", { fill: "currentColor", d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z" }, null, -1), rN = [oN];
function sN(e, t, n, o, r, s) { return k(), z("svg", nN, rN); }
var Al = Dt(tN, [["render", sN], ["__file", "d-arrow-left.vue"]]), lN = { name: "DArrowRight" }, aN = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, iN = Q("path", { fill: "currentColor", d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688zm-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z" }, null, -1), uN = [iN];
function cN(e, t, n, o, r, s) { return k(), z("svg", aN, uN); }
var Ml = Dt(lN, [["render", cN], ["__file", "d-arrow-right.vue"]]), dN = { name: "Delete" }, fN = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, pN = Q("path", { fill: "currentColor", d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z" }, null, -1), hN = [pN];
function vN(e, t, n, o, r, s) { return k(), z("svg", fN, hN); }
var mN = Dt(dN, [["render", vN], ["__file", "delete.vue"]]), gN = { name: "Document" }, yN = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, bN = Q("path", { fill: "currentColor", d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z" }, null, -1), wN = [bN];
function CN(e, t, n, o, r, s) { return k(), z("svg", yN, wN); }
var SN = Dt(gN, [["render", CN], ["__file", "document.vue"]]), _N = { name: "FullScreen" }, kN = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, EN = Q("path", { fill: "currentColor", d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64v.064zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64l-192 .192zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64v-.064z" }, null, -1), $N = [EN];
function TN(e, t, n, o, r, s) { return k(), z("svg", kN, $N); }
var ON = Dt(_N, [["render", TN], ["__file", "full-screen.vue"]]), IN = { name: "Hide" }, xN = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, AN = Q("path", { fill: "currentColor", d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z" }, null, -1), MN = Q("path", { fill: "currentColor", d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z" }, null, -1), NN = [AN, MN];
function PN(e, t, n, o, r, s) { return k(), z("svg", xN, NN); }
var RN = Dt(IN, [["render", PN], ["__file", "hide.vue"]]), LN = { name: "InfoFilled" }, DN = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, BN = Q("path", { fill: "currentColor", d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z" }, null, -1), FN = [BN];
function VN(e, t, n, o, r, s) { return k(), z("svg", DN, FN); }
var uh = Dt(LN, [["render", VN], ["__file", "info-filled.vue"]]), zN = { name: "Loading" }, HN = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, KN = Q("path", { fill: "currentColor", d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z" }, null, -1), jN = [KN];
function WN(e, t, n, o, r, s) { return k(), z("svg", HN, jN); }
var as = Dt(zN, [["render", WN], ["__file", "loading.vue"]]), UN = { name: "Minus" }, qN = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, YN = Q("path", { fill: "currentColor", d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64z" }, null, -1), GN = [YN];
function XN(e, t, n, o, r, s) { return k(), z("svg", qN, GN); }
var JN = Dt(UN, [["render", XN], ["__file", "minus.vue"]]), ZN = { name: "MoreFilled" }, QN = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, eP = Q("path", { fill: "currentColor", d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224z" }, null, -1), tP = [eP];
function nP(e, t, n, o, r, s) { return k(), z("svg", QN, tP); }
var _g = Dt(ZN, [["render", nP], ["__file", "more-filled.vue"]]), oP = { name: "More" }, rP = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, sP = Q("path", { fill: "currentColor", d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96z" }, null, -1), lP = [sP];
function aP(e, t, n, o, r, s) { return k(), z("svg", rP, lP); }
var iP = Dt(oP, [["render", aP], ["__file", "more.vue"]]), uP = { name: "PictureFilled" }, cP = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, dP = Q("path", { fill: "currentColor", d: "M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32H96zm315.52-228.48-68.928-68.928a32 32 0 0 0-45.248 0L128 768.064h778.688l-242.112-290.56a32 32 0 0 0-49.216 0L458.752 665.408a32 32 0 0 1-47.232 2.112zM256 384a96 96 0 1 0 192.064-.064A96 96 0 0 0 256 384z" }, null, -1), fP = [dP];
function pP(e, t, n, o, r, s) { return k(), z("svg", cP, fP); }
var hP = Dt(uP, [["render", pP], ["__file", "picture-filled.vue"]]), vP = { name: "Plus" }, mP = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, gP = Q("path", { fill: "currentColor", d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64h352z" }, null, -1), yP = [gP];
function bP(e, t, n, o, r, s) { return k(), z("svg", mP, yP); }
var N1 = Dt(vP, [["render", bP], ["__file", "plus.vue"]]), wP = { name: "QuestionFilled" }, CP = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, SP = Q("path", { fill: "currentColor", d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z" }, null, -1), _P = [SP];
function kP(e, t, n, o, r, s) { return k(), z("svg", CP, _P); }
var EP = Dt(wP, [["render", kP], ["__file", "question-filled.vue"]]), $P = { name: "RefreshLeft" }, TP = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, OP = Q("path", { fill: "currentColor", d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z" }, null, -1), IP = [OP];
function xP(e, t, n, o, r, s) { return k(), z("svg", TP, IP); }
var AP = Dt($P, [["render", xP], ["__file", "refresh-left.vue"]]), MP = { name: "RefreshRight" }, NP = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, PP = Q("path", { fill: "currentColor", d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z" }, null, -1), RP = [PP];
function LP(e, t, n, o, r, s) { return k(), z("svg", NP, RP); }
var DP = Dt(MP, [["render", LP], ["__file", "refresh-right.vue"]]), BP = { name: "ScaleToOriginal" }, FP = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, VP = Q("path", { fill: "currentColor", d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zM512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412zM512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512z" }, null, -1), zP = [VP];
function HP(e, t, n, o, r, s) { return k(), z("svg", FP, zP); }
var KP = Dt(BP, [["render", HP], ["__file", "scale-to-original.vue"]]), jP = { name: "Search" }, WP = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, UP = Q("path", { fill: "currentColor", d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704z" }, null, -1), qP = [UP];
function YP(e, t, n, o, r, s) { return k(), z("svg", WP, qP); }
var GP = Dt(jP, [["render", YP], ["__file", "search.vue"]]), XP = { name: "SortDown" }, JP = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, ZP = Q("path", { fill: "currentColor", d: "M576 96v709.568L333.312 562.816A32 32 0 1 0 288 608l297.408 297.344A32 32 0 0 0 640 882.688V96a32 32 0 0 0-64 0z" }, null, -1), QP = [ZP];
function eR(e, t, n, o, r, s) { return k(), z("svg", JP, QP); }
var tR = Dt(XP, [["render", eR], ["__file", "sort-down.vue"]]), nR = { name: "SortUp" }, oR = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, rR = Q("path", { fill: "currentColor", d: "M384 141.248V928a32 32 0 1 0 64 0V218.56l242.688 242.688A32 32 0 1 0 736 416L438.592 118.656A32 32 0 0 0 384 141.248z" }, null, -1), sR = [rR];
function lR(e, t, n, o, r, s) { return k(), z("svg", oR, sR); }
var aR = Dt(nR, [["render", lR], ["__file", "sort-up.vue"]]), iR = { name: "StarFilled" }, uR = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, cR = Q("path", { fill: "currentColor", d: "M283.84 867.84 512 747.776l228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72z" }, null, -1), dR = [cR];
function fR(e, t, n, o, r, s) { return k(), z("svg", uR, dR); }
var Hi = Dt(iR, [["render", fR], ["__file", "star-filled.vue"]]), pR = { name: "Star" }, hR = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, vR = Q("path", { fill: "currentColor", d: "m512 747.84 228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72L512 747.84zM313.6 924.48a70.4 70.4 0 0 1-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z" }, null, -1), mR = [vR];
function gR(e, t, n, o, r, s) { return k(), z("svg", hR, mR); }
var yR = Dt(pR, [["render", gR], ["__file", "star.vue"]]), bR = { name: "SuccessFilled" }, wR = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, CR = Q("path", { fill: "currentColor", d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z" }, null, -1), SR = [CR];
function _R(e, t, n, o, r, s) { return k(), z("svg", wR, SR); }
var P1 = Dt(bR, [["render", _R], ["__file", "success-filled.vue"]]), kR = { name: "View" }, ER = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, $R = Q("path", { fill: "currentColor", d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z" }, null, -1), TR = [$R];
function OR(e, t, n, o, r, s) { return k(), z("svg", ER, TR); }
var IR = Dt(kR, [["render", OR], ["__file", "view.vue"]]), xR = { name: "WarningFilled" }, AR = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, MR = Q("path", { fill: "currentColor", d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z" }, null, -1), NR = [MR];
function PR(e, t, n, o, r, s) { return k(), z("svg", AR, NR); }
var xc = Dt(xR, [["render", PR], ["__file", "warning-filled.vue"]]), RR = { name: "ZoomIn" }, LR = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, DR = Q("path", { fill: "currentColor", d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zm-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96z" }, null, -1), BR = [DR];
function FR(e, t, n, o, r, s) { return k(), z("svg", LR, BR); }
var R1 = Dt(RR, [["render", FR], ["__file", "zoom-in.vue"]]), VR = { name: "ZoomOut" }, zR = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, HR = Q("path", { fill: "currentColor", d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zM352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64z" }, null, -1), KR = [HR];
function jR(e, t, n, o, r, s) { return k(), z("svg", zR, KR); }
var WR = Dt(VR, [["render", jR], ["__file", "zoom-out.vue"]]);
const L1 = "__epPropKey", ve = e => e, UR = e => yt(e) && !!e[L1], Wo = (e, t) => { if (!yt(e) || UR(e))
    return e; const { values: n, required: o, default: r, type: s, validator: l } = e, u = { type: s, required: !!o, validator: n || l ? c => { let d = !1, f = []; if (n && (f = Array.from(n), Tt(e, "default") && f.push(r), d || (d = f.includes(c))), l && (d || (d = l(c))), !d && f.length > 0) {
        const p = [...new Set(f)].map(v => JSON.stringify(v)).join(", ");
        J_(`Invalid prop: validation failed${t ? ` for prop "${t}"` : ""}. Expected one of [${p}], got value ${JSON.stringify(c)}.`);
    } return d; } : void 0, [L1]: !0 }; return Tt(e, "default") && (u.default = r), u; }, Ve = e => Ku(Object.entries(e).map(([t, n]) => [t, Wo(n, t)])), Zt = ve([String, Object, Function]), D1 = { Close: Ho }, ch = { Close: Ho, SuccessFilled: P1, InfoFilled: uh, WarningFilled: xc, CircleCloseFilled: ih }, Qr = { success: P1, warning: xc, error: ih, info: uh }, B1 = { validating: as, success: ah, error: ls }, vt = (e, t) => { if (e.install = n => { for (const o of [e, ...Object.values(t ?? {})])
    n.component(o.name, o); }, t)
    for (const [n, o] of Object.entries(t))
        e[n] = o; return e; }, F1 = (e, t) => (e.install = n => { e._context = n._context, n.config.globalProperties[t] = e; }, e), qR = (e, t) => (e.install = n => { n.directive(t, e); }, e), pn = e => (e.install = Wt, e), Ac = (...e) => t => { e.forEach(n => { at(n) ? n(t) : n.value = t; }); }, tt = { tab: "Tab", enter: "Enter", space: "Space", left: "ArrowLeft", up: "ArrowUp", right: "ArrowRight", down: "ArrowDown", esc: "Escape", delete: "Delete", backspace: "Backspace", numpadEnter: "NumpadEnter", pageUp: "PageUp", pageDown: "PageDown", home: "Home", end: "End" }, YR = ["year", "month", "date", "dates", "week", "datetime", "datetimerange", "daterange", "monthrange"], Sd = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"], gt = "update:modelValue", en = "change", qn = "input", kg = Symbol("INSTALLED_KEY"), sr = ["", "default", "small", "large"], GR = { large: 40, default: 32, small: 24 }, XR = e => GR[e || "default"], Mc = e => ["", ...sr].includes(e);
var bo = (e => (e[e.TEXT = 1] = "TEXT", e[e.CLASS = 2] = "CLASS", e[e.STYLE = 4] = "STYLE", e[e.PROPS = 8] = "PROPS", e[e.FULL_PROPS = 16] = "FULL_PROPS", e[e.HYDRATE_EVENTS = 32] = "HYDRATE_EVENTS", e[e.STABLE_FRAGMENT = 64] = "STABLE_FRAGMENT", e[e.KEYED_FRAGMENT = 128] = "KEYED_FRAGMENT", e[e.UNKEYED_FRAGMENT = 256] = "UNKEYED_FRAGMENT", e[e.NEED_PATCH = 512] = "NEED_PATCH", e[e.DYNAMIC_SLOTS = 1024] = "DYNAMIC_SLOTS", e[e.HOISTED = -1] = "HOISTED", e[e.BAIL = -2] = "BAIL", e))(bo || {});
function hf(e) { return un(e) && e.type === Qe; }
function JR(e) { return un(e) && e.type === Wn; }
function ZR(e) { return un(e) && !hf(e) && !JR(e); }
const QR = e => { if (!un(e))
    return {}; const t = e.props || {}, n = (un(e.type) ? e.type.props : void 0) || {}, o = {}; return Object.keys(n).forEach(r => { Tt(n[r], "default") && (o[r] = n[r].default); }), Object.keys(t).forEach(r => { o[Eo(r)] = t[r]; }), o; }, e8 = e => { if (!qe(e) || e.length > 1)
    throw new Error("expect to receive a single Vue element child"); return e[0]; }, ml = e => { const t = qe(e) ? e : [e], n = []; return t.forEach(o => { var r; qe(o) ? n.push(...ml(o)) : un(o) && qe(o.children) ? n.push(...ml(o.children)) : (n.push(o), un(o) && ((r = o.component) != null && r.subTree) && n.push(...ml(o.component.subTree))); }), n; }, Eg = e => [...new Set(e)], yr = e => !e && e !== 0 ? [] : Array.isArray(e) ? e : [e], Nc = e => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(e), Ja = e => At ? window.requestAnimationFrame(e) : setTimeout(e, 16), Pc = e => At ? window.cancelAnimationFrame(e) : clearTimeout(e), Rc = () => Math.floor(Math.random() * 1e4), ln = e => e, t8 = ["class", "style"], n8 = /^on[A-Z]/, dh = (e = {}) => { const { excludeListeners: t = !1, excludeKeys: n } = e, o = S(() => ((n == null ? void 0 : n.value) || []).concat(t8)), r = ht(); return S(r ? () => { var s; return Ku(Object.entries((s = r.proxy) == null ? void 0 : s.$attrs).filter(([l]) => !o.value.includes(l) && !(t && n8.test(l)))); } : () => ({})); }, tr = ({ from: e, replacement: t, scope: n, version: o, ref: r, type: s = "API" }, l) => { Oe(() => i(l), a => { }, { immediate: !0 }); }, V1 = (e, t, n) => { let o = { offsetX: 0, offsetY: 0 }; const r = a => { const u = a.clientX, c = a.clientY, { offsetX: d, offsetY: f } = o, p = e.value.getBoundingClientRect(), v = p.left, m = p.top, h = p.width, g = p.height, y = document.documentElement.clientWidth, C = document.documentElement.clientHeight, b = -v + d, w = -m + f, T = y - v - h + d, E = C - m - g + f, x = L => { const B = Math.min(Math.max(d + L.clientX - u, b), T), F = Math.min(Math.max(f + L.clientY - c, w), E); o = { offsetX: B, offsetY: F }, e.value.style.transform = `translate(${gn(B)}, ${gn(F)})`; }, I = () => { document.removeEventListener("mousemove", x), document.removeEventListener("mouseup", I); }; document.addEventListener("mousemove", x), document.addEventListener("mouseup", I); }, s = () => { t.value && e.value && t.value.addEventListener("mousedown", r); }, l = () => { t.value && e.value && t.value.removeEventListener("mousedown", r); }; ft(() => { mo(() => { n.value ? s() : l(); }); }), on(() => { l(); }); }, o8 = e => ({ focus: () => { var t, n; (n = (t = e.value) == null ? void 0 : t.focus) == null || n.call(t); } });
var r8 = { name: "en", el: { colorpicker: { confirm: "OK", clear: "Clear", defaultLabel: "color picker", description: "current color is {color}. press enter to select a new color." }, datepicker: { now: "Now", today: "Today", cancel: "Cancel", clear: "Clear", confirm: "OK", dateTablePrompt: "Use the arrow keys and enter to select the day of the month", monthTablePrompt: "Use the arrow keys and enter to select the month", yearTablePrompt: "Use the arrow keys and enter to select the year", selectedDate: "Selected date", selectDate: "Select date", selectTime: "Select time", startDate: "Start Date", startTime: "Start Time", endDate: "End Date", endTime: "End Time", prevYear: "Previous Year", nextYear: "Next Year", prevMonth: "Previous Month", nextMonth: "Next Month", year: "", month1: "January", month2: "February", month3: "March", month4: "April", month5: "May", month6: "June", month7: "July", month8: "August", month9: "September", month10: "October", month11: "November", month12: "December", week: "week", weeks: { sun: "Sun", mon: "Mon", tue: "Tue", wed: "Wed", thu: "Thu", fri: "Fri", sat: "Sat" }, weeksFull: { sun: "Sunday", mon: "Monday", tue: "Tuesday", wed: "Wednesday", thu: "Thursday", fri: "Friday", sat: "Saturday" }, months: { jan: "Jan", feb: "Feb", mar: "Mar", apr: "Apr", may: "May", jun: "Jun", jul: "Jul", aug: "Aug", sep: "Sep", oct: "Oct", nov: "Nov", dec: "Dec" } }, inputNumber: { decrease: "decrease number", increase: "increase number" }, select: { loading: "Loading", noMatch: "No matching data", noData: "No data", placeholder: "Select" }, dropdown: { toggleDropdown: "Toggle Dropdown" }, cascader: { noMatch: "No matching data", loading: "Loading", placeholder: "Select", noData: "No data" }, pagination: { goto: "Go to", pagesize: "/page", total: "Total {total}", pageClassifier: "", page: "Page", prev: "Go to previous page", next: "Go to next page", currentPage: "page {pager}", prevPages: "Previous {pager} pages", nextPages: "Next {pager} pages", deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details" }, dialog: { close: "Close this dialog" }, drawer: { close: "Close this dialog" }, messagebox: { title: "Message", confirm: "OK", cancel: "Cancel", error: "Illegal input", close: "Close this dialog" }, upload: { deleteTip: "press delete to remove", delete: "Delete", preview: "Preview", continue: "Continue" }, slider: { defaultLabel: "slider between {min} and {max}", defaultRangeStartLabel: "pick start value", defaultRangeEndLabel: "pick end value" }, table: { emptyText: "No Data", confirmFilter: "Confirm", resetFilter: "Reset", clearFilter: "All", sumText: "Sum" }, tree: { emptyText: "No Data" }, transfer: { noMatch: "No matching data", noData: "No data", titles: ["List 1", "List 2"], filterPlaceholder: "Enter keyword", noCheckedFormat: "{total} items", hasCheckedFormat: "{checked}/{total} checked" }, image: { error: "FAILED" }, pageHeader: { title: "Back" }, popconfirm: { confirmButtonText: "Yes", cancelButtonText: "No" } } };
const s8 = e => (t, n) => l8(t, n, i(e)), l8 = (e, t, n) => sn(n, e, e).replace(/\{(\w+)\}/g, (o, r) => { var s; return `${(s = t == null ? void 0 : t[r]) != null ? s : `{${r}}`}`; }), a8 = e => { const t = S(() => i(e).name), n = Jt(e) ? e : M(e); return { lang: t, locale: n, t: s8(e) }; }, z1 = Symbol("localeContextKey"), Nt = e => { const t = e || Ye(z1, M()); return a8(S(() => t.value || r8)); }, ju = "el", i8 = "is-", gs = (e, t, n, o, r) => { let s = `${e}-${t}`; return n && (s += `-${n}`), o && (s += `__${o}`), r && (s += `--${r}`), s; }, H1 = Symbol("namespaceContextKey"), fh = e => { const t = e || Ye(H1, M(ju)); return S(() => i(t) || ju); }, Ie = (e, t) => { const n = fh(t); return { namespace: n, b: (h = "") => gs(n.value, e, h, "", ""), e: h => h ? gs(n.value, e, "", h, "") : "", m: h => h ? gs(n.value, e, "", "", h) : "", be: (h, g) => h && g ? gs(n.value, e, h, g, "") : "", em: (h, g) => h && g ? gs(n.value, e, "", h, g) : "", bm: (h, g) => h && g ? gs(n.value, e, h, "", g) : "", bem: (h, g, y) => h && g && y ? gs(n.value, e, h, g, y) : "", is: (h, ...g) => { const y = g.length >= 1 ? g[0] : !0; return h && y ? `${i8}${h}` : ""; }, cssVar: h => { const g = {}; for (const y in h)
        h[y] && (g[`--${n.value}-${y}`] = h[y]); return g; }, cssVarName: h => `--${n.value}-${h}`, cssVarBlock: h => { const g = {}; for (const y in h)
        h[y] && (g[`--${n.value}-${e}-${y}`] = h[y]); return g; }, cssVarBlockName: h => `--${n.value}-${e}-${h}` }; }, K1 = (e, t = {}) => { Jt(e) || _n("[useLockscreen]", "You need to pass a ref param to this function"); const n = t.ns || Ie("popup"), o = Vy(() => n.bm("parent", "hidden")); if (!At || Vo(document.body, o.value))
    return; let r = 0, s = !1, l = "0"; const a = () => { setTimeout(() => { so(document == null ? void 0 : document.body, o.value), s && document && (document.body.style.width = l); }, 200); }; Oe(e, u => { if (!u) {
    a();
    return;
} s = !Vo(document.body, o.value), s && (l = document.body.style.width), r = I1(n.namespace.value); const c = document.documentElement.clientHeight < document.body.scrollHeight, d = Kr(document.body, "overflowY"); r > 0 && (c || d === "scroll") && s && (document.body.style.width = `calc(100% - ${r}px)`), Jo(document.body, o.value); }), ky(() => a()); }, u8 = Wo({ type: ve(Boolean), default: null }), c8 = Wo({ type: ve(Function) }), j1 = e => { const t = `update:${e}`, n = `onUpdate:${e}`, o = [t], r = { [e]: u8, [n]: c8 }; return { useModelToggle: ({ indicator: l, toggleReason: a, shouldHideWhenRouteChanges: u, shouldProceed: c, onShow: d, onHide: f }) => { const p = ht(), { emit: v } = p, m = p.props, h = S(() => at(m[n])), g = S(() => m[e] === null), y = x => { l.value !== !0 && (l.value = !0, a && (a.value = x), at(d) && d(x)); }, C = x => { l.value !== !1 && (l.value = !1, a && (a.value = x), at(f) && f(x)); }, b = x => { if (m.disabled === !0 || at(c) && !c())
        return; const I = h.value && At; I && v(t, !0), (g.value || !I) && y(x); }, w = x => { if (m.disabled === !0 || !At)
        return; const I = h.value && At; I && v(t, !1), (g.value || !I) && C(x); }, T = x => { wn(x) && (m.disabled && x ? h.value && v(t, !1) : l.value !== x && (x ? y() : C())); }, E = () => { l.value ? w() : b(); }; return Oe(() => m[e], T), u && p.appContext.config.globalProperties.$route !== void 0 && Oe(() => ({ ...p.proxy.$route }), () => { u.value && l.value && w(); }), ft(() => { T(m[e]); }), { hide: w, show: b, toggle: E, hasUpdateHandler: h }; }, useModelToggleProps: r, useModelToggleEmits: o }; };
j1("modelValue");
const W1 = e => { const t = ht(); return S(() => { var n, o; return (o = (n = t == null ? void 0 : t.proxy) == null ? void 0 : n.$props) == null ? void 0 : o[e]; }); };
var lo = "top", Oo = "bottom", Io = "right", ao = "left", ph = "auto", ki = [lo, Oo, Io, ao], Nl = "start", Za = "end", d8 = "clippingParents", U1 = "viewport", ia = "popper", f8 = "reference", $g = ki.reduce(function (e, t) { return e.concat([t + "-" + Nl, t + "-" + Za]); }, []), Ys = [].concat(ki, [ph]).reduce(function (e, t) { return e.concat([t, t + "-" + Nl, t + "-" + Za]); }, []), p8 = "beforeRead", h8 = "read", v8 = "afterRead", m8 = "beforeMain", g8 = "main", y8 = "afterMain", b8 = "beforeWrite", w8 = "write", C8 = "afterWrite", S8 = [p8, h8, v8, m8, g8, y8, b8, w8, C8];
function nr(e) { return e ? (e.nodeName || "").toLowerCase() : null; }
function Uo(e) { if (e == null)
    return window; if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
} return e; }
function Pl(e) { var t = Uo(e).Element; return e instanceof t || e instanceof Element; }
function _o(e) { var t = Uo(e).HTMLElement; return e instanceof t || e instanceof HTMLElement; }
function hh(e) { if (typeof ShadowRoot > "u")
    return !1; var t = Uo(e).ShadowRoot; return e instanceof t || e instanceof ShadowRoot; }
function _8(e) { var t = e.state; Object.keys(t.elements).forEach(function (n) { var o = t.styles[n] || {}, r = t.attributes[n] || {}, s = t.elements[n]; !_o(s) || !nr(s) || (Object.assign(s.style, o), Object.keys(r).forEach(function (l) { var a = r[l]; a === !1 ? s.removeAttribute(l) : s.setAttribute(l, a === !0 ? "" : a); })); }); }
function k8(e) { var t = e.state, n = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function () { Object.keys(t.elements).forEach(function (o) { var r = t.elements[o], s = t.attributes[o] || {}, l = Object.keys(t.styles.hasOwnProperty(o) ? t.styles[o] : n[o]), a = l.reduce(function (u, c) { return u[c] = "", u; }, {}); !_o(r) || !nr(r) || (Object.assign(r.style, a), Object.keys(s).forEach(function (u) { r.removeAttribute(u); })); }); }; }
var q1 = { name: "applyStyles", enabled: !0, phase: "write", fn: _8, effect: k8, requires: ["computeStyles"] };
function Qo(e) { return e.split("-")[0]; }
var Ls = Math.max, Wu = Math.min, Rl = Math.round;
function Ll(e, t) { t === void 0 && (t = !1); var n = e.getBoundingClientRect(), o = 1, r = 1; if (_o(e) && t) {
    var s = e.offsetHeight, l = e.offsetWidth;
    l > 0 && (o = Rl(n.width) / l || 1), s > 0 && (r = Rl(n.height) / s || 1);
} return { width: n.width / o, height: n.height / r, top: n.top / r, right: n.right / o, bottom: n.bottom / r, left: n.left / o, x: n.left / o, y: n.top / r }; }
function vh(e) { var t = Ll(e), n = e.offsetWidth, o = e.offsetHeight; return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - o) <= 1 && (o = t.height), { x: e.offsetLeft, y: e.offsetTop, width: n, height: o }; }
function Y1(e, t) { var n = t.getRootNode && t.getRootNode(); if (e.contains(t))
    return !0; if (n && hh(n)) {
    var o = t;
    do {
        if (o && e.isSameNode(o))
            return !0;
        o = o.parentNode || o.host;
    } while (o);
} return !1; }
function _r(e) { return Uo(e).getComputedStyle(e); }
function E8(e) { return ["table", "td", "th"].indexOf(nr(e)) >= 0; }
function is(e) { return ((Pl(e) ? e.ownerDocument : e.document) || window.document).documentElement; }
function Lc(e) { return nr(e) === "html" ? e : e.assignedSlot || e.parentNode || (hh(e) ? e.host : null) || is(e); }
function Tg(e) { return !_o(e) || _r(e).position === "fixed" ? null : e.offsetParent; }
function $8(e) { var t = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1; if (n && _o(e)) {
    var o = _r(e);
    if (o.position === "fixed")
        return null;
} var r = Lc(e); for (hh(r) && (r = r.host); _o(r) && ["html", "body"].indexOf(nr(r)) < 0;) {
    var s = _r(r);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || t && s.willChange === "filter" || t && s.filter && s.filter !== "none")
        return r;
    r = r.parentNode;
} return null; }
function Ei(e) { for (var t = Uo(e), n = Tg(e); n && E8(n) && _r(n).position === "static";)
    n = Tg(n); return n && (nr(n) === "html" || nr(n) === "body" && _r(n).position === "static") ? t : n || $8(e) || t; }
function mh(e) { return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"; }
function Ea(e, t, n) { return Ls(e, Wu(t, n)); }
function T8(e, t, n) { var o = Ea(e, t, n); return o > n ? n : o; }
function G1() { return { top: 0, right: 0, bottom: 0, left: 0 }; }
function X1(e) { return Object.assign({}, G1(), e); }
function J1(e, t) { return t.reduce(function (n, o) { return n[o] = e, n; }, {}); }
var O8 = function (e, t) { return e = typeof e == "function" ? e(Object.assign({}, t.rects, { placement: t.placement })) : e, X1(typeof e != "number" ? e : J1(e, ki)); };
function I8(e) { var t, n = e.state, o = e.name, r = e.options, s = n.elements.arrow, l = n.modifiersData.popperOffsets, a = Qo(n.placement), u = mh(a), c = [ao, Io].indexOf(a) >= 0, d = c ? "height" : "width"; if (!(!s || !l)) {
    var f = O8(r.padding, n), p = vh(s), v = u === "y" ? lo : ao, m = u === "y" ? Oo : Io, h = n.rects.reference[d] + n.rects.reference[u] - l[u] - n.rects.popper[d], g = l[u] - n.rects.reference[u], y = Ei(s), C = y ? u === "y" ? y.clientHeight || 0 : y.clientWidth || 0 : 0, b = h / 2 - g / 2, w = f[v], T = C - p[d] - f[m], E = C / 2 - p[d] / 2 + b, x = Ea(w, E, T), I = u;
    n.modifiersData[o] = (t = {}, t[I] = x, t.centerOffset = x - E, t);
} }
function x8(e) { var t = e.state, n = e.options, o = n.element, r = o === void 0 ? "[data-popper-arrow]" : o; r != null && (typeof r == "string" && (r = t.elements.popper.querySelector(r), !r) || !Y1(t.elements.popper, r) || (t.elements.arrow = r)); }
var A8 = { name: "arrow", enabled: !0, phase: "main", fn: I8, effect: x8, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
function Dl(e) { return e.split("-")[1]; }
var M8 = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function N8(e) { var t = e.x, n = e.y, o = window, r = o.devicePixelRatio || 1; return { x: Rl(t * r) / r || 0, y: Rl(n * r) / r || 0 }; }
function Og(e) { var t, n = e.popper, o = e.popperRect, r = e.placement, s = e.variation, l = e.offsets, a = e.position, u = e.gpuAcceleration, c = e.adaptive, d = e.roundOffsets, f = e.isFixed, p = l.x, v = p === void 0 ? 0 : p, m = l.y, h = m === void 0 ? 0 : m, g = typeof d == "function" ? d({ x: v, y: h }) : { x: v, y: h }; v = g.x, h = g.y; var y = l.hasOwnProperty("x"), C = l.hasOwnProperty("y"), b = ao, w = lo, T = window; if (c) {
    var E = Ei(n), x = "clientHeight", I = "clientWidth";
    if (E === Uo(n) && (E = is(n), _r(E).position !== "static" && a === "absolute" && (x = "scrollHeight", I = "scrollWidth")), E = E, r === lo || (r === ao || r === Io) && s === Za) {
        w = Oo;
        var L = f && E === T && T.visualViewport ? T.visualViewport.height : E[x];
        h -= L - o.height, h *= u ? 1 : -1;
    }
    if (r === ao || (r === lo || r === Oo) && s === Za) {
        b = Io;
        var B = f && E === T && T.visualViewport ? T.visualViewport.width : E[I];
        v -= B - o.width, v *= u ? 1 : -1;
    }
} var F = Object.assign({ position: a }, c && M8), V = d === !0 ? N8({ x: v, y: h }) : { x: v, y: h }; if (v = V.x, h = V.y, u) {
    var R;
    return Object.assign({}, F, (R = {}, R[w] = C ? "0" : "", R[b] = y ? "0" : "", R.transform = (T.devicePixelRatio || 1) <= 1 ? "translate(" + v + "px, " + h + "px)" : "translate3d(" + v + "px, " + h + "px, 0)", R));
} return Object.assign({}, F, (t = {}, t[w] = C ? h + "px" : "", t[b] = y ? v + "px" : "", t.transform = "", t)); }
function P8(e) { var t = e.state, n = e.options, o = n.gpuAcceleration, r = o === void 0 ? !0 : o, s = n.adaptive, l = s === void 0 ? !0 : s, a = n.roundOffsets, u = a === void 0 ? !0 : a, c = { placement: Qo(t.placement), variation: Dl(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: r, isFixed: t.options.strategy === "fixed" }; t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Og(Object.assign({}, c, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: l, roundOffsets: u })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Og(Object.assign({}, c, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: u })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement }); }
var Z1 = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: P8, data: {} }, Ki = { passive: !0 };
function R8(e) { var t = e.state, n = e.instance, o = e.options, r = o.scroll, s = r === void 0 ? !0 : r, l = o.resize, a = l === void 0 ? !0 : l, u = Uo(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper); return s && c.forEach(function (d) { d.addEventListener("scroll", n.update, Ki); }), a && u.addEventListener("resize", n.update, Ki), function () { s && c.forEach(function (d) { d.removeEventListener("scroll", n.update, Ki); }), a && u.removeEventListener("resize", n.update, Ki); }; }
var Q1 = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: R8, data: {} }, L8 = { left: "right", right: "left", bottom: "top", top: "bottom" };
function du(e) { return e.replace(/left|right|bottom|top/g, function (t) { return L8[t]; }); }
var D8 = { start: "end", end: "start" };
function Ig(e) { return e.replace(/start|end/g, function (t) { return D8[t]; }); }
function gh(e) { var t = Uo(e), n = t.pageXOffset, o = t.pageYOffset; return { scrollLeft: n, scrollTop: o }; }
function yh(e) { return Ll(is(e)).left + gh(e).scrollLeft; }
function B8(e) { var t = Uo(e), n = is(e), o = t.visualViewport, r = n.clientWidth, s = n.clientHeight, l = 0, a = 0; return o && (r = o.width, s = o.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (l = o.offsetLeft, a = o.offsetTop)), { width: r, height: s, x: l + yh(e), y: a }; }
function F8(e) { var t, n = is(e), o = gh(e), r = (t = e.ownerDocument) == null ? void 0 : t.body, s = Ls(n.scrollWidth, n.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0), l = Ls(n.scrollHeight, n.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0), a = -o.scrollLeft + yh(e), u = -o.scrollTop; return _r(r || n).direction === "rtl" && (a += Ls(n.clientWidth, r ? r.clientWidth : 0) - s), { width: s, height: l, x: a, y: u }; }
function bh(e) { var t = _r(e), n = t.overflow, o = t.overflowX, r = t.overflowY; return /auto|scroll|overlay|hidden/.test(n + r + o); }
function ew(e) { return ["html", "body", "#document"].indexOf(nr(e)) >= 0 ? e.ownerDocument.body : _o(e) && bh(e) ? e : ew(Lc(e)); }
function $a(e, t) { var n; t === void 0 && (t = []); var o = ew(e), r = o === ((n = e.ownerDocument) == null ? void 0 : n.body), s = Uo(o), l = r ? [s].concat(s.visualViewport || [], bh(o) ? o : []) : o, a = t.concat(l); return r ? a : a.concat($a(Lc(l))); }
function vf(e) { return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }); }
function V8(e) { var t = Ll(e); return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t; }
function xg(e, t) { return t === U1 ? vf(B8(e)) : Pl(t) ? V8(t) : vf(F8(is(e))); }
function z8(e) { var t = $a(Lc(e)), n = ["absolute", "fixed"].indexOf(_r(e).position) >= 0, o = n && _o(e) ? Ei(e) : e; return Pl(o) ? t.filter(function (r) { return Pl(r) && Y1(r, o) && nr(r) !== "body"; }) : []; }
function H8(e, t, n) { var o = t === "clippingParents" ? z8(e) : [].concat(t), r = [].concat(o, [n]), s = r[0], l = r.reduce(function (a, u) { var c = xg(e, u); return a.top = Ls(c.top, a.top), a.right = Wu(c.right, a.right), a.bottom = Wu(c.bottom, a.bottom), a.left = Ls(c.left, a.left), a; }, xg(e, s)); return l.width = l.right - l.left, l.height = l.bottom - l.top, l.x = l.left, l.y = l.top, l; }
function tw(e) { var t = e.reference, n = e.element, o = e.placement, r = o ? Qo(o) : null, s = o ? Dl(o) : null, l = t.x + t.width / 2 - n.width / 2, a = t.y + t.height / 2 - n.height / 2, u; switch (r) {
    case lo:
        u = { x: l, y: t.y - n.height };
        break;
    case Oo:
        u = { x: l, y: t.y + t.height };
        break;
    case Io:
        u = { x: t.x + t.width, y: a };
        break;
    case ao:
        u = { x: t.x - n.width, y: a };
        break;
    default: u = { x: t.x, y: t.y };
} var c = r ? mh(r) : null; if (c != null) {
    var d = c === "y" ? "height" : "width";
    switch (s) {
        case Nl:
            u[c] = u[c] - (t[d] / 2 - n[d] / 2);
            break;
        case Za:
            u[c] = u[c] + (t[d] / 2 - n[d] / 2);
            break;
    }
} return u; }
function Qa(e, t) { t === void 0 && (t = {}); var n = t, o = n.placement, r = o === void 0 ? e.placement : o, s = n.boundary, l = s === void 0 ? d8 : s, a = n.rootBoundary, u = a === void 0 ? U1 : a, c = n.elementContext, d = c === void 0 ? ia : c, f = n.altBoundary, p = f === void 0 ? !1 : f, v = n.padding, m = v === void 0 ? 0 : v, h = X1(typeof m != "number" ? m : J1(m, ki)), g = d === ia ? f8 : ia, y = e.rects.popper, C = e.elements[p ? g : d], b = H8(Pl(C) ? C : C.contextElement || is(e.elements.popper), l, u), w = Ll(e.elements.reference), T = tw({ reference: w, element: y, strategy: "absolute", placement: r }), E = vf(Object.assign({}, y, T)), x = d === ia ? E : w, I = { top: b.top - x.top + h.top, bottom: x.bottom - b.bottom + h.bottom, left: b.left - x.left + h.left, right: x.right - b.right + h.right }, L = e.modifiersData.offset; if (d === ia && L) {
    var B = L[r];
    Object.keys(I).forEach(function (F) { var V = [Io, Oo].indexOf(F) >= 0 ? 1 : -1, R = [lo, Oo].indexOf(F) >= 0 ? "y" : "x"; I[F] += B[R] * V; });
} return I; }
function K8(e, t) { t === void 0 && (t = {}); var n = t, o = n.placement, r = n.boundary, s = n.rootBoundary, l = n.padding, a = n.flipVariations, u = n.allowedAutoPlacements, c = u === void 0 ? Ys : u, d = Dl(o), f = d ? a ? $g : $g.filter(function (m) { return Dl(m) === d; }) : ki, p = f.filter(function (m) { return c.indexOf(m) >= 0; }); p.length === 0 && (p = f); var v = p.reduce(function (m, h) { return m[h] = Qa(e, { placement: h, boundary: r, rootBoundary: s, padding: l })[Qo(h)], m; }, {}); return Object.keys(v).sort(function (m, h) { return v[m] - v[h]; }); }
function j8(e) { if (Qo(e) === ph)
    return []; var t = du(e); return [Ig(e), t, Ig(t)]; }
function W8(e) { var t = e.state, n = e.options, o = e.name; if (!t.modifiersData[o]._skip) {
    for (var r = n.mainAxis, s = r === void 0 ? !0 : r, l = n.altAxis, a = l === void 0 ? !0 : l, u = n.fallbackPlacements, c = n.padding, d = n.boundary, f = n.rootBoundary, p = n.altBoundary, v = n.flipVariations, m = v === void 0 ? !0 : v, h = n.allowedAutoPlacements, g = t.options.placement, y = Qo(g), C = y === g, b = u || (C || !m ? [du(g)] : j8(g)), w = [g].concat(b).reduce(function (ye, Re) { return ye.concat(Qo(Re) === ph ? K8(t, { placement: Re, boundary: d, rootBoundary: f, padding: c, flipVariations: m, allowedAutoPlacements: h }) : Re); }, []), T = t.rects.reference, E = t.rects.popper, x = new Map, I = !0, L = w[0], B = 0; B < w.length; B++) {
        var F = w[B], V = Qo(F), R = Dl(F) === Nl, K = [lo, Oo].indexOf(V) >= 0, te = K ? "width" : "height", U = Qa(t, { placement: F, boundary: d, rootBoundary: f, altBoundary: p, padding: c }), D = K ? R ? Io : ao : R ? Oo : lo;
        T[te] > E[te] && (D = du(D));
        var j = du(D), A = [];
        if (s && A.push(U[V] <= 0), a && A.push(U[D] <= 0, U[j] <= 0), A.every(function (ye) { return ye; })) {
            L = F, I = !1;
            break;
        }
        x.set(F, A);
    }
    if (I)
        for (var G = m ? 3 : 1, se = function (ye) { var Re = w.find(function (me) { var le = x.get(me); if (le)
            return le.slice(0, ye).every(function (oe) { return oe; }); }); if (Re)
            return L = Re, "break"; }, Z = G; Z > 0; Z--) {
            var ce = se(Z);
            if (ce === "break")
                break;
        }
    t.placement !== L && (t.modifiersData[o]._skip = !0, t.placement = L, t.reset = !0);
} }
var U8 = { name: "flip", enabled: !0, phase: "main", fn: W8, requiresIfExists: ["offset"], data: { _skip: !1 } };
function Ag(e, t, n) { return n === void 0 && (n = { x: 0, y: 0 }), { top: e.top - t.height - n.y, right: e.right - t.width + n.x, bottom: e.bottom - t.height + n.y, left: e.left - t.width - n.x }; }
function Mg(e) { return [lo, Io, Oo, ao].some(function (t) { return e[t] >= 0; }); }
function q8(e) { var t = e.state, n = e.name, o = t.rects.reference, r = t.rects.popper, s = t.modifiersData.preventOverflow, l = Qa(t, { elementContext: "reference" }), a = Qa(t, { altBoundary: !0 }), u = Ag(l, o), c = Ag(a, r, s), d = Mg(u), f = Mg(c); t.modifiersData[n] = { referenceClippingOffsets: u, popperEscapeOffsets: c, isReferenceHidden: d, hasPopperEscaped: f }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": d, "data-popper-escaped": f }); }
var Y8 = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: q8 };
function G8(e, t, n) { var o = Qo(e), r = [ao, lo].indexOf(o) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, t, { placement: e })) : n, l = s[0], a = s[1]; return l = l || 0, a = (a || 0) * r, [ao, Io].indexOf(o) >= 0 ? { x: a, y: l } : { x: l, y: a }; }
function X8(e) { var t = e.state, n = e.options, o = e.name, r = n.offset, s = r === void 0 ? [0, 0] : r, l = Ys.reduce(function (d, f) { return d[f] = G8(f, t.rects, s), d; }, {}), a = l[t.placement], u = a.x, c = a.y; t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += u, t.modifiersData.popperOffsets.y += c), t.modifiersData[o] = l; }
var J8 = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: X8 };
function Z8(e) { var t = e.state, n = e.name; t.modifiersData[n] = tw({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement }); }
var nw = { name: "popperOffsets", enabled: !0, phase: "read", fn: Z8, data: {} };
function Q8(e) { return e === "x" ? "y" : "x"; }
function e6(e) { var t = e.state, n = e.options, o = e.name, r = n.mainAxis, s = r === void 0 ? !0 : r, l = n.altAxis, a = l === void 0 ? !1 : l, u = n.boundary, c = n.rootBoundary, d = n.altBoundary, f = n.padding, p = n.tether, v = p === void 0 ? !0 : p, m = n.tetherOffset, h = m === void 0 ? 0 : m, g = Qa(t, { boundary: u, rootBoundary: c, padding: f, altBoundary: d }), y = Qo(t.placement), C = Dl(t.placement), b = !C, w = mh(y), T = Q8(w), E = t.modifiersData.popperOffsets, x = t.rects.reference, I = t.rects.popper, L = typeof h == "function" ? h(Object.assign({}, t.rects, { placement: t.placement })) : h, B = typeof L == "number" ? { mainAxis: L, altAxis: L } : Object.assign({ mainAxis: 0, altAxis: 0 }, L), F = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, V = { x: 0, y: 0 }; if (E) {
    if (s) {
        var R, K = w === "y" ? lo : ao, te = w === "y" ? Oo : Io, U = w === "y" ? "height" : "width", D = E[w], j = D + g[K], A = D - g[te], G = v ? -I[U] / 2 : 0, se = C === Nl ? x[U] : I[U], Z = C === Nl ? -I[U] : -x[U], ce = t.elements.arrow, ye = v && ce ? vh(ce) : { width: 0, height: 0 }, Re = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : G1(), me = Re[K], le = Re[te], oe = Ea(0, x[U], ye[U]), fe = b ? x[U] / 2 - G - oe - me - B.mainAxis : se - oe - me - B.mainAxis, Ce = b ? -x[U] / 2 + G + oe + le + B.mainAxis : Z + oe + le + B.mainAxis, Ae = t.elements.arrow && Ei(t.elements.arrow), q = Ae ? w === "y" ? Ae.clientTop || 0 : Ae.clientLeft || 0 : 0, re = (R = F == null ? void 0 : F[w]) != null ? R : 0, he = D + fe - re - q, Ee = D + Ce - re, Ne = Ea(v ? Wu(j, he) : j, D, v ? Ls(A, Ee) : A);
        E[w] = Ne, V[w] = Ne - D;
    }
    if (a) {
        var Se, De = w === "x" ? lo : ao, Me = w === "x" ? Oo : Io, $e = E[T], Pe = T === "y" ? "height" : "width", He = $e + g[De], je = $e - g[Me], Ue = [lo, ao].indexOf(y) !== -1, Te = (Se = F == null ? void 0 : F[T]) != null ? Se : 0, Ge = Ue ? He : $e - x[Pe] - I[Pe] - Te + B.altAxis, W = Ue ? $e + x[Pe] + I[Pe] - Te - B.altAxis : je, X = v && Ue ? T8(Ge, $e, W) : Ea(v ? Ge : He, $e, v ? W : je);
        E[T] = X, V[T] = X - $e;
    }
    t.modifiersData[o] = V;
} }
var t6 = { name: "preventOverflow", enabled: !0, phase: "main", fn: e6, requiresIfExists: ["offset"] };
function n6(e) { return { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop }; }
function o6(e) { return e === Uo(e) || !_o(e) ? gh(e) : n6(e); }
function r6(e) { var t = e.getBoundingClientRect(), n = Rl(t.width) / e.offsetWidth || 1, o = Rl(t.height) / e.offsetHeight || 1; return n !== 1 || o !== 1; }
function s6(e, t, n) { n === void 0 && (n = !1); var o = _o(t), r = _o(t) && r6(t), s = is(t), l = Ll(e, r), a = { scrollLeft: 0, scrollTop: 0 }, u = { x: 0, y: 0 }; return (o || !o && !n) && ((nr(t) !== "body" || bh(s)) && (a = o6(t)), _o(t) ? (u = Ll(t, !0), u.x += t.clientLeft, u.y += t.clientTop) : s && (u.x = yh(s))), { x: l.left + a.scrollLeft - u.x, y: l.top + a.scrollTop - u.y, width: l.width, height: l.height }; }
function l6(e) { var t = new Map, n = new Set, o = []; e.forEach(function (s) { t.set(s.name, s); }); function r(s) { n.add(s.name); var l = [].concat(s.requires || [], s.requiresIfExists || []); l.forEach(function (a) { if (!n.has(a)) {
    var u = t.get(a);
    u && r(u);
} }), o.push(s); } return e.forEach(function (s) { n.has(s.name) || r(s); }), o; }
function a6(e) { var t = l6(e); return S8.reduce(function (n, o) { return n.concat(t.filter(function (r) { return r.phase === o; })); }, []); }
function i6(e) { var t; return function () { return t || (t = new Promise(function (n) { Promise.resolve().then(function () { t = void 0, n(e()); }); })), t; }; }
function u6(e) { var t = e.reduce(function (n, o) { var r = n[o.name]; return n[o.name] = r ? Object.assign({}, r, o, { options: Object.assign({}, r.options, o.options), data: Object.assign({}, r.data, o.data) }) : o, n; }, {}); return Object.keys(t).map(function (n) { return t[n]; }); }
var Ng = { placement: "bottom", modifiers: [], strategy: "absolute" };
function Pg() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n]; return !t.some(function (o) { return !(o && typeof o.getBoundingClientRect == "function"); }); }
function wh(e) { e === void 0 && (e = {}); var t = e, n = t.defaultModifiers, o = n === void 0 ? [] : n, r = t.defaultOptions, s = r === void 0 ? Ng : r; return function (l, a, u) { u === void 0 && (u = s); var c = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ng, s), modifiersData: {}, elements: { reference: l, popper: a }, attributes: {}, styles: {} }, d = [], f = !1, p = { state: c, setOptions: function (h) { var g = typeof h == "function" ? h(c.options) : h; m(), c.options = Object.assign({}, s, c.options, g), c.scrollParents = { reference: Pl(l) ? $a(l) : l.contextElement ? $a(l.contextElement) : [], popper: $a(a) }; var y = a6(u6([].concat(o, c.options.modifiers))); return c.orderedModifiers = y.filter(function (C) { return C.enabled; }), v(), p.update(); }, forceUpdate: function () { if (!f) {
        var h = c.elements, g = h.reference, y = h.popper;
        if (Pg(g, y)) {
            c.rects = { reference: s6(g, Ei(y), c.options.strategy === "fixed"), popper: vh(y) }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function (I) { return c.modifiersData[I.name] = Object.assign({}, I.data); });
            for (var C = 0; C < c.orderedModifiers.length; C++) {
                if (c.reset === !0) {
                    c.reset = !1, C = -1;
                    continue;
                }
                var b = c.orderedModifiers[C], w = b.fn, T = b.options, E = T === void 0 ? {} : T, x = b.name;
                typeof w == "function" && (c = w({ state: c, options: E, name: x, instance: p }) || c);
            }
        }
    } }, update: i6(function () { return new Promise(function (h) { p.forceUpdate(), h(c); }); }), destroy: function () { m(), f = !0; } }; if (!Pg(l, a))
    return p; p.setOptions(u).then(function (h) { !f && u.onFirstUpdate && u.onFirstUpdate(h); }); function v() { c.orderedModifiers.forEach(function (h) { var g = h.name, y = h.options, C = y === void 0 ? {} : y, b = h.effect; if (typeof b == "function") {
    var w = b({ state: c, name: g, instance: p, options: C }), T = function () { };
    d.push(w || T);
} }); } function m() { d.forEach(function (h) { return h(); }), d = []; } return p; }; }
wh();
var c6 = [Q1, nw, Z1, q1];
wh({ defaultModifiers: c6 });
var d6 = [Q1, nw, Z1, q1, J8, U8, t6, A8, Y8], ow = wh({ defaultModifiers: d6 });
const f6 = (e, t, n = {}) => { const o = { name: "updateState", enabled: !0, phase: "write", fn: ({ state: u }) => { const c = p6(u); Object.assign(l.value, c); }, requires: ["computeStyles"] }, r = S(() => { const { onFirstUpdate: u, placement: c, strategy: d, modifiers: f } = i(n); return { onFirstUpdate: u, placement: c || "bottom", strategy: d || "absolute", modifiers: [...f || [], o, { name: "applyStyles", enabled: !1 }] }; }), s = Xt(), l = M({ styles: { popper: { position: i(r).strategy, left: "0", top: "0" }, arrow: { position: "absolute" } }, attributes: {} }), a = () => { s.value && (s.value.destroy(), s.value = void 0); }; return Oe(r, u => { const c = i(s); c && c.setOptions(u); }, { deep: !0 }), Oe([e, t], ([u, c]) => { a(), !(!u || !c) && (s.value = ow(u, c, i(r))); }), on(() => { a(); }), { state: S(() => { var u; return { ...((u = i(s)) == null ? void 0 : u.state) || {} }; }), styles: S(() => i(l).styles), attributes: S(() => i(l).attributes), update: () => { var u; return (u = i(s)) == null ? void 0 : u.update(); }, forceUpdate: () => { var u; return (u = i(s)) == null ? void 0 : u.forceUpdate(); }, instanceRef: S(() => i(s)) }; };
function p6(e) { const t = Object.keys(e.elements), n = Ku(t.map(r => [r, e.styles[r] || {}])), o = Ku(t.map(r => [r, e.attributes[r]])); return { styles: n, attributes: o }; }
const Ch = e => { if (!e)
    return { onClick: Wt, onMousedown: Wt, onMouseup: Wt }; let t = !1, n = !1; return { onClick: l => { t && n && e(l), t = n = !1; }, onMousedown: l => { t = l.target === l.currentTarget; }, onMouseup: l => { n = l.target === l.currentTarget; } }; }, h6 = (e, t = 0) => { if (t === 0)
    return e; const n = M(!1); let o = 0; const r = () => { o && clearTimeout(o), o = window.setTimeout(() => { n.value = e.value; }, t); }; return ft(r), Oe(() => e.value, s => { s ? r() : n.value = s; }), n; };
function Rg() { let e; const t = (o, r) => { n(), e = window.setTimeout(o, r); }, n = () => window.clearTimeout(e); return Cc(() => n()), { registerTimeout: t, cancelTimeout: n }; }
const Lg = { prefix: Math.floor(Math.random() * 1e4), current: 0 }, v6 = Symbol("elIdInjection"), rw = () => ht() ? Ye(v6, Lg) : Lg, xo = e => { const t = rw(), n = fh(); return S(() => i(e) || `${n.value}-id-${t.prefix}-${t.current++}`); };
let ol = [];
const Dg = e => { const t = e; t.key === tt.esc && ol.forEach(n => n(t)); }, m6 = e => { ft(() => { ol.length === 0 && document.addEventListener("keydown", Dg), At && ol.push(e); }), on(() => { ol = ol.filter(t => t !== e), ol.length === 0 && At && document.removeEventListener("keydown", Dg); }); };
let Bg;
const sw = () => { const e = fh(), t = rw(), n = S(() => `${e.value}-popper-container-${t.prefix}`), o = S(() => `#${n.value}`); return { id: n, selector: o }; }, g6 = e => { const t = document.createElement("div"); return t.id = e, document.body.appendChild(t), t; }, y6 = () => { const { id: e, selector: t } = sw(); return mc(() => { At && !Bg && !document.body.querySelector(t.value) && (Bg = g6(e.value)); }), { id: e, selector: t }; }, b6 = Ve({ showAfter: { type: Number, default: 0 }, hideAfter: { type: Number, default: 200 }, autoClose: { type: Number, default: 0 } }), lw = ({ showAfter: e, hideAfter: t, autoClose: n, open: o, close: r }) => { const { registerTimeout: s } = Rg(), { registerTimeout: l, cancelTimeout: a } = Rg(); return { onOpen: d => { s(() => { o(d); const f = i(n); lt(f) && f > 0 && l(() => { r(d); }, f); }, i(e)); }, onClose: d => { a(), s(() => { r(d); }, i(t)); } }; }, aw = Symbol("elForwardRef"), w6 = e => { St(aw, { setForwardRef: n => { e.value = n; } }); }, C6 = e => ({ mounted(t) { e(t); }, updated(t) { e(t); }, unmounted() { e(null); } }), Fg = M(0), iw = 2e3, uw = Symbol("zIndexContextKey"), Gl = e => { const t = e || Ye(uw, void 0), n = S(() => { const s = i(t); return lt(s) ? s : iw; }), o = S(() => n.value + Fg.value); return { initialZIndex: n, currentZIndex: o, nextZIndex: () => (Fg.value++, o.value) }; };
function Sh(e) { return e.split("-")[1]; }
function cw(e) { return e === "y" ? "height" : "width"; }
function _h(e) { return e.split("-")[0]; }
function kh(e) { return ["top", "bottom"].includes(_h(e)) ? "x" : "y"; }
function Vg(e, t, n) { let { reference: o, floating: r } = e; const s = o.x + o.width / 2 - r.width / 2, l = o.y + o.height / 2 - r.height / 2, a = kh(t), u = cw(a), c = o[u] / 2 - r[u] / 2, d = a === "x"; let f; switch (_h(t)) {
    case "top":
        f = { x: s, y: o.y - r.height };
        break;
    case "bottom":
        f = { x: s, y: o.y + o.height };
        break;
    case "right":
        f = { x: o.x + o.width, y: l };
        break;
    case "left":
        f = { x: o.x - r.width, y: l };
        break;
    default: f = { x: o.x, y: o.y };
} switch (Sh(t)) {
    case "start":
        f[a] -= c * (n && d ? -1 : 1);
        break;
    case "end": f[a] += c * (n && d ? -1 : 1);
} return f; }
const S6 = async (e, t, n) => { const { placement: o = "bottom", strategy: r = "absolute", middleware: s = [], platform: l } = n, a = s.filter(Boolean), u = await (l.isRTL == null ? void 0 : l.isRTL(t)); let c = await l.getElementRects({ reference: e, floating: t, strategy: r }), { x: d, y: f } = Vg(c, o, u), p = o, v = {}, m = 0; for (let h = 0; h < a.length; h++) {
    const { name: g, fn: y } = a[h], { x: C, y: b, data: w, reset: T } = await y({ x: d, y: f, initialPlacement: o, placement: p, strategy: r, middlewareData: v, rects: c, platform: l, elements: { reference: e, floating: t } });
    d = C ?? d, f = b ?? f, v = { ...v, [g]: { ...v[g], ...w } }, T && m <= 50 && (m++, typeof T == "object" && (T.placement && (p = T.placement), T.rects && (c = T.rects === !0 ? await l.getElementRects({ reference: e, floating: t, strategy: r }) : T.rects), { x: d, y: f } = Vg(c, p, u)), h = -1);
} return { x: d, y: f, placement: p, strategy: r, middlewareData: v }; };
function dw(e, t) { return typeof e == "function" ? e(t) : e; }
function _6(e) { return typeof e != "number" ? function (t) { return { top: 0, right: 0, bottom: 0, left: 0, ...t }; }(e) : { top: e, right: e, bottom: e, left: e }; }
function fw(e) { return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height }; }
const mf = Math.min, k6 = Math.max;
function E6(e, t, n) { return k6(e, mf(t, n)); }
const $6 = e => ({ name: "arrow", options: e, async fn(t) { const { x: n, y: o, placement: r, rects: s, platform: l, elements: a } = t, { element: u, padding: c = 0 } = dw(e, t) || {}; if (u == null)
        return {}; const d = _6(c), f = { x: n, y: o }, p = kh(r), v = cw(p), m = await l.getDimensions(u), h = p === "y", g = h ? "top" : "left", y = h ? "bottom" : "right", C = h ? "clientHeight" : "clientWidth", b = s.reference[v] + s.reference[p] - f[p] - s.floating[v], w = f[p] - s.reference[p], T = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(u)); let E = T ? T[C] : 0; E && await (l.isElement == null ? void 0 : l.isElement(T)) || (E = a.floating[C] || s.floating[v]); const x = b / 2 - w / 2, I = E / 2 - m[v] / 2 - 1, L = mf(d[g], I), B = mf(d[y], I), F = L, V = E - m[v] - B, R = E / 2 - m[v] / 2 + x, K = E6(F, R, V), te = Sh(r) != null && R != K && s.reference[v] / 2 - (R < F ? L : B) - m[v] / 2 < 0 ? R < F ? F - R : V - R : 0; return { [p]: f[p] - te, data: { [p]: K, centerOffset: R - K + te } }; } }), T6 = ["top", "right", "bottom", "left"];
T6.reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
const O6 = function (e) { return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) { const { x: n, y: o } = t, r = await async function (s, l) { const { placement: a, platform: u, elements: c } = s, d = await (u.isRTL == null ? void 0 : u.isRTL(c.floating)), f = _h(a), p = Sh(a), v = kh(a) === "x", m = ["left", "top"].includes(f) ? -1 : 1, h = d && v ? -1 : 1, g = dw(l, s); let { mainAxis: y, crossAxis: C, alignmentAxis: b } = typeof g == "number" ? { mainAxis: g, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...g }; return p && typeof b == "number" && (C = p === "end" ? -1 * b : b), v ? { x: C * h, y: y * m } : { x: y * m, y: C * h }; }(t, e); return { x: n + r.x, y: o + r.y, data: r }; } }; };
function ho(e) { var t; return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window; }
function or(e) { return ho(e).getComputedStyle(e); }
function pw(e) { return e instanceof ho(e).Node; }
function es(e) { return pw(e) ? (e.nodeName || "").toLowerCase() : "#document"; }
function Ko(e) { return e instanceof HTMLElement || e instanceof ho(e).HTMLElement; }
function zg(e) { return typeof ShadowRoot < "u" && (e instanceof ho(e).ShadowRoot || e instanceof ShadowRoot); }
function ei(e) { const { overflow: t, overflowX: n, overflowY: o, display: r } = or(e); return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !["inline", "contents"].includes(r); }
function I6(e) { return ["table", "td", "th"].includes(es(e)); }
function gf(e) { const t = Eh(), n = or(e); return n.transform !== "none" || n.perspective !== "none" || !!n.containerType && n.containerType !== "normal" || !t && !!n.backdropFilter && n.backdropFilter !== "none" || !t && !!n.filter && n.filter !== "none" || ["transform", "perspective", "filter"].some(o => (n.willChange || "").includes(o)) || ["paint", "layout", "strict", "content"].some(o => (n.contain || "").includes(o)); }
function Eh() { return !(typeof CSS > "u" || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none"); }
function Dc(e) { return ["html", "body", "#document"].includes(es(e)); }
const Hg = Math.min, Ta = Math.max, Uu = Math.round, ts = e => ({ x: e, y: e });
function hw(e) { const t = or(e); let n = parseFloat(t.width) || 0, o = parseFloat(t.height) || 0; const r = Ko(e), s = r ? e.offsetWidth : n, l = r ? e.offsetHeight : o, a = Uu(n) !== s || Uu(o) !== l; return a && (n = s, o = l), { width: n, height: o, $: a }; }
function br(e) { return e instanceof Element || e instanceof ho(e).Element; }
function vw(e) { return br(e) ? e : e.contextElement; }
function gl(e) { const t = vw(e); if (!Ko(t))
    return ts(1); const n = t.getBoundingClientRect(), { width: o, height: r, $: s } = hw(t); let l = (s ? Uu(n.width) : n.width) / o, a = (s ? Uu(n.height) : n.height) / r; return l && Number.isFinite(l) || (l = 1), a && Number.isFinite(a) || (a = 1), { x: l, y: a }; }
const x6 = ts(0);
function mw(e) { const t = ho(e); return Eh() && t.visualViewport ? { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop } : x6; }
function ti(e, t, n, o) { t === void 0 && (t = !1), n === void 0 && (n = !1); const r = e.getBoundingClientRect(), s = vw(e); let l = ts(1); t && (o ? br(o) && (l = gl(o)) : l = gl(e)); const a = function (p, v, m) { return v === void 0 && (v = !1), !(!m || v && m !== ho(p)) && v; }(s, n, o) ? mw(s) : ts(0); let u = (r.left + a.x) / l.x, c = (r.top + a.y) / l.y, d = r.width / l.x, f = r.height / l.y; if (s) {
    const p = ho(s), v = o && br(o) ? ho(o) : o;
    let m = p.frameElement;
    for (; m && o && v !== p;) {
        const h = gl(m), g = m.getBoundingClientRect(), y = getComputedStyle(m), C = g.left + (m.clientLeft + parseFloat(y.paddingLeft)) * h.x, b = g.top + (m.clientTop + parseFloat(y.paddingTop)) * h.y;
        u *= h.x, c *= h.y, d *= h.x, f *= h.y, u += C, c += b, m = ho(m).frameElement;
    }
} return fw({ width: d, height: f, x: u, y: c }); }
function Bc(e) { return br(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset }; }
function Yr(e) { var t; return (t = (pw(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement; }
function gw(e) { return ti(Yr(e)).left + Bc(e).scrollLeft; }
function Bl(e) { if (es(e) === "html")
    return e; const t = e.assignedSlot || e.parentNode || zg(e) && e.host || Yr(e); return zg(t) ? t.host : t; }
function yw(e) { const t = Bl(e); return Dc(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Ko(t) && ei(t) ? t : yw(t); }
function bw(e, t) { var n; t === void 0 && (t = []); const o = yw(e), r = o === ((n = e.ownerDocument) == null ? void 0 : n.body), s = ho(o); return r ? t.concat(s, s.visualViewport || [], ei(o) ? o : []) : t.concat(o, bw(o)); }
function Kg(e, t, n) { let o; if (t === "viewport")
    o = function (r, s) { const l = ho(r), a = Yr(r), u = l.visualViewport; let c = a.clientWidth, d = a.clientHeight, f = 0, p = 0; if (u) {
        c = u.width, d = u.height;
        const v = Eh();
        (!v || v && s === "fixed") && (f = u.offsetLeft, p = u.offsetTop);
    } return { width: c, height: d, x: f, y: p }; }(e, n);
else if (t === "document")
    o = function (r) { const s = Yr(r), l = Bc(r), a = r.ownerDocument.body, u = Ta(s.scrollWidth, s.clientWidth, a.scrollWidth, a.clientWidth), c = Ta(s.scrollHeight, s.clientHeight, a.scrollHeight, a.clientHeight); let d = -l.scrollLeft + gw(r); const f = -l.scrollTop; return or(a).direction === "rtl" && (d += Ta(s.clientWidth, a.clientWidth) - u), { width: u, height: c, x: d, y: f }; }(Yr(e));
else if (br(t))
    o = function (r, s) { const l = ti(r, !0, s === "fixed"), a = l.top + r.clientTop, u = l.left + r.clientLeft, c = Ko(r) ? gl(r) : ts(1); return { width: r.clientWidth * c.x, height: r.clientHeight * c.y, x: u * c.x, y: a * c.y }; }(t, n);
else {
    const r = mw(e);
    o = { ...t, x: t.x - r.x, y: t.y - r.y };
} return fw(o); }
function ww(e, t) { const n = Bl(e); return !(n === t || !br(n) || Dc(n)) && (or(n).position === "fixed" || ww(n, t)); }
function A6(e, t, n) { const o = Ko(t), r = Yr(t), s = n === "fixed", l = ti(e, !0, s, t); let a = { scrollLeft: 0, scrollTop: 0 }; const u = ts(0); if (o || !o && !s)
    if ((es(t) !== "body" || ei(r)) && (a = Bc(t)), Ko(t)) {
        const c = ti(t, !0, s, t);
        u.x = c.x + t.clientLeft, u.y = c.y + t.clientTop;
    }
    else
        r && (u.x = gw(r)); return { x: l.left + a.scrollLeft - u.x, y: l.top + a.scrollTop - u.y, width: l.width, height: l.height }; }
function jg(e, t) { return Ko(e) && or(e).position !== "fixed" ? t ? t(e) : e.offsetParent : null; }
function Wg(e, t) { const n = ho(e); if (!Ko(e))
    return n; let o = jg(e, t); for (; o && I6(o) && or(o).position === "static";)
    o = jg(o, t); return o && (es(o) === "html" || es(o) === "body" && or(o).position === "static" && !gf(o)) ? n : o || function (r) { let s = Bl(r); for (; Ko(s) && !Dc(s);) {
    if (gf(s))
        return s;
    s = Bl(s);
} return null; }(e) || n; }
const M6 = { convertOffsetParentRelativeRectToViewportRelativeRect: function (e) { let { rect: t, offsetParent: n, strategy: o } = e; const r = Ko(n), s = Yr(n); if (n === s)
        return t; let l = { scrollLeft: 0, scrollTop: 0 }, a = ts(1); const u = ts(0); if ((r || !r && o !== "fixed") && ((es(n) !== "body" || ei(s)) && (l = Bc(n)), Ko(n))) {
        const c = ti(n);
        a = gl(n), u.x = c.x + n.clientLeft, u.y = c.y + n.clientTop;
    } return { width: t.width * a.x, height: t.height * a.y, x: t.x * a.x - l.scrollLeft * a.x + u.x, y: t.y * a.y - l.scrollTop * a.y + u.y }; }, getDocumentElement: Yr, getClippingRect: function (e) { let { element: t, boundary: n, rootBoundary: o, strategy: r } = e; const s = [...n === "clippingAncestors" ? function (u, c) { const d = c.get(u); if (d)
            return d; let f = bw(u).filter(h => br(h) && es(h) !== "body"), p = null; const v = or(u).position === "fixed"; let m = v ? Bl(u) : u; for (; br(m) && !Dc(m);) {
            const h = or(m), g = gf(m);
            g || h.position !== "fixed" || (p = null), (v ? !g && !p : !g && h.position === "static" && p && ["absolute", "fixed"].includes(p.position) || ei(m) && !g && ww(u, m)) ? f = f.filter(y => y !== m) : p = h, m = Bl(m);
        } return c.set(u, f), f; }(t, this._c) : [].concat(n), o], l = s[0], a = s.reduce((u, c) => { const d = Kg(t, c, r); return u.top = Ta(d.top, u.top), u.right = Hg(d.right, u.right), u.bottom = Hg(d.bottom, u.bottom), u.left = Ta(d.left, u.left), u; }, Kg(t, l, r)); return { width: a.right - a.left, height: a.bottom - a.top, x: a.left, y: a.top }; }, getOffsetParent: Wg, getElementRects: async function (e) { let { reference: t, floating: n, strategy: o } = e; const r = this.getOffsetParent || Wg, s = this.getDimensions; return { reference: A6(t, await r(n), o), floating: { x: 0, y: 0, ...await s(n) } }; }, getClientRects: function (e) { return Array.from(e.getClientRects()); }, getDimensions: function (e) { return hw(e); }, getScale: gl, isElement: br, isRTL: function (e) { return getComputedStyle(e).direction === "rtl"; } }, N6 = (e, t, n) => { const o = new Map, r = { platform: M6, ...n }, s = { ...r.platform, _c: o }; return S6(e, t, { ...r, platform: s }); };
Ve({});
const P6 = e => { if (!At)
    return; if (!e)
    return e; const t = po(e); return t || (Jt(e) ? t : e); }, R6 = ({ middleware: e, placement: t, strategy: n }) => { const o = M(), r = M(), s = M(), l = M(), a = M({}), u = { x: s, y: l, placement: t, strategy: n, middlewareData: a }, c = async () => { if (!At)
    return; const d = P6(o), f = po(r); if (!d || !f)
    return; const p = await N6(d, f, { placement: i(t), strategy: i(n), middleware: i(e) }); Xa(u).forEach(v => { u[v].value = p[v]; }); }; return ft(() => { mo(() => { c(); }); }), { ...u, update: c, referenceRef: o, contentRef: r }; }, L6 = ({ arrowRef: e, padding: t }) => ({ name: "arrow", options: { element: e, padding: t }, fn(n) { const o = i(e); return o ? $6({ element: o, padding: t }).fn(n) : {}; } });
function D6(e) { const t = M(); function n() { if (e.value == null)
    return; const { selectionStart: r, selectionEnd: s, value: l } = e.value; if (r == null || s == null)
    return; const a = l.slice(0, Math.max(0, r)), u = l.slice(Math.max(0, s)); t.value = { selectionStart: r, selectionEnd: s, value: l, beforeTxt: a, afterTxt: u }; } function o() { if (e.value == null || t.value == null)
    return; const { value: r } = e.value, { beforeTxt: s, afterTxt: l, selectionStart: a } = t.value; if (s == null || l == null || a == null)
    return; let u = r.length; if (r.endsWith(l))
    u = r.length - l.length;
else if (r.startsWith(s))
    u = s.length;
else {
    const c = s[a - 1], d = r.indexOf(c, a - 1);
    d !== -1 && (u = d + 1);
} e.value.setSelectionRange(u, u); } return [n, o]; }
const B6 = (e, t, n) => ml(e.subTree).filter(s => { var l; return un(s) && ((l = s.type) == null ? void 0 : l.name) === t && !!s.component; }).map(s => s.component.uid).map(s => n[s]).filter(s => !!s), $h = (e, t) => { const n = {}, o = Xt([]); return { children: o, addChild: l => { n[l.uid] = l, o.value = B6(e, t, n); }, removeChild: l => { delete n[l], o.value = o.value.filter(a => a.uid !== l); } }; }, Bn = Wo({ type: String, values: sr, required: !1 }), Cw = Symbol("size"), F6 = () => { const e = Ye(Cw, {}); return S(() => i(e.size) || ""); };
function V6(e, { afterFocus: t, afterBlur: n } = {}) { const o = ht(), { emit: r } = o, s = Xt(), l = M(!1), a = d => { l.value || (l.value = !0, r("focus", d), t == null || t()); }, u = d => { var f; d.relatedTarget && ((f = s.value) != null && f.contains(d.relatedTarget)) || (l.value = !1, r("blur", d), n == null || n()); }, c = () => { var d; (d = e.value) == null || d.focus(); }; return Oe(s, d => { d && (d.setAttribute("role", "button"), d.setAttribute("tabindex", "-1")); }), nn(s, "click", c), { wrapperRef: s, isFocused: l, handleFocus: a, handleBlur: u }; }
const Sw = Symbol(), qu = M();
function Fc(e, t = void 0) { const n = ht() ? Ye(Sw, qu) : qu; return e ? S(() => { var o, r; return (r = (o = n.value) == null ? void 0 : o[e]) != null ? r : t; }) : n; }
function Vc(e, t) { const n = Fc(), o = Ie(e, S(() => { var a; return ((a = n.value) == null ? void 0 : a.namespace) || ju; })), r = Nt(S(() => { var a; return (a = n.value) == null ? void 0 : a.locale; })), s = Gl(S(() => { var a; return ((a = n.value) == null ? void 0 : a.zIndex) || iw; })), l = S(() => { var a; return i(t) || ((a = n.value) == null ? void 0 : a.size) || ""; }); return Th(S(() => i(n) || {})), { ns: o, locale: r, zIndex: s, size: l }; }
const Th = (e, t, n = !1) => { var o; const r = !!ht(), s = r ? Fc() : void 0, l = (o = t == null ? void 0 : t.provide) != null ? o : r ? St : void 0; if (!l)
    return; const a = S(() => { const u = i(e); return s != null && s.value ? z6(s.value, u) : u; }); return l(Sw, a), l(z1, S(() => a.value.locale)), l(H1, S(() => a.value.namespace)), l(uw, S(() => a.value.zIndex)), l(Cw, { size: S(() => a.value.size || "") }), (n || !qu.value) && (qu.value = a.value), a; }, z6 = (e, t) => { var n; const o = [...new Set([...Xa(e), ...Xa(t)])], r = {}; for (const s of o)
    r[s] = (n = t[s]) != null ? n : e[s]; return r; }, H6 = Ve({ a11y: { type: Boolean, default: !0 }, locale: { type: ve(Object) }, size: Bn, button: { type: ve(Object) }, experimentalFeatures: { type: ve(Object) }, keyboardNavigation: { type: Boolean, default: !0 }, message: { type: ve(Object) }, zIndex: Number, namespace: { type: String, default: "el" } }), yf = {}, K6 = ae({ name: "ElConfigProvider", props: H6, setup(e, { slots: t }) { Oe(() => e.message, o => { Object.assign(yf, o ?? {}); }, { immediate: !0, deep: !0 }); const n = Th(e); return () => ke(t, "default", { config: n == null ? void 0 : n.value }); } }), j6 = vt(K6), W6 = "2.3.8", U6 = (e = []) => ({ version: W6, install: (n, o) => { n[kg] || (n[kg] = !0, e.forEach(r => n.use(r)), o && Th(o, n, !0)); } }), q6 = Ve({ zIndex: { type: ve([Number, String]), default: 100 }, target: { type: String, default: "" }, offset: { type: Number, default: 0 }, position: { type: String, values: ["top", "bottom"], default: "top" } }), Y6 = { scroll: ({ scrollTop: e, fixed: t }) => lt(e) && wn(t), [en]: e => wn(e) };
var Fe = (e, t) => { const n = e.__vccOpts || e; for (const [o, r] of t)
    n[o] = r; return n; };
const _w = "ElAffix", G6 = ae({ name: _w }), X6 = ae({ ...G6, props: q6, emits: Y6, setup(e, { expose: t, emit: n }) { const o = e, r = Ie("affix"), s = Xt(), l = Xt(), a = Xt(), { height: u } = hT(), { height: c, width: d, top: f, bottom: p, update: v } = zm(l, { windowScroll: !1 }), m = zm(s), h = M(!1), g = M(0), y = M(0), C = S(() => ({ height: h.value ? `${c.value}px` : "", width: h.value ? `${d.value}px` : "" })), b = S(() => { if (!h.value)
        return {}; const E = o.offset ? gn(o.offset) : 0; return { height: `${c.value}px`, width: `${d.value}px`, top: o.position === "top" ? E : "", bottom: o.position === "bottom" ? E : "", transform: y.value ? `translateY(${y.value}px)` : "", zIndex: o.zIndex }; }), w = () => { if (a.value)
        if (g.value = a.value instanceof Window ? document.documentElement.scrollTop : a.value.scrollTop || 0, o.position === "top")
            if (o.target) {
                const E = m.bottom.value - o.offset - c.value;
                h.value = o.offset > f.value && m.bottom.value > 0, y.value = E < 0 ? E : 0;
            }
            else
                h.value = o.offset > f.value;
        else if (o.target) {
            const E = u.value - m.top.value - o.offset - c.value;
            h.value = u.value - o.offset < p.value && u.value > m.top.value, y.value = E < 0 ? -E : 0;
        }
        else
            h.value = u.value - o.offset < p.value; }, T = () => { v(), n("scroll", { scrollTop: g.value, fixed: h.value }); }; return Oe(h, E => n("change", E)), ft(() => { var E; o.target ? (s.value = (E = document.querySelector(o.target)) != null ? E : void 0, s.value || _n(_w, `Target is not existed: ${o.target}`)) : s.value = document.documentElement, a.value = lh(l.value, !0), v(); }), nn(a, "scroll", T), mo(w), t({ update: w, updateRoot: v }), (E, x) => (k(), z("div", { ref_key: "root", ref: l, class: O(i(r).b()), style: et(i(C)) }, [Q("div", { class: O({ [i(r).m("fixed")]: h.value }), style: et(i(b)) }, [ke(E.$slots, "default")], 6)], 6)); } });
var J6 = Fe(X6, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/affix/src/affix.vue"]]);
const Z6 = vt(J6), Q6 = Ve({ size: { type: ve([Number, String]) }, color: { type: String } }), eL = ae({ name: "ElIcon", inheritAttrs: !1 }), tL = ae({ ...eL, props: Q6, setup(e) { const t = e, n = Ie("icon"), o = S(() => { const { size: r, color: s } = t; return !r && !s ? {} : { fontSize: En(r) ? void 0 : gn(r), "--color": s }; }); return (r, s) => (k(), z("i", Ct({ class: i(n).b(), style: i(o) }, r.$attrs), [ke(r.$slots, "default")], 16)); } });
var nL = Fe(tL, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
const Je = vt(nL), oL = ["light", "dark"], rL = Ve({ title: { type: String, default: "" }, description: { type: String, default: "" }, type: { type: String, values: Xa(Qr), default: "info" }, closable: { type: Boolean, default: !0 }, closeText: { type: String, default: "" }, showIcon: Boolean, center: Boolean, effect: { type: String, values: oL, default: "light" } }), sL = { close: e => e instanceof MouseEvent }, lL = ae({ name: "ElAlert" }), aL = ae({ ...lL, props: rL, emits: sL, setup(e, { emit: t }) { const n = e, { Close: o } = ch, r = An(), s = Ie("alert"), l = M(!0), a = S(() => Qr[n.type]), u = S(() => [s.e("icon"), { [s.is("big")]: !!n.description || !!r.default }]), c = S(() => ({ [s.is("bold")]: n.description || r.default })), d = f => { l.value = !1, t("close", f); }; return (f, p) => (k(), ge(yn, { name: i(s).b("fade"), persisted: "" }, { default: ie(() => [dt(Q("div", { class: O([i(s).b(), i(s).m(f.type), i(s).is("center", f.center), i(s).is(f.effect)]), role: "alert" }, [f.showIcon && i(a) ? (k(), ge(i(Je), { key: 0, class: O(i(u)) }, { default: ie(() => [(k(), ge(kt(i(a))))]), _: 1 }, 8, ["class"])) : pe("v-if", !0), Q("div", { class: O(i(s).e("content")) }, [f.title || f.$slots.title ? (k(), z("span", { key: 0, class: O([i(s).e("title"), i(c)]) }, [ke(f.$slots, "title", {}, () => [Ot(Be(f.title), 1)])], 2)) : pe("v-if", !0), f.$slots.default || f.description ? (k(), z("p", { key: 1, class: O(i(s).e("description")) }, [ke(f.$slots, "default", {}, () => [Ot(Be(f.description), 1)])], 2)) : pe("v-if", !0), f.closable ? (k(), z(Qe, { key: 2 }, [f.closeText ? (k(), z("div", { key: 0, class: O([i(s).e("close-btn"), i(s).is("customed")]), onClick: d }, Be(f.closeText), 3)) : (k(), ge(i(Je), { key: 1, class: O(i(s).e("close-btn")), onClick: d }, { default: ie(() => [ee(i(o))]), _: 1 }, 8, ["class"]))], 64)) : pe("v-if", !0)], 2)], 2), [[Pt, l.value]])]), _: 3 }, 8, ["name"])); } });
var iL = Fe(aL, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/alert/src/alert.vue"]]);
const uL = vt(iL), Gs = Symbol("formContextKey"), rr = Symbol("formItemContextKey"), kn = (e, t = {}) => { const n = M(void 0), o = t.prop ? n : W1("size"), r = t.global ? n : F6(), s = t.form ? { size: void 0 } : Ye(Gs, void 0), l = t.formItem ? { size: void 0 } : Ye(rr, void 0); return S(() => o.value || i(e) || (l == null ? void 0 : l.size) || (s == null ? void 0 : s.size) || r.value || ""); }, uo = e => { const t = W1("disabled"), n = Ye(Gs, void 0); return S(() => t.value || i(e) || (n == null ? void 0 : n.disabled) || !1); }, Zn = () => { const e = Ye(Gs, void 0), t = Ye(rr, void 0); return { form: e, formItem: t }; }, us = (e, { formItemContext: t, disableIdGeneration: n, disableIdManagement: o }) => { n || (n = M(!1)), o || (o = M(!1)); const r = M(); let s; const l = S(() => { var a; return !!(!e.label && t && t.inputIds && ((a = t.inputIds) == null ? void 0 : a.length) <= 1); }); return ft(() => { s = Oe([an(e, "id"), n], ([a, u]) => { const c = a ?? (u ? void 0 : xo().value); c !== r.value && (t != null && t.removeInputId && (r.value && t.removeInputId(r.value), !(o != null && o.value) && !u && c && t.addInputId(c)), r.value = c); }, { immediate: !0 }); }), rs(() => { s && s(), t != null && t.removeInputId && r.value && t.removeInputId(r.value); }), { isLabeledByFormItem: l, inputId: r }; }, cL = Ve({ size: { type: String, values: sr }, disabled: Boolean }), dL = Ve({ ...cL, model: Object, rules: { type: ve(Object) }, labelPosition: { type: String, values: ["left", "right", "top"], default: "right" }, requireAsteriskPosition: { type: String, values: ["left", "right"], default: "left" }, labelWidth: { type: [String, Number], default: "" }, labelSuffix: { type: String, default: "" }, inline: Boolean, inlineMessage: Boolean, statusIcon: Boolean, showMessage: { type: Boolean, default: !0 }, validateOnRuleChange: { type: Boolean, default: !0 }, hideRequiredAsterisk: Boolean, scrollToError: Boolean, scrollIntoViewOptions: { type: [Object, Boolean] } }), fL = { validate: (e, t, n) => (qe(e) || it(e)) && wn(t) && it(n) };
function pL() { const e = M([]), t = S(() => { if (!e.value.length)
    return "0"; const s = Math.max(...e.value); return s ? `${s}px` : ""; }); function n(s) { const l = e.value.indexOf(s); return l === -1 && t.value, l; } function o(s, l) { if (s && l) {
    const a = n(l);
    e.value.splice(a, 1, s);
}
else
    s && e.value.push(s); } function r(s) { const l = n(s); l > -1 && e.value.splice(l, 1); } return { autoLabelWidth: t, registerLabelWidth: o, deregisterLabelWidth: r }; }
const ji = (e, t) => { const n = xl(t); return n.length > 0 ? e.filter(o => o.prop && n.includes(o.prop)) : e; }, hL = "ElForm", vL = ae({ name: hL }), mL = ae({ ...vL, props: dL, emits: fL, setup(e, { expose: t, emit: n }) { const o = e, r = [], s = kn(), l = Ie("form"), a = S(() => { const { labelPosition: C, inline: b } = o; return [l.b(), l.m(s.value || "default"), { [l.m(`label-${C}`)]: C, [l.m("inline")]: b }]; }), u = C => { r.push(C); }, c = C => { C.prop && r.splice(r.indexOf(C), 1); }, d = (C = []) => { o.model && ji(r, C).forEach(b => b.resetField()); }, f = (C = []) => { ji(r, C).forEach(b => b.clearValidate()); }, p = S(() => !!o.model), v = C => { if (r.length === 0)
        return []; const b = ji(r, C); return b.length ? b : []; }, m = async (C) => g(void 0, C), h = async (C = []) => { if (!p.value)
        return !1; const b = v(C); if (b.length === 0)
        return !0; let w = {}; for (const T of b)
        try {
            await T.validate("");
        }
        catch (E) {
            w = { ...w, ...E };
        } return Object.keys(w).length === 0 ? !0 : Promise.reject(w); }, g = async (C = [], b) => { const w = !at(b); try {
        const T = await h(C);
        return T === !0 && (b == null || b(T)), T;
    }
    catch (T) {
        if (T instanceof Error)
            throw T;
        const E = T;
        return o.scrollToError && y(Object.keys(E)[0]), b == null || b(!1, E), w && Promise.reject(E);
    } }, y = C => { var b; const w = ji(r, C)[0]; w && ((b = w.$el) == null || b.scrollIntoView(o.scrollIntoViewOptions)); }; return Oe(() => o.rules, () => { o.validateOnRuleChange && m().catch(C => void 0); }, { deep: !0 }), St(Gs, Lt({ ...Sn(o), emit: n, resetFields: d, clearValidate: f, validateField: g, addField: u, removeField: c, ...pL() })), t({ validate: m, validateField: g, resetFields: d, clearValidate: f, scrollToField: y }), (C, b) => (k(), z("form", { class: O(i(a)) }, [ke(C.$slots, "default")], 2)); } });
var gL = Fe(mL, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form.vue"]]);
function $s() { return $s = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
} return e; }, $s.apply(this, arguments); }
function yL(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, ni(e, t); }
function bf(e) { return bf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n); }, bf(e); }
function ni(e, t) { return ni = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (o, r) { return o.__proto__ = r, o; }, ni(e, t); }
function bL() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1; if (typeof Proxy == "function")
    return !0; try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0;
}
catch {
    return !1;
} }
function fu(e, t, n) { return bL() ? fu = Reflect.construct.bind() : fu = function (r, s, l) { var a = [null]; a.push.apply(a, s); var u = Function.bind.apply(r, a), c = new u; return l && ni(c, l.prototype), c; }, fu.apply(null, arguments); }
function wL(e) { return Function.toString.call(e).indexOf("[native code]") !== -1; }
function wf(e) { var t = typeof Map == "function" ? new Map : void 0; return wf = function (o) { if (o === null || !wL(o))
    return o; if (typeof o != "function")
    throw new TypeError("Super expression must either be null or a function"); if (typeof t < "u") {
    if (t.has(o))
        return t.get(o);
    t.set(o, r);
} function r() { return fu(o, arguments, bf(this).constructor); } return r.prototype = Object.create(o.prototype, { constructor: { value: r, enumerable: !1, writable: !0, configurable: !0 } }), ni(r, o); }, wf(e); }
var CL = /%[sdj%]/g, SL = function () { };
typeof process < "u" && process.env;
function Cf(e) { if (!e || !e.length)
    return null; var t = {}; return e.forEach(function (n) { var o = n.field; t[o] = t[o] || [], t[o].push(n); }), t; }
function vo(e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
    n[o - 1] = arguments[o]; var r = 0, s = n.length; if (typeof e == "function")
    return e.apply(null, n); if (typeof e == "string") {
    var l = e.replace(CL, function (a) { if (a === "%%")
        return "%"; if (r >= s)
        return a; switch (a) {
        case "%s": return String(n[r++]);
        case "%d": return Number(n[r++]);
        case "%j":
            try {
                return JSON.stringify(n[r++]);
            }
            catch {
                return "[Circular]";
            }
            break;
        default: return a;
    } });
    return l;
} return e; }
function _L(e) { return e === "string" || e === "url" || e === "hex" || e === "email" || e === "date" || e === "pattern"; }
function $n(e, t) { return !!(e == null || t === "array" && Array.isArray(e) && !e.length || _L(t) && typeof e == "string" && !e); }
function kL(e, t, n) { var o = [], r = 0, s = e.length; function l(a) { o.push.apply(o, a || []), r++, r === s && n(o); } e.forEach(function (a) { t(a, l); }); }
function Ug(e, t, n) { var o = 0, r = e.length; function s(l) { if (l && l.length) {
    n(l);
    return;
} var a = o; o = o + 1, a < r ? t(e[a], s) : n([]); } s([]); }
function EL(e) { var t = []; return Object.keys(e).forEach(function (n) { t.push.apply(t, e[n] || []); }), t; }
var qg = function (e) { yL(t, e); function t(n, o) { var r; return r = e.call(this, "Async Validation Error") || this, r.errors = n, r.fields = o, r; } return t; }(wf(Error));
function $L(e, t, n, o, r) { if (t.first) {
    var s = new Promise(function (p, v) { var m = function (y) { return o(y), y.length ? v(new qg(y, Cf(y))) : p(r); }, h = EL(e); Ug(h, n, m); });
    return s.catch(function (p) { return p; }), s;
} var l = t.firstFields === !0 ? Object.keys(e) : t.firstFields || [], a = Object.keys(e), u = a.length, c = 0, d = [], f = new Promise(function (p, v) { var m = function (g) { if (d.push.apply(d, g), c++, c === u)
    return o(d), d.length ? v(new qg(d, Cf(d))) : p(r); }; a.length || (o(d), p(r)), a.forEach(function (h) { var g = e[h]; l.indexOf(h) !== -1 ? Ug(g, n, m) : kL(g, n, m); }); }); return f.catch(function (p) { return p; }), f; }
function TL(e) { return !!(e && e.message !== void 0); }
function OL(e, t) { for (var n = e, o = 0; o < t.length; o++) {
    if (n == null)
        return n;
    n = n[t[o]];
} return n; }
function Yg(e, t) { return function (n) { var o; return e.fullFields ? o = OL(t, e.fullFields) : o = t[n.field || e.fullField], TL(n) ? (n.field = n.field || e.fullField, n.fieldValue = o, n) : { message: typeof n == "function" ? n() : n, fieldValue: o, field: n.field || e.fullField }; }; }
function Gg(e, t) { if (t) {
    for (var n in t)
        if (t.hasOwnProperty(n)) {
            var o = t[n];
            typeof o == "object" && typeof e[n] == "object" ? e[n] = $s({}, e[n], o) : e[n] = o;
        }
} return e; }
var kw = function (t, n, o, r, s, l) { t.required && (!o.hasOwnProperty(t.field) || $n(n, l || t.type)) && r.push(vo(s.messages.required, t.fullField)); }, IL = function (t, n, o, r, s) { (/^\s+$/.test(n) || n === "") && r.push(vo(s.messages.whitespace, t.fullField)); }, Wi, xL = function () {
    if (Wi)
        return Wi;
    var e = "[a-fA-F\\d:]", t = function (w) { return w && w.includeBoundaries ? "(?:(?<=\\s|^)(?=" + e + ")|(?<=" + e + ")(?=\\s|$))" : ""; }, n = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", o = "[a-fA-F\\d]{1,4}", r = (`
(?:
(?:` + o + ":){7}(?:" + o + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + o + ":){6}(?:" + n + "|:" + o + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + o + ":){5}(?::" + n + "|(?::" + o + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + o + ":){4}(?:(?::" + o + "){0,1}:" + n + "|(?::" + o + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + o + ":){3}(?:(?::" + o + "){0,2}:" + n + "|(?::" + o + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + o + ":){2}(?:(?::" + o + "){0,3}:" + n + "|(?::" + o + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + o + ":){1}(?:(?::" + o + "){0,4}:" + n + "|(?::" + o + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + o + "){0,5}:" + n + "|(?::" + o + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), s = new RegExp("(?:^" + n + "$)|(?:^" + r + "$)"), l = new RegExp("^" + n + "$"), a = new RegExp("^" + r + "$"), u = function (w) { return w && w.exact ? s : new RegExp("(?:" + t(w) + n + t(w) + ")|(?:" + t(w) + r + t(w) + ")", "g"); };
    u.v4 = function (b) { return b && b.exact ? l : new RegExp("" + t(b) + n + t(b), "g"); }, u.v6 = function (b) { return b && b.exact ? a : new RegExp("" + t(b) + r + t(b), "g"); };
    var c = "(?:(?:[a-z]+:)?//)", d = "(?:\\S+(?::\\S*)?@)?", f = u.v4().source, p = u.v6().source, v = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", m = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", h = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", g = "(?::\\d{2,5})?", y = '(?:[/?#][^\\s"]*)?', C = "(?:" + c + "|www\\.)" + d + "(?:localhost|" + f + "|" + p + "|" + v + m + h + ")" + g + y;
    return Wi = new RegExp("(?:^" + C + "$)", "i"), Wi;
}, Xg = { email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/, hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i }, va = { integer: function (t) { return va.number(t) && parseInt(t, 10) === t; }, float: function (t) { return va.number(t) && !va.integer(t); }, array: function (t) { return Array.isArray(t); }, regexp: function (t) { if (t instanceof RegExp)
        return !0; try {
        return !!new RegExp(t);
    }
    catch {
        return !1;
    } }, date: function (t) { return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime()); }, number: function (t) { return isNaN(t) ? !1 : typeof t == "number"; }, object: function (t) { return typeof t == "object" && !va.array(t); }, method: function (t) { return typeof t == "function"; }, email: function (t) { return typeof t == "string" && t.length <= 320 && !!t.match(Xg.email); }, url: function (t) { return typeof t == "string" && t.length <= 2048 && !!t.match(xL()); }, hex: function (t) { return typeof t == "string" && !!t.match(Xg.hex); } }, AL = function (t, n, o, r, s) { if (t.required && n === void 0) {
    kw(t, n, o, r, s);
    return;
} var l = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], a = t.type; l.indexOf(a) > -1 ? va[a](n) || r.push(vo(s.messages.types[a], t.fullField, t.type)) : a && typeof n !== t.type && r.push(vo(s.messages.types[a], t.fullField, t.type)); }, ML = function (t, n, o, r, s) { var l = typeof t.len == "number", a = typeof t.min == "number", u = typeof t.max == "number", c = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, d = n, f = null, p = typeof n == "number", v = typeof n == "string", m = Array.isArray(n); if (p ? f = "number" : v ? f = "string" : m && (f = "array"), !f)
    return !1; m && (d = n.length), v && (d = n.replace(c, "_").length), l ? d !== t.len && r.push(vo(s.messages[f].len, t.fullField, t.len)) : a && !u && d < t.min ? r.push(vo(s.messages[f].min, t.fullField, t.min)) : u && !a && d > t.max ? r.push(vo(s.messages[f].max, t.fullField, t.max)) : a && u && (d < t.min || d > t.max) && r.push(vo(s.messages[f].range, t.fullField, t.min, t.max)); }, Zs = "enum", NL = function (t, n, o, r, s) { t[Zs] = Array.isArray(t[Zs]) ? t[Zs] : [], t[Zs].indexOf(n) === -1 && r.push(vo(s.messages[Zs], t.fullField, t[Zs].join(", "))); }, PL = function (t, n, o, r, s) { if (t.pattern) {
    if (t.pattern instanceof RegExp)
        t.pattern.lastIndex = 0, t.pattern.test(n) || r.push(vo(s.messages.pattern.mismatch, t.fullField, n, t.pattern));
    else if (typeof t.pattern == "string") {
        var l = new RegExp(t.pattern);
        l.test(n) || r.push(vo(s.messages.pattern.mismatch, t.fullField, n, t.pattern));
    }
} }, Yt = { required: kw, whitespace: IL, type: AL, range: ML, enum: NL, pattern: PL }, RL = function (t, n, o, r, s) { var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field); if (a) {
    if ($n(n, "string") && !t.required)
        return o();
    Yt.required(t, n, r, l, s, "string"), $n(n, "string") || (Yt.type(t, n, r, l, s), Yt.range(t, n, r, l, s), Yt.pattern(t, n, r, l, s), t.whitespace === !0 && Yt.whitespace(t, n, r, l, s));
} o(l); }, LL = function (t, n, o, r, s) { var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field); if (a) {
    if ($n(n) && !t.required)
        return o();
    Yt.required(t, n, r, l, s), n !== void 0 && Yt.type(t, n, r, l, s);
} o(l); }, DL = function (t, n, o, r, s) { var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field); if (a) {
    if (n === "" && (n = void 0), $n(n) && !t.required)
        return o();
    Yt.required(t, n, r, l, s), n !== void 0 && (Yt.type(t, n, r, l, s), Yt.range(t, n, r, l, s));
} o(l); }, BL = function (t, n, o, r, s) { var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field); if (a) {
    if ($n(n) && !t.required)
        return o();
    Yt.required(t, n, r, l, s), n !== void 0 && Yt.type(t, n, r, l, s);
} o(l); }, FL = function (t, n, o, r, s) { var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field); if (a) {
    if ($n(n) && !t.required)
        return o();
    Yt.required(t, n, r, l, s), $n(n) || Yt.type(t, n, r, l, s);
} o(l); }, VL = function (t, n, o, r, s) { var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field); if (a) {
    if ($n(n) && !t.required)
        return o();
    Yt.required(t, n, r, l, s), n !== void 0 && (Yt.type(t, n, r, l, s), Yt.range(t, n, r, l, s));
} o(l); }, zL = function (t, n, o, r, s) { var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field); if (a) {
    if ($n(n) && !t.required)
        return o();
    Yt.required(t, n, r, l, s), n !== void 0 && (Yt.type(t, n, r, l, s), Yt.range(t, n, r, l, s));
} o(l); }, HL = function (t, n, o, r, s) { var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field); if (a) {
    if (n == null && !t.required)
        return o();
    Yt.required(t, n, r, l, s, "array"), n != null && (Yt.type(t, n, r, l, s), Yt.range(t, n, r, l, s));
} o(l); }, KL = function (t, n, o, r, s) { var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field); if (a) {
    if ($n(n) && !t.required)
        return o();
    Yt.required(t, n, r, l, s), n !== void 0 && Yt.type(t, n, r, l, s);
} o(l); }, jL = "enum", WL = function (t, n, o, r, s) { var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field); if (a) {
    if ($n(n) && !t.required)
        return o();
    Yt.required(t, n, r, l, s), n !== void 0 && Yt[jL](t, n, r, l, s);
} o(l); }, UL = function (t, n, o, r, s) { var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field); if (a) {
    if ($n(n, "string") && !t.required)
        return o();
    Yt.required(t, n, r, l, s), $n(n, "string") || Yt.pattern(t, n, r, l, s);
} o(l); }, qL = function (t, n, o, r, s) { var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field); if (a) {
    if ($n(n, "date") && !t.required)
        return o();
    if (Yt.required(t, n, r, l, s), !$n(n, "date")) {
        var u;
        n instanceof Date ? u = n : u = new Date(n), Yt.type(t, u, r, l, s), u && Yt.range(t, u.getTime(), r, l, s);
    }
} o(l); }, YL = function (t, n, o, r, s) { var l = [], a = Array.isArray(n) ? "array" : typeof n; Yt.required(t, n, r, l, s, a), o(l); }, _d = function (t, n, o, r, s) { var l = t.type, a = [], u = t.required || !t.required && r.hasOwnProperty(t.field); if (u) {
    if ($n(n, l) && !t.required)
        return o();
    Yt.required(t, n, r, a, s, l), $n(n, l) || Yt.type(t, n, r, a, s);
} o(a); }, GL = function (t, n, o, r, s) { var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field); if (a) {
    if ($n(n) && !t.required)
        return o();
    Yt.required(t, n, r, l, s);
} o(l); }, Oa = { string: RL, method: LL, number: DL, boolean: BL, regexp: FL, integer: VL, float: zL, array: HL, object: KL, enum: WL, pattern: UL, date: qL, url: _d, hex: _d, email: _d, required: YL, any: GL };
function Sf() { return { default: "Validation error on field %s", required: "%s is required", enum: "%s must be one of %s", whitespace: "%s cannot be empty", date: { format: "%s date %s is invalid for format %s", parse: "%s date could not be parsed, %s is invalid ", invalid: "%s date %s is invalid" }, types: { string: "%s is not a %s", method: "%s is not a %s (function)", array: "%s is not an %s", object: "%s is not an %s", number: "%s is not a %s", date: "%s is not a %s", boolean: "%s is not a %s", integer: "%s is not an %s", float: "%s is not a %s", regexp: "%s is not a valid %s", email: "%s is not a valid %s", url: "%s is not a valid %s", hex: "%s is not a valid %s" }, string: { len: "%s must be exactly %s characters", min: "%s must be at least %s characters", max: "%s cannot be longer than %s characters", range: "%s must be between %s and %s characters" }, number: { len: "%s must equal %s", min: "%s cannot be less than %s", max: "%s cannot be greater than %s", range: "%s must be between %s and %s" }, array: { len: "%s must be exactly %s in length", min: "%s cannot be less than %s in length", max: "%s cannot be greater than %s in length", range: "%s must be between %s and %s in length" }, pattern: { mismatch: "%s value %s does not match pattern %s" }, clone: function () { var t = JSON.parse(JSON.stringify(this)); return t.clone = this.clone, t; } }; }
var _f = Sf(), $i = function () { function e(n) { this.rules = null, this._messages = _f, this.define(n); } var t = e.prototype; return t.define = function (o) { var r = this; if (!o)
    throw new Error("Cannot configure a schema with no rules"); if (typeof o != "object" || Array.isArray(o))
    throw new Error("Rules must be an object"); this.rules = {}, Object.keys(o).forEach(function (s) { var l = o[s]; r.rules[s] = Array.isArray(l) ? l : [l]; }); }, t.messages = function (o) { return o && (this._messages = Gg(Sf(), o)), this._messages; }, t.validate = function (o, r, s) { var l = this; r === void 0 && (r = {}), s === void 0 && (s = function () { }); var a = o, u = r, c = s; if (typeof u == "function" && (c = u, u = {}), !this.rules || Object.keys(this.rules).length === 0)
    return c && c(null, a), Promise.resolve(a); function d(h) { var g = [], y = {}; function C(w) { if (Array.isArray(w)) {
    var T;
    g = (T = g).concat.apply(T, w);
}
else
    g.push(w); } for (var b = 0; b < h.length; b++)
    C(h[b]); g.length ? (y = Cf(g), c(g, y)) : c(null, a); } if (u.messages) {
    var f = this.messages();
    f === _f && (f = Sf()), Gg(f, u.messages), u.messages = f;
}
else
    u.messages = this.messages(); var p = {}, v = u.keys || Object.keys(this.rules); v.forEach(function (h) { var g = l.rules[h], y = a[h]; g.forEach(function (C) { var b = C; typeof b.transform == "function" && (a === o && (a = $s({}, a)), y = a[h] = b.transform(y)), typeof b == "function" ? b = { validator: b } : b = $s({}, b), b.validator = l.getValidationMethod(b), b.validator && (b.field = h, b.fullField = b.fullField || h, b.type = l.getType(b), p[h] = p[h] || [], p[h].push({ rule: b, value: y, source: a, field: h })); }); }); var m = {}; return $L(p, u, function (h, g) { var y = h.rule, C = (y.type === "object" || y.type === "array") && (typeof y.fields == "object" || typeof y.defaultField == "object"); C = C && (y.required || !y.required && h.value), y.field = h.field; function b(E, x) { return $s({}, x, { fullField: y.fullField + "." + E, fullFields: y.fullFields ? [].concat(y.fullFields, [E]) : [E] }); } function w(E) { E === void 0 && (E = []); var x = Array.isArray(E) ? E : [E]; !u.suppressWarning && x.length && e.warning("async-validator:", x), x.length && y.message !== void 0 && (x = [].concat(y.message)); var I = x.map(Yg(y, a)); if (u.first && I.length)
    return m[y.field] = 1, g(I); if (!C)
    g(I);
else {
    if (y.required && !h.value)
        return y.message !== void 0 ? I = [].concat(y.message).map(Yg(y, a)) : u.error && (I = [u.error(y, vo(u.messages.required, y.field))]), g(I);
    var L = {};
    y.defaultField && Object.keys(h.value).map(function (V) { L[V] = y.defaultField; }), L = $s({}, L, h.rule.fields);
    var B = {};
    Object.keys(L).forEach(function (V) { var R = L[V], K = Array.isArray(R) ? R : [R]; B[V] = K.map(b.bind(null, V)); });
    var F = new e(B);
    F.messages(u.messages), h.rule.options && (h.rule.options.messages = u.messages, h.rule.options.error = u.error), F.validate(h.value, h.rule.options || u, function (V) { var R = []; I && I.length && R.push.apply(R, I), V && V.length && R.push.apply(R, V), g(R.length ? R : null); });
} } var T; if (y.asyncValidator)
    T = y.asyncValidator(y, h.value, w, h.source, u);
else if (y.validator) {
    try {
        T = y.validator(y, h.value, w, h.source, u);
    }
    catch (E) {
        console.error == null || console.error(E), u.suppressValidatorError || setTimeout(function () { throw E; }, 0), w(E.message);
    }
    T === !0 ? w() : T === !1 ? w(typeof y.message == "function" ? y.message(y.fullField || y.field) : y.message || (y.fullField || y.field) + " fails") : T instanceof Array ? w(T) : T instanceof Error && w(T.message);
} T && T.then && T.then(function () { return w(); }, function (E) { return w(E); }); }, function (h) { d(h); }, a); }, t.getType = function (o) { if (o.type === void 0 && o.pattern instanceof RegExp && (o.type = "pattern"), typeof o.validator != "function" && o.type && !Oa.hasOwnProperty(o.type))
    throw new Error(vo("Unknown rule type %s", o.type)); return o.type || "string"; }, t.getValidationMethod = function (o) { if (typeof o.validator == "function")
    return o.validator; var r = Object.keys(o), s = r.indexOf("message"); return s !== -1 && r.splice(s, 1), r.length === 1 && r[0] === "required" ? Oa.required : Oa[this.getType(o)] || void 0; }, e; }();
$i.register = function (t, n) { if (typeof n != "function")
    throw new Error("Cannot register a validator by type, validator is not a function"); Oa[t] = n; };
$i.warning = SL;
$i.messages = _f;
$i.validators = Oa;
const XL = ["", "error", "validating", "success"], JL = Ve({ label: String, labelWidth: { type: [String, Number], default: "" }, prop: { type: ve([String, Array]) }, required: { type: Boolean, default: void 0 }, rules: { type: ve([Object, Array]) }, error: String, validateStatus: { type: String, values: XL }, for: String, inlineMessage: { type: [String, Boolean], default: "" }, showMessage: { type: Boolean, default: !0 }, size: { type: String, values: sr } }), Jg = "ElLabelWrap";
var ZL = ae({ name: Jg, props: { isAutoWidth: Boolean, updateAll: Boolean }, setup(e, { slots: t }) { const n = Ye(Gs, void 0), o = Ye(rr); o || _n(Jg, "usage: <el-form-item><label-wrap /></el-form-item>"); const r = Ie("form"), s = M(), l = M(0), a = () => { var d; if ((d = s.value) != null && d.firstElementChild) {
        const f = window.getComputedStyle(s.value.firstElementChild).width;
        return Math.ceil(Number.parseFloat(f));
    }
    else
        return 0; }, u = (d = "update") => { Xe(() => { t.default && e.isAutoWidth && (d === "update" ? l.value = a() : d === "remove" && (n == null || n.deregisterLabelWidth(l.value))); }); }, c = () => u("update"); return ft(() => { c(); }), on(() => { u("remove"); }), Er(() => c()), Oe(l, (d, f) => { e.updateAll && (n == null || n.registerLabelWidth(d, f)); }), Vn(S(() => { var d, f; return (f = (d = s.value) == null ? void 0 : d.firstElementChild) != null ? f : null; }), c), () => { var d, f; if (!t)
        return null; const { isAutoWidth: p } = e; if (p) {
        const v = n == null ? void 0 : n.autoLabelWidth, m = o == null ? void 0 : o.hasLabel, h = {};
        if (m && v && v !== "auto") {
            const g = Math.max(0, Number.parseInt(v, 10) - l.value), y = n.labelPosition === "left" ? "marginRight" : "marginLeft";
            g && (h[y] = `${g}px`);
        }
        return ee("div", { ref: s, class: [r.be("item", "label-wrap")], style: h }, [(d = t.default) == null ? void 0 : d.call(t)]);
    }
    else
        return ee(Qe, { ref: s }, [(f = t.default) == null ? void 0 : f.call(t)]); }; } });
const QL = ["role", "aria-labelledby"], eD = ae({ name: "ElFormItem" }), tD = ae({ ...eD, props: JL, setup(e, { expose: t }) { const n = e, o = An(), r = Ye(Gs, void 0), s = Ye(rr, void 0), l = kn(void 0, { formItem: !1 }), a = Ie("form-item"), u = xo().value, c = M([]), d = M(""), f = Z$(d, 100), p = M(""), v = M(); let m, h = !1; const g = S(() => { if ((r == null ? void 0 : r.labelPosition) === "top")
        return {}; const le = gn(n.labelWidth || (r == null ? void 0 : r.labelWidth) || ""); return le ? { width: le } : {}; }), y = S(() => { if ((r == null ? void 0 : r.labelPosition) === "top" || r != null && r.inline)
        return {}; if (!n.label && !n.labelWidth && L)
        return {}; const le = gn(n.labelWidth || (r == null ? void 0 : r.labelWidth) || ""); return !n.label && !o.label ? { marginLeft: le } : {}; }), C = S(() => [a.b(), a.m(l.value), a.is("error", d.value === "error"), a.is("validating", d.value === "validating"), a.is("success", d.value === "success"), a.is("required", K.value || n.required), a.is("no-asterisk", r == null ? void 0 : r.hideRequiredAsterisk), (r == null ? void 0 : r.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left", { [a.m("feedback")]: r == null ? void 0 : r.statusIcon }]), b = S(() => wn(n.inlineMessage) ? n.inlineMessage : (r == null ? void 0 : r.inlineMessage) || !1), w = S(() => [a.e("error"), { [a.em("error", "inline")]: b.value }]), T = S(() => n.prop ? it(n.prop) ? n.prop : n.prop.join(".") : ""), E = S(() => !!(n.label || o.label)), x = S(() => n.for || c.value.length === 1 ? c.value[0] : void 0), I = S(() => !x.value && E.value), L = !!s, B = S(() => { const le = r == null ? void 0 : r.model; if (!(!le || !n.prop))
        return cu(le, n.prop).value; }), F = S(() => { const { required: le } = n, oe = []; n.rules && oe.push(...xl(n.rules)); const fe = r == null ? void 0 : r.rules; if (fe && n.prop) {
        const Ce = cu(fe, n.prop).value;
        Ce && oe.push(...xl(Ce));
    } if (le !== void 0) {
        const Ce = oe.map((Ae, q) => [Ae, q]).filter(([Ae]) => Object.keys(Ae).includes("required"));
        if (Ce.length > 0)
            for (const [Ae, q] of Ce)
                Ae.required !== le && (oe[q] = { ...Ae, required: le });
        else
            oe.push({ required: le });
    } return oe; }), V = S(() => F.value.length > 0), R = le => F.value.filter(fe => !fe.trigger || !le ? !0 : Array.isArray(fe.trigger) ? fe.trigger.includes(le) : fe.trigger === le).map(({ trigger: fe, ...Ce }) => Ce), K = S(() => F.value.some(le => le.required)), te = S(() => { var le; return f.value === "error" && n.showMessage && ((le = r == null ? void 0 : r.showMessage) != null ? le : !0); }), U = S(() => `${n.label || ""}${(r == null ? void 0 : r.labelSuffix) || ""}`), D = le => { d.value = le; }, j = le => { var oe, fe; const { errors: Ce, fields: Ae } = le; (!Ce || !Ae) && console.error(le), D("error"), p.value = Ce ? (fe = (oe = Ce == null ? void 0 : Ce[0]) == null ? void 0 : oe.message) != null ? fe : `${n.prop} is required` : "", r == null || r.emit("validate", n.prop, !1, p.value); }, A = () => { D("success"), r == null || r.emit("validate", n.prop, !0, ""); }, G = async (le) => { const oe = T.value; return new $i({ [oe]: le }).validate({ [oe]: B.value }, { firstFields: !0 }).then(() => (A(), !0)).catch(Ce => (j(Ce), Promise.reject(Ce))); }, se = async (le, oe) => { if (h || !n.prop)
        return !1; const fe = at(oe); if (!V.value)
        return oe == null || oe(!1), !1; const Ce = R(le); return Ce.length === 0 ? (oe == null || oe(!0), !0) : (D("validating"), G(Ce).then(() => (oe == null || oe(!0), !0)).catch(Ae => { const { fields: q } = Ae; return oe == null || oe(!1, q), fe ? !1 : Promise.reject(q); })); }, Z = () => { D(""), p.value = "", h = !1; }, ce = async () => { const le = r == null ? void 0 : r.model; if (!le || !n.prop)
        return; const oe = cu(le, n.prop); h = !0, oe.value = yg(m), await Xe(), Z(), h = !1; }, ye = le => { c.value.includes(le) || c.value.push(le); }, Re = le => { c.value = c.value.filter(oe => oe !== le); }; Oe(() => n.error, le => { p.value = le || "", D(le ? "error" : ""); }, { immediate: !0 }), Oe(() => n.validateStatus, le => D(le || "")); const me = Lt({ ...Sn(n), $el: v, size: l, validateState: d, labelId: u, inputIds: c, isGroup: I, hasLabel: E, addInputId: ye, removeInputId: Re, resetField: ce, clearValidate: Z, validate: se }); return St(rr, me), ft(() => { n.prop && (r == null || r.addField(me), m = yg(B.value)); }), on(() => { r == null || r.removeField(me); }), t({ size: l, validateMessage: p, validateState: d, validate: se, clearValidate: Z, resetField: ce }), (le, oe) => { var fe; return k(), z("div", { ref_key: "formItemRef", ref: v, class: O(i(C)), role: i(I) ? "group" : void 0, "aria-labelledby": i(I) ? i(u) : void 0 }, [ee(i(ZL), { "is-auto-width": i(g).width === "auto", "update-all": ((fe = i(r)) == null ? void 0 : fe.labelWidth) === "auto" }, { default: ie(() => [i(E) ? (k(), ge(kt(i(x) ? "label" : "div"), { key: 0, id: i(u), for: i(x), class: O(i(a).e("label")), style: et(i(g)) }, { default: ie(() => [ke(le.$slots, "label", { label: i(U) }, () => [Ot(Be(i(U)), 1)])]), _: 3 }, 8, ["id", "for", "class", "style"])) : pe("v-if", !0)]), _: 3 }, 8, ["is-auto-width", "update-all"]), Q("div", { class: O(i(a).e("content")), style: et(i(y)) }, [ke(le.$slots, "default"), ee(Sb, { name: `${i(a).namespace.value}-zoom-in-top` }, { default: ie(() => [i(te) ? ke(le.$slots, "error", { key: 0, error: p.value }, () => [Q("div", { class: O(i(w)) }, Be(p.value), 3)]) : pe("v-if", !0)]), _: 3 }, 8, ["name"])], 6)], 10, QL); }; } });
var Ew = Fe(tD, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form-item.vue"]]);
const nD = vt(gL, { FormItem: Ew }), oD = pn(Ew);
let Mo;
const rD = `
  height:0 !important;
  visibility:hidden !important;
  ${Wb() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`, sD = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing"];
function lD(e) { const t = window.getComputedStyle(e), n = t.getPropertyValue("box-sizing"), o = Number.parseFloat(t.getPropertyValue("padding-bottom")) + Number.parseFloat(t.getPropertyValue("padding-top")), r = Number.parseFloat(t.getPropertyValue("border-bottom-width")) + Number.parseFloat(t.getPropertyValue("border-top-width")); return { contextStyle: sD.map(l => `${l}:${t.getPropertyValue(l)}`).join(";"), paddingSize: o, borderSize: r, boxSizing: n }; }
function Zg(e, t = 1, n) { var o; Mo || (Mo = document.createElement("textarea"), document.body.appendChild(Mo)); const { paddingSize: r, borderSize: s, boxSizing: l, contextStyle: a } = lD(e); Mo.setAttribute("style", `${a};${rD}`), Mo.value = e.value || e.placeholder || ""; let u = Mo.scrollHeight; const c = {}; l === "border-box" ? u = u + s : l === "content-box" && (u = u - r), Mo.value = ""; const d = Mo.scrollHeight - r; if (lt(t)) {
    let f = d * t;
    l === "border-box" && (f = f + r + s), u = Math.max(f, u), c.minHeight = `${f}px`;
} if (lt(n)) {
    let f = d * n;
    l === "border-box" && (f = f + r + s), u = Math.min(f, u);
} return c.height = `${u}px`, (o = Mo.parentNode) == null || o.removeChild(Mo), Mo = void 0, c; }
const aD = Ve({ id: { type: String, default: void 0 }, size: Bn, disabled: Boolean, modelValue: { type: ve([String, Number, Object]), default: "" }, type: { type: String, default: "text" }, resize: { type: String, values: ["none", "both", "horizontal", "vertical"] }, autosize: { type: ve([Boolean, Object]), default: !1 }, autocomplete: { type: String, default: "off" }, formatter: { type: Function }, parser: { type: Function }, placeholder: { type: String }, form: { type: String }, readonly: { type: Boolean, default: !1 }, clearable: { type: Boolean, default: !1 }, showPassword: { type: Boolean, default: !1 }, showWordLimit: { type: Boolean, default: !1 }, suffixIcon: { type: Zt }, prefixIcon: { type: Zt }, containerRole: { type: String, default: void 0 }, label: { type: String, default: void 0 }, tabindex: { type: [String, Number], default: 0 }, validateEvent: { type: Boolean, default: !0 }, inputStyle: { type: ve([Object, Array, String]), default: () => ln({}) } }), iD = { [gt]: e => it(e), input: e => it(e), change: e => it(e), focus: e => e instanceof FocusEvent, blur: e => e instanceof FocusEvent, clear: () => !0, mouseleave: e => e instanceof MouseEvent, mouseenter: e => e instanceof MouseEvent, keydown: e => e instanceof Event, compositionstart: e => e instanceof CompositionEvent, compositionupdate: e => e instanceof CompositionEvent, compositionend: e => e instanceof CompositionEvent }, uD = ["role"], cD = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form"], dD = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form"], fD = ae({ name: "ElInput", inheritAttrs: !1 }), pD = ae({ ...fD, props: aD, emits: iD, setup(e, { expose: t, emit: n }) { const o = e, r = js(), s = An(), l = S(() => { const Te = {}; return o.containerRole === "combobox" && (Te["aria-haspopup"] = r["aria-haspopup"], Te["aria-owns"] = r["aria-owns"], Te["aria-expanded"] = r["aria-expanded"]), Te; }), a = S(() => [o.type === "textarea" ? g.b() : h.b(), h.m(v.value), h.is("disabled", m.value), h.is("exceed", ye.value), { [h.b("group")]: s.prepend || s.append, [h.bm("group", "append")]: s.append, [h.bm("group", "prepend")]: s.prepend, [h.m("prefix")]: s.prefix || o.prefixIcon, [h.m("suffix")]: s.suffix || o.suffixIcon || o.clearable || o.showPassword, [h.bm("suffix", "password-clear")]: G.value && se.value }, r.class]), u = S(() => [h.e("wrapper"), h.is("focus", B.value)]), c = dh({ excludeKeys: S(() => Object.keys(l.value)) }), { form: d, formItem: f } = Zn(), { inputId: p } = us(o, { formItemContext: f }), v = kn(), m = uo(), h = Ie("input"), g = Ie("textarea"), y = Xt(), C = Xt(), b = M(!1), w = M(!1), T = M(!1), E = M(), x = Xt(o.inputStyle), I = S(() => y.value || C.value), { wrapperRef: L, isFocused: B, handleFocus: F, handleBlur: V } = V6(I, { afterBlur() { var Te; o.validateEvent && ((Te = f == null ? void 0 : f.validate) == null || Te.call(f, "blur").catch(Ge => void 0)); } }), R = S(() => { var Te; return (Te = d == null ? void 0 : d.statusIcon) != null ? Te : !1; }), K = S(() => (f == null ? void 0 : f.validateState) || ""), te = S(() => K.value && B1[K.value]), U = S(() => T.value ? IR : RN), D = S(() => [r.style, o.inputStyle]), j = S(() => [o.inputStyle, x.value, { resize: o.resize }]), A = S(() => bn(o.modelValue) ? "" : String(o.modelValue)), G = S(() => o.clearable && !m.value && !o.readonly && !!A.value && (B.value || b.value)), se = S(() => o.showPassword && !m.value && !o.readonly && !!A.value && (!!A.value || B.value)), Z = S(() => o.showWordLimit && !!c.value.maxlength && (o.type === "text" || o.type === "textarea") && !m.value && !o.readonly && !o.showPassword), ce = S(() => A.value.length), ye = S(() => !!Z.value && ce.value > Number(c.value.maxlength)), Re = S(() => !!s.suffix || !!o.suffixIcon || G.value || o.showPassword || Z.value || !!K.value && R.value), [me, le] = D6(y); Vn(C, Te => { if (Ce(), !Z.value || o.resize !== "both")
        return; const Ge = Te[0], { width: W } = Ge.contentRect; E.value = { right: `calc(100% - ${W + 15 + 6}px)` }; }); const oe = () => { const { type: Te, autosize: Ge } = o; if (!(!At || Te !== "textarea" || !C.value))
        if (Ge) {
            const W = yt(Ge) ? Ge.minRows : void 0, X = yt(Ge) ? Ge.maxRows : void 0, $ = Zg(C.value, W, X);
            x.value = { overflowY: "hidden", ...$ }, Xe(() => { C.value.offsetHeight, x.value = $; });
        }
        else
            x.value = { minHeight: Zg(C.value).minHeight }; }, Ce = (Te => { let Ge = !1; return () => { var W; if (Ge || !o.autosize)
        return; ((W = C.value) == null ? void 0 : W.offsetParent) === null || (Te(), Ge = !0); }; })(oe), Ae = () => { const Te = I.value, Ge = o.formatter ? o.formatter(A.value) : A.value; !Te || Te.value === Ge || (Te.value = Ge); }, q = async (Te) => { me(); let { value: Ge } = Te.target; if (o.formatter && (Ge = o.parser ? o.parser(Ge) : Ge), !w.value) {
        if (Ge === A.value) {
            Ae();
            return;
        }
        n(gt, Ge), n("input", Ge), await Xe(), Ae(), le();
    } }, re = Te => { n("change", Te.target.value); }, he = Te => { n("compositionstart", Te), w.value = !0; }, Ee = Te => { var Ge; n("compositionupdate", Te); const W = (Ge = Te.target) == null ? void 0 : Ge.value, X = W[W.length - 1] || ""; w.value = !Nc(X); }, Ne = Te => { n("compositionend", Te), w.value && (w.value = !1, q(Te)); }, Se = () => { T.value = !T.value, De(); }, De = async () => { var Te; await Xe(), (Te = I.value) == null || Te.focus(); }, Me = () => { var Te; return (Te = I.value) == null ? void 0 : Te.blur(); }, $e = Te => { b.value = !1, n("mouseleave", Te); }, Pe = Te => { b.value = !0, n("mouseenter", Te); }, He = Te => { n("keydown", Te); }, je = () => { var Te; (Te = I.value) == null || Te.select(); }, Ue = () => { n(gt, ""), n("change", ""), n("clear"), n("input", ""); }; return Oe(() => o.modelValue, () => { var Te; Xe(() => oe()), o.validateEvent && ((Te = f == null ? void 0 : f.validate) == null || Te.call(f, "change").catch(Ge => void 0)); }), Oe(A, () => Ae()), Oe(() => o.type, async () => { await Xe(), Ae(), oe(); }), ft(() => { !o.formatter && o.parser, Ae(), Xe(oe); }), t({ input: y, textarea: C, ref: I, textareaStyle: j, autosize: an(o, "autosize"), focus: De, blur: Me, select: je, clear: Ue, resizeTextarea: oe }), (Te, Ge) => dt((k(), z("div", Ct(i(l), { class: i(a), style: i(D), role: Te.containerRole, onMouseenter: Pe, onMouseleave: $e }), [pe(" input "), Te.type !== "textarea" ? (k(), z(Qe, { key: 0 }, [pe(" prepend slot "), Te.$slots.prepend ? (k(), z("div", { key: 0, class: O(i(h).be("group", "prepend")) }, [ke(Te.$slots, "prepend")], 2)) : pe("v-if", !0), Q("div", { ref_key: "wrapperRef", ref: L, class: O(i(u)) }, [pe(" prefix slot "), Te.$slots.prefix || Te.prefixIcon ? (k(), z("span", { key: 0, class: O(i(h).e("prefix")) }, [Q("span", { class: O(i(h).e("prefix-inner")) }, [ke(Te.$slots, "prefix"), Te.prefixIcon ? (k(), ge(i(Je), { key: 0, class: O(i(h).e("icon")) }, { default: ie(() => [(k(), ge(kt(Te.prefixIcon)))]), _: 1 }, 8, ["class"])) : pe("v-if", !0)], 2)], 2)) : pe("v-if", !0), Q("input", Ct({ id: i(p), ref_key: "input", ref: y, class: i(h).e("inner") }, i(c), { type: Te.showPassword ? T.value ? "text" : "password" : Te.type, disabled: i(m), formatter: Te.formatter, parser: Te.parser, readonly: Te.readonly, autocomplete: Te.autocomplete, tabindex: Te.tabindex, "aria-label": Te.label, placeholder: Te.placeholder, style: Te.inputStyle, form: o.form, onCompositionstart: he, onCompositionupdate: Ee, onCompositionend: Ne, onInput: q, onFocus: Ge[0] || (Ge[0] = (...W) => i(F) && i(F)(...W)), onBlur: Ge[1] || (Ge[1] = (...W) => i(V) && i(V)(...W)), onChange: re, onKeydown: He }), null, 16, cD), pe(" suffix slot "), i(Re) ? (k(), z("span", { key: 1, class: O(i(h).e("suffix")) }, [Q("span", { class: O(i(h).e("suffix-inner")) }, [!i(G) || !i(se) || !i(Z) ? (k(), z(Qe, { key: 0 }, [ke(Te.$slots, "suffix"), Te.suffixIcon ? (k(), ge(i(Je), { key: 0, class: O(i(h).e("icon")) }, { default: ie(() => [(k(), ge(kt(Te.suffixIcon)))]), _: 1 }, 8, ["class"])) : pe("v-if", !0)], 64)) : pe("v-if", !0), i(G) ? (k(), ge(i(Je), { key: 1, class: O([i(h).e("icon"), i(h).e("clear")]), onMousedown: st(i(Wt), ["prevent"]), onClick: Ue }, { default: ie(() => [ee(i(ls))]), _: 1 }, 8, ["class", "onMousedown"])) : pe("v-if", !0), i(se) ? (k(), ge(i(Je), { key: 2, class: O([i(h).e("icon"), i(h).e("password")]), onClick: Se }, { default: ie(() => [(k(), ge(kt(i(U))))]), _: 1 }, 8, ["class"])) : pe("v-if", !0), i(Z) ? (k(), z("span", { key: 3, class: O(i(h).e("count")) }, [Q("span", { class: O(i(h).e("count-inner")) }, Be(i(ce)) + " / " + Be(i(c).maxlength), 3)], 2)) : pe("v-if", !0), i(K) && i(te) && i(R) ? (k(), ge(i(Je), { key: 4, class: O([i(h).e("icon"), i(h).e("validateIcon"), i(h).is("loading", i(K) === "validating")]) }, { default: ie(() => [(k(), ge(kt(i(te))))]), _: 1 }, 8, ["class"])) : pe("v-if", !0)], 2)], 2)) : pe("v-if", !0)], 2), pe(" append slot "), Te.$slots.append ? (k(), z("div", { key: 1, class: O(i(h).be("group", "append")) }, [ke(Te.$slots, "append")], 2)) : pe("v-if", !0)], 64)) : (k(), z(Qe, { key: 1 }, [pe(" textarea "), Q("textarea", Ct({ id: i(p), ref_key: "textarea", ref: C, class: i(g).e("inner") }, i(c), { tabindex: Te.tabindex, disabled: i(m), readonly: Te.readonly, autocomplete: Te.autocomplete, style: i(j), "aria-label": Te.label, placeholder: Te.placeholder, form: o.form, onCompositionstart: he, onCompositionupdate: Ee, onCompositionend: Ne, onInput: q, onFocus: Ge[2] || (Ge[2] = (...W) => i(F) && i(F)(...W)), onBlur: Ge[3] || (Ge[3] = (...W) => i(V) && i(V)(...W)), onChange: re, onKeydown: He }), null, 16, dD), i(Z) ? (k(), z("span", { key: 0, style: et(E.value), class: O(i(h).e("count")) }, Be(i(ce)) + " / " + Be(i(c).maxlength), 7)) : pe("v-if", !0)], 64))], 16, uD)), [[Pt, Te.type !== "hidden"]]); } });
var hD = Fe(pD, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
const Ln = vt(hD), al = 4, $w = { vertical: { offset: "offsetHeight", scroll: "scrollTop", scrollSize: "scrollHeight", size: "height", key: "vertical", axis: "Y", client: "clientY", direction: "top" }, horizontal: { offset: "offsetWidth", scroll: "scrollLeft", scrollSize: "scrollWidth", size: "width", key: "horizontal", axis: "X", client: "clientX", direction: "left" } }, vD = ({ move: e, size: t, bar: n }) => ({ [n.size]: t, transform: `translate${n.axis}(${e}%)` }), Tw = Symbol("scrollbarContextKey"), mD = Ve({ vertical: Boolean, size: String, move: Number, ratio: { type: Number, required: !0 }, always: Boolean }), gD = "Thumb", yD = ae({ __name: "thumb", props: mD, setup(e) { const t = e, n = Ye(Tw), o = Ie("scrollbar"); n || _n(gD, "can not inject scrollbar context"); const r = M(), s = M(), l = M({}), a = M(!1); let u = !1, c = !1, d = At ? document.onselectstart : null; const f = S(() => $w[t.vertical ? "vertical" : "horizontal"]), p = S(() => vD({ size: t.size, move: t.move, bar: f.value })), v = S(() => r.value[f.value.offset] ** 2 / n.wrapElement[f.value.scrollSize] / t.ratio / s.value[f.value.offset]), m = E => { var x; if (E.stopPropagation(), E.ctrlKey || [1, 2].includes(E.button))
        return; (x = window.getSelection()) == null || x.removeAllRanges(), g(E); const I = E.currentTarget; I && (l.value[f.value.axis] = I[f.value.offset] - (E[f.value.client] - I.getBoundingClientRect()[f.value.direction])); }, h = E => { if (!s.value || !r.value || !n.wrapElement)
        return; const x = Math.abs(E.target.getBoundingClientRect()[f.value.direction] - E[f.value.client]), I = s.value[f.value.offset] / 2, L = (x - I) * 100 * v.value / r.value[f.value.offset]; n.wrapElement[f.value.scroll] = L * n.wrapElement[f.value.scrollSize] / 100; }, g = E => { E.stopImmediatePropagation(), u = !0, document.addEventListener("mousemove", y), document.addEventListener("mouseup", C), d = document.onselectstart, document.onselectstart = () => !1; }, y = E => { if (!r.value || !s.value || u === !1)
        return; const x = l.value[f.value.axis]; if (!x)
        return; const I = (r.value.getBoundingClientRect()[f.value.direction] - E[f.value.client]) * -1, L = s.value[f.value.offset] - x, B = (I - L) * 100 * v.value / r.value[f.value.offset]; n.wrapElement[f.value.scroll] = B * n.wrapElement[f.value.scrollSize] / 100; }, C = () => { u = !1, l.value[f.value.axis] = 0, document.removeEventListener("mousemove", y), document.removeEventListener("mouseup", C), T(), c && (a.value = !1); }, b = () => { c = !1, a.value = !!t.size; }, w = () => { c = !0, a.value = u; }; on(() => { T(), document.removeEventListener("mouseup", C); }); const T = () => { document.onselectstart !== d && (document.onselectstart = d); }; return nn(an(n, "scrollbarElement"), "mousemove", b), nn(an(n, "scrollbarElement"), "mouseleave", w), (E, x) => (k(), ge(yn, { name: i(o).b("fade"), persisted: "" }, { default: ie(() => [dt(Q("div", { ref_key: "instance", ref: r, class: O([i(o).e("bar"), i(o).is(i(f).key)]), onMousedown: h }, [Q("div", { ref_key: "thumb", ref: s, class: O(i(o).e("thumb")), style: et(i(p)), onMousedown: m }, null, 38)], 34), [[Pt, E.always || a.value]])]), _: 1 }, 8, ["name"])); } });
var Qg = Fe(yD, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
const bD = Ve({ always: { type: Boolean, default: !0 }, width: String, height: String, ratioX: { type: Number, default: 1 }, ratioY: { type: Number, default: 1 } }), wD = ae({ __name: "bar", props: bD, setup(e, { expose: t }) { const n = e, o = M(0), r = M(0); return t({ handleScroll: l => { if (l) {
            const a = l.offsetHeight - al, u = l.offsetWidth - al;
            r.value = l.scrollTop * 100 / a * n.ratioY, o.value = l.scrollLeft * 100 / u * n.ratioX;
        } } }), (l, a) => (k(), z(Qe, null, [ee(Qg, { move: o.value, ratio: l.ratioX, size: l.width, always: l.always }, null, 8, ["move", "ratio", "size", "always"]), ee(Qg, { move: r.value, ratio: l.ratioY, size: l.height, vertical: "", always: l.always }, null, 8, ["move", "ratio", "size", "always"])], 64)); } });
var CD = Fe(wD, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
const SD = Ve({ height: { type: [String, Number], default: "" }, maxHeight: { type: [String, Number], default: "" }, native: { type: Boolean, default: !1 }, wrapStyle: { type: ve([String, Object, Array]), default: "" }, wrapClass: { type: [String, Array], default: "" }, viewClass: { type: [String, Array], default: "" }, viewStyle: { type: [String, Array, Object], default: "" }, noresize: Boolean, tag: { type: String, default: "div" }, always: Boolean, minSize: { type: Number, default: 20 } }), _D = { scroll: ({ scrollTop: e, scrollLeft: t }) => [e, t].every(lt) }, kD = "ElScrollbar", ED = ae({ name: kD }), $D = ae({ ...ED, props: SD, emits: _D, setup(e, { expose: t, emit: n }) { const o = e, r = Ie("scrollbar"); let s, l; const a = M(), u = M(), c = M(), d = M("0"), f = M("0"), p = M(), v = M(1), m = M(1), h = S(() => { const x = {}; return o.height && (x.height = gn(o.height)), o.maxHeight && (x.maxHeight = gn(o.maxHeight)), [o.wrapStyle, x]; }), g = S(() => [o.wrapClass, r.e("wrap"), { [r.em("wrap", "hidden-default")]: !o.native }]), y = S(() => [r.e("view"), o.viewClass]), C = () => { var x; u.value && ((x = p.value) == null || x.handleScroll(u.value), n("scroll", { scrollTop: u.value.scrollTop, scrollLeft: u.value.scrollLeft })); }; function b(x, I) { yt(x) ? u.value.scrollTo(x) : lt(x) && lt(I) && u.value.scrollTo(x, I); } const w = x => { lt(x) && (u.value.scrollTop = x); }, T = x => { lt(x) && (u.value.scrollLeft = x); }, E = () => { if (!u.value)
        return; const x = u.value.offsetHeight - al, I = u.value.offsetWidth - al, L = x ** 2 / u.value.scrollHeight, B = I ** 2 / u.value.scrollWidth, F = Math.max(L, o.minSize), V = Math.max(B, o.minSize); v.value = L / (x - L) / (F / (x - F)), m.value = B / (I - B) / (V / (I - V)), f.value = F + al < x ? `${F}px` : "", d.value = V + al < I ? `${V}px` : ""; }; return Oe(() => o.noresize, x => { x ? (s == null || s(), l == null || l()) : ({ stop: s } = Vn(c, E), l = nn("resize", E)); }, { immediate: !0 }), Oe(() => [o.maxHeight, o.height], () => { o.native || Xe(() => { var x; E(), u.value && ((x = p.value) == null || x.handleScroll(u.value)); }); }), St(Tw, Lt({ scrollbarElement: a, wrapElement: u })), ft(() => { o.native || Xe(() => { E(); }); }), Er(() => E()), t({ wrapRef: u, update: E, scrollTo: b, setScrollTop: w, setScrollLeft: T, handleScroll: C }), (x, I) => (k(), z("div", { ref_key: "scrollbarRef", ref: a, class: O(i(r).b()) }, [Q("div", { ref_key: "wrapRef", ref: u, class: O(i(g)), style: et(i(h)), onScroll: C }, [(k(), ge(kt(x.tag), { ref_key: "resizeRef", ref: c, class: O(i(y)), style: et(x.viewStyle) }, { default: ie(() => [ke(x.$slots, "default")]), _: 3 }, 8, ["class", "style"]))], 38), x.native ? pe("v-if", !0) : (k(), ge(CD, { key: 0, ref_key: "barRef", ref: p, height: f.value, width: d.value, always: x.always, "ratio-x": m.value, "ratio-y": v.value }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"]))], 2)); } });
var TD = Fe($D, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
const Or = vt(TD), Oh = Symbol("popper"), Ow = Symbol("popperContent"), OD = ["dialog", "grid", "group", "listbox", "menu", "navigation", "tooltip", "tree"], Iw = Ve({ role: { type: String, values: OD, default: "tooltip" } }), ID = ae({ name: "ElPopper", inheritAttrs: !1 }), xD = ae({ ...ID, props: Iw, setup(e, { expose: t }) { const n = e, o = M(), r = M(), s = M(), l = M(), a = S(() => n.role), u = { triggerRef: o, popperInstanceRef: r, contentRef: s, referenceRef: l, role: a }; return t(u), St(Oh, u), (c, d) => ke(c.$slots, "default"); } });
var AD = Fe(xD, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
const xw = Ve({ arrowOffset: { type: Number, default: 5 } }), MD = ae({ name: "ElPopperArrow", inheritAttrs: !1 }), ND = ae({ ...MD, props: xw, setup(e, { expose: t }) { const n = e, o = Ie("popper"), { arrowOffset: r, arrowRef: s, arrowStyle: l } = Ye(Ow, void 0); return Oe(() => n.arrowOffset, a => { r.value = a; }), on(() => { s.value = void 0; }), t({ arrowRef: s }), (a, u) => (k(), z("span", { ref_key: "arrowRef", ref: s, class: O(i(o).e("arrow")), style: et(i(l)), "data-popper-arrow": "" }, null, 6)); } });
var PD = Fe(ND, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
const RD = "ElOnlyChild", Aw = ae({ name: RD, setup(e, { slots: t, attrs: n }) { var o; const r = Ye(aw), s = C6((o = r == null ? void 0 : r.setForwardRef) != null ? o : Wt); return () => { var l; const a = (l = t.default) == null ? void 0 : l.call(t, n); if (!a || a.length > 1)
        return null; const u = Mw(a); return u ? dt(Sr(u, n), [[s]]) : null; }; } });
function Mw(e) { if (!e)
    return null; const t = e; for (const n of t) {
    if (yt(n))
        switch (n.type) {
            case Wn: continue;
            case Ul:
            case "svg": return e0(n);
            case Qe: return Mw(n.children);
            default: return n;
        }
    return e0(n);
} return null; }
function e0(e) { const t = Ie("only-child"); return ee("span", { class: t.e("content") }, [e]); }
const Nw = Ve({ virtualRef: { type: ve(Object) }, virtualTriggering: Boolean, onMouseenter: { type: ve(Function) }, onMouseleave: { type: ve(Function) }, onClick: { type: ve(Function) }, onKeydown: { type: ve(Function) }, onFocus: { type: ve(Function) }, onBlur: { type: ve(Function) }, onContextmenu: { type: ve(Function) }, id: String, open: Boolean }), LD = ae({ name: "ElPopperTrigger", inheritAttrs: !1 }), DD = ae({ ...LD, props: Nw, setup(e, { expose: t }) { const n = e, { role: o, triggerRef: r } = Ye(Oh, void 0); w6(r); const s = S(() => a.value ? n.id : void 0), l = S(() => { if (o && o.value === "tooltip")
        return n.open && n.id ? n.id : void 0; }), a = S(() => { if (o && o.value !== "tooltip")
        return o.value; }), u = S(() => a.value ? `${n.open}` : void 0); let c; return ft(() => { Oe(() => n.virtualRef, d => { d && (r.value = po(d)); }, { immediate: !0 }), Oe(r, (d, f) => { c == null || c(), c = void 0, To(d) && (["onMouseenter", "onMouseleave", "onClick", "onKeydown", "onFocus", "onBlur", "onContextmenu"].forEach(p => { var v; const m = n[p]; m && (d.addEventListener(p.slice(2).toLowerCase(), m), (v = f == null ? void 0 : f.removeEventListener) == null || v.call(f, p.slice(2).toLowerCase(), m)); }), c = Oe([s, l, a, u], p => { ["aria-controls", "aria-describedby", "aria-haspopup", "aria-expanded"].forEach((v, m) => { bn(p[m]) ? d.removeAttribute(v) : d.setAttribute(v, p[m]); }); }, { immediate: !0 })), To(f) && ["aria-controls", "aria-describedby", "aria-haspopup", "aria-expanded"].forEach(p => f.removeAttribute(p)); }, { immediate: !0 }); }), on(() => { c == null || c(), c = void 0; }), t({ triggerRef: r }), (d, f) => d.virtualTriggering ? pe("v-if", !0) : (k(), ge(i(Aw), Ct({ key: 0 }, d.$attrs, { "aria-controls": i(s), "aria-describedby": i(l), "aria-expanded": i(u), "aria-haspopup": i(a) }), { default: ie(() => [ke(d.$slots, "default")]), _: 3 }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])); } });
var BD = Fe(DD, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
const kd = "focus-trap.focus-after-trapped", Ed = "focus-trap.focus-after-released", FD = "focus-trap.focusout-prevented", t0 = { cancelable: !0, bubbles: !1 }, VD = { cancelable: !0, bubbles: !1 }, n0 = "focusAfterTrapped", o0 = "focusAfterReleased", Ih = Symbol("elFocusTrap"), xh = M(), zc = M(0), Ah = M(0);
let Ui = 0;
const Pw = e => { const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: o => { const r = o.tagName === "INPUT" && o.type === "hidden"; return o.disabled || o.hidden || r ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 || o === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; } }); for (; n.nextNode();)
    t.push(n.currentNode); return t; }, r0 = (e, t) => { for (const n of e)
    if (!zD(n, t))
        return n; }, zD = (e, t) => { if (getComputedStyle(e).visibility === "hidden")
    return !0; for (; e;) {
    if (t && e === t)
        return !1;
    if (getComputedStyle(e).display === "none")
        return !0;
    e = e.parentElement;
} return !1; }, HD = e => { const t = Pw(e), n = r0(t, e), o = r0(t.reverse(), e); return [n, o]; }, KD = e => e instanceof HTMLInputElement && "select" in e, Dr = (e, t) => { if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), Ah.value = window.performance.now(), e !== n && KD(e) && t && e.select();
} };
function s0(e, t) { const n = [...e], o = e.indexOf(t); return o !== -1 && n.splice(o, 1), n; }
const jD = () => { let e = []; return { push: o => { const r = e[0]; r && o !== r && r.pause(), e = s0(e, o), e.unshift(o); }, remove: o => { var r, s; e = s0(e, o), (s = (r = e[0]) == null ? void 0 : r.resume) == null || s.call(r); } }; }, WD = (e, t = !1) => { const n = document.activeElement; for (const o of e)
    if (Dr(o, t), document.activeElement !== n)
        return; }, l0 = jD(), UD = () => zc.value > Ah.value, qi = () => { xh.value = "pointer", zc.value = window.performance.now(); }, a0 = () => { xh.value = "keyboard", zc.value = window.performance.now(); }, qD = () => (ft(() => { Ui === 0 && (document.addEventListener("mousedown", qi), document.addEventListener("touchstart", qi), document.addEventListener("keydown", a0)), Ui++; }), on(() => { Ui--, Ui <= 0 && (document.removeEventListener("mousedown", qi), document.removeEventListener("touchstart", qi), document.removeEventListener("keydown", a0)); }), { focusReason: xh, lastUserFocusTimestamp: zc, lastAutomatedFocusTimestamp: Ah }), Yi = e => new CustomEvent(FD, { ...VD, detail: e }), YD = ae({ name: "ElFocusTrap", inheritAttrs: !1, props: { loop: Boolean, trapped: Boolean, focusTrapEl: Object, focusStartEl: { type: [Object, String], default: "first" } }, emits: [n0, o0, "focusin", "focusout", "focusout-prevented", "release-requested"], setup(e, { emit: t }) { const n = M(); let o, r; const { focusReason: s } = qD(); m6(m => { e.trapped && !l.paused && t("release-requested", m); }); const l = { paused: !1, pause() { this.paused = !0; }, resume() { this.paused = !1; } }, a = m => { if (!e.loop && !e.trapped || l.paused)
        return; const { key: h, altKey: g, ctrlKey: y, metaKey: C, currentTarget: b, shiftKey: w } = m, { loop: T } = e, E = h === tt.tab && !g && !y && !C, x = document.activeElement; if (E && x) {
        const I = b, [L, B] = HD(I);
        if (L && B) {
            if (!w && x === B) {
                const V = Yi({ focusReason: s.value });
                t("focusout-prevented", V), V.defaultPrevented || (m.preventDefault(), T && Dr(L, !0));
            }
            else if (w && [L, I].includes(x)) {
                const V = Yi({ focusReason: s.value });
                t("focusout-prevented", V), V.defaultPrevented || (m.preventDefault(), T && Dr(B, !0));
            }
        }
        else if (x === I) {
            const V = Yi({ focusReason: s.value });
            t("focusout-prevented", V), V.defaultPrevented || m.preventDefault();
        }
    } }; St(Ih, { focusTrapRef: n, onKeydown: a }), Oe(() => e.focusTrapEl, m => { m && (n.value = m); }, { immediate: !0 }), Oe([n], ([m], [h]) => { m && (m.addEventListener("keydown", a), m.addEventListener("focusin", d), m.addEventListener("focusout", f)), h && (h.removeEventListener("keydown", a), h.removeEventListener("focusin", d), h.removeEventListener("focusout", f)); }); const u = m => { t(n0, m); }, c = m => t(o0, m), d = m => { const h = i(n); if (!h)
        return; const g = m.target, y = m.relatedTarget, C = g && h.contains(g); e.trapped || y && h.contains(y) || (o = y), C && t("focusin", m), !l.paused && e.trapped && (C ? r = g : Dr(r, !0)); }, f = m => { const h = i(n); if (!(l.paused || !h))
        if (e.trapped) {
            const g = m.relatedTarget;
            !bn(g) && !h.contains(g) && setTimeout(() => { if (!l.paused && e.trapped) {
                const y = Yi({ focusReason: s.value });
                t("focusout-prevented", y), y.defaultPrevented || Dr(r, !0);
            } }, 0);
        }
        else {
            const g = m.target;
            g && h.contains(g) || t("focusout", m);
        } }; async function p() { await Xe(); const m = i(n); if (m) {
        l0.push(l);
        const h = m.contains(document.activeElement) ? o : document.activeElement;
        if (o = h, !m.contains(h)) {
            const y = new Event(kd, t0);
            m.addEventListener(kd, u), m.dispatchEvent(y), y.defaultPrevented || Xe(() => { let C = e.focusStartEl; it(C) || (Dr(C), document.activeElement !== C && (C = "first")), C === "first" && WD(Pw(m), !0), (document.activeElement === h || C === "container") && Dr(m); });
        }
    } } function v() { const m = i(n); if (m) {
        m.removeEventListener(kd, u);
        const h = new CustomEvent(Ed, { ...t0, detail: { focusReason: s.value } });
        m.addEventListener(Ed, c), m.dispatchEvent(h), !h.defaultPrevented && (s.value == "keyboard" || !UD() || m.contains(document.activeElement)) && Dr(o ?? document.body), m.removeEventListener(Ed, u), l0.remove(l);
    } } return ft(() => { e.trapped && p(), Oe(() => e.trapped, m => { m ? p() : v(); }); }), on(() => { e.trapped && v(); }), { onKeydown: a }; } });
function GD(e, t, n, o, r, s) { return ke(e.$slots, "default", { handleKeydown: e.onKeydown }); }
var Hc = Fe(YD, [["render", GD], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
const XD = ["fixed", "absolute"], JD = Ve({ boundariesPadding: { type: Number, default: 0 }, fallbackPlacements: { type: ve(Array), default: void 0 }, gpuAcceleration: { type: Boolean, default: !0 }, offset: { type: Number, default: 12 }, placement: { type: String, values: Ys, default: "bottom" }, popperOptions: { type: ve(Object), default: () => ({}) }, strategy: { type: String, values: XD, default: "absolute" } }), Rw = Ve({ ...JD, id: String, style: { type: ve([String, Array, Object]) }, className: { type: ve([String, Array, Object]) }, effect: { type: String, default: "dark" }, visible: Boolean, enterable: { type: Boolean, default: !0 }, pure: Boolean, focusOnShow: { type: Boolean, default: !1 }, trapping: { type: Boolean, default: !1 }, popperClass: { type: ve([String, Array, Object]) }, popperStyle: { type: ve([String, Array, Object]) }, referenceEl: { type: ve(Object) }, triggerTargetEl: { type: ve(Object) }, stopPopperMouseEvent: { type: Boolean, default: !0 }, ariaLabel: { type: String, default: void 0 }, virtualTriggering: Boolean, zIndex: Number }), ZD = { mouseenter: e => e instanceof MouseEvent, mouseleave: e => e instanceof MouseEvent, focus: () => !0, blur: () => !0, close: () => !0 }, QD = (e, t = []) => { const { placement: n, strategy: o, popperOptions: r } = e, s = { placement: n, strategy: o, ...r, modifiers: [...tB(e), ...t] }; return nB(s, r == null ? void 0 : r.modifiers), s; }, eB = e => { if (At)
    return po(e); };
function tB(e) { const { offset: t, gpuAcceleration: n, fallbackPlacements: o } = e; return [{ name: "offset", options: { offset: [0, t ?? 12] } }, { name: "preventOverflow", options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } } }, { name: "flip", options: { padding: 5, fallbackPlacements: o } }, { name: "computeStyles", options: { gpuAcceleration: n } }]; }
function nB(e, t) { t && (e.modifiers = [...e.modifiers, ...t ?? []]); }
const oB = 0, rB = e => { const { popperInstanceRef: t, contentRef: n, triggerRef: o, role: r } = Ye(Oh, void 0), s = M(), l = M(), a = S(() => ({ name: "eventListeners", enabled: !!e.visible })), u = S(() => { var y; const C = i(s), b = (y = i(l)) != null ? y : oB; return { name: "arrow", enabled: !aM(C), options: { element: C, padding: b } }; }), c = S(() => ({ onFirstUpdate: () => { m(); }, ...QD(e, [i(u), i(a)]) })), d = S(() => eB(e.referenceEl) || i(o)), { attributes: f, state: p, styles: v, update: m, forceUpdate: h, instanceRef: g } = f6(d, n, c); return Oe(g, y => t.value = y), ft(() => { Oe(() => { var y; return (y = i(d)) == null ? void 0 : y.getBoundingClientRect(); }, () => { m(); }); }), { attributes: f, arrowRef: s, contentRef: n, instanceRef: g, state: p, styles: v, role: r, forceUpdate: h, update: m }; }, sB = (e, { attributes: t, styles: n, role: o }) => { const { nextZIndex: r } = Gl(), s = Ie("popper"), l = S(() => i(t).popper), a = M(e.zIndex || r()), u = S(() => [s.b(), s.is("pure", e.pure), s.is(e.effect), e.popperClass]), c = S(() => [{ zIndex: i(a) }, i(n).popper, e.popperStyle || {}]), d = S(() => o.value === "dialog" ? "false" : void 0), f = S(() => i(n).arrow || {}); return { ariaModal: d, arrowStyle: f, contentAttrs: l, contentClass: u, contentStyle: c, contentZIndex: a, updateZIndex: () => { a.value = e.zIndex || r(); } }; }, lB = (e, t) => { const n = M(!1), o = M(); return { focusStartRef: o, trapped: n, onFocusAfterReleased: c => { var d; ((d = c.detail) == null ? void 0 : d.focusReason) !== "pointer" && (o.value = "first", t("blur")); }, onFocusAfterTrapped: () => { t("focus"); }, onFocusInTrap: c => { e.visible && !n.value && (c.target && (o.value = c.target), n.value = !0); }, onFocusoutPrevented: c => { e.trapping || (c.detail.focusReason === "pointer" && c.preventDefault(), n.value = !1); }, onReleaseRequested: () => { n.value = !1, t("close"); } }; }, aB = ae({ name: "ElPopperContent" }), iB = ae({ ...aB, props: Rw, emits: ZD, setup(e, { expose: t, emit: n }) { const o = e, { focusStartRef: r, trapped: s, onFocusAfterReleased: l, onFocusAfterTrapped: a, onFocusInTrap: u, onFocusoutPrevented: c, onReleaseRequested: d } = lB(o, n), { attributes: f, arrowRef: p, contentRef: v, styles: m, instanceRef: h, role: g, update: y } = rB(o), { ariaModal: C, arrowStyle: b, contentAttrs: w, contentClass: T, contentStyle: E, updateZIndex: x } = sB(o, { styles: m, attributes: f, role: g }), I = Ye(rr, void 0), L = M(); St(Ow, { arrowStyle: b, arrowRef: p, arrowOffset: L }), I && (I.addInputId || I.removeInputId) && St(rr, { ...I, addInputId: Wt, removeInputId: Wt }); let B; const F = (R = !0) => { y(), R && x(); }, V = () => { F(!1), o.visible && o.focusOnShow ? s.value = !0 : o.visible === !1 && (s.value = !1); }; return ft(() => { Oe(() => o.triggerTargetEl, (R, K) => { B == null || B(), B = void 0; const te = i(R || v.value), U = i(K || v.value); To(te) && (B = Oe([g, () => o.ariaLabel, C, () => o.id], D => { ["role", "aria-label", "aria-modal", "id"].forEach((j, A) => { bn(D[A]) ? te.removeAttribute(j) : te.setAttribute(j, D[A]); }); }, { immediate: !0 })), U !== te && To(U) && ["role", "aria-label", "aria-modal", "id"].forEach(D => { U.removeAttribute(D); }); }, { immediate: !0 }), Oe(() => o.visible, V, { immediate: !0 }); }), on(() => { B == null || B(), B = void 0; }), t({ popperContentRef: v, popperInstanceRef: h, updatePopper: F, contentStyle: E }), (R, K) => (k(), z("div", Ct({ ref_key: "contentRef", ref: v }, i(w), { style: i(E), class: i(T), tabindex: "-1", onMouseenter: K[0] || (K[0] = te => R.$emit("mouseenter", te)), onMouseleave: K[1] || (K[1] = te => R.$emit("mouseleave", te)) }), [ee(i(Hc), { trapped: i(s), "trap-on-focus-in": !0, "focus-trap-el": i(v), "focus-start-el": i(r), onFocusAfterTrapped: i(a), onFocusAfterReleased: i(l), onFocusin: i(u), onFocusoutPrevented: i(c), onReleaseRequested: i(d) }, { default: ie(() => [ke(R.$slots, "default")]), _: 3 }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])], 16)); } });
var uB = Fe(iB, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
const Lw = vt(AD), Kc = Symbol("elTooltip"), On = Ve({ ...b6, ...Rw, appendTo: { type: ve([String, Object]) }, content: { type: String, default: "" }, rawContent: { type: Boolean, default: !1 }, persistent: Boolean, ariaLabel: String, visible: { type: ve(Boolean), default: null }, transition: String, teleported: { type: Boolean, default: !0 }, disabled: Boolean }), oi = Ve({ ...Nw, disabled: Boolean, trigger: { type: ve([String, Array]), default: "hover" }, triggerKeys: { type: ve(Array), default: () => [tt.enter, tt.space] } }), { useModelToggleProps: cB, useModelToggleEmits: dB, useModelToggle: fB } = j1("visible"), pB = Ve({ ...Iw, ...cB, ...On, ...oi, ...xw, showArrow: { type: Boolean, default: !0 } }), hB = [...dB, "before-show", "before-hide", "show", "hide", "open", "close"], vB = (e, t) => qe(e) ? e.includes(t) : e === t, Qs = (e, t, n) => o => { vB(i(e), t) && n(o); }, mB = ae({ name: "ElTooltipTrigger" }), gB = ae({ ...mB, props: oi, setup(e, { expose: t }) { const n = e, o = Ie("tooltip"), { controlled: r, id: s, open: l, onOpen: a, onClose: u, onToggle: c } = Ye(Kc, void 0), d = M(null), f = () => { if (i(r) || n.disabled)
        return !0; }, p = an(n, "trigger"), v = fn(f, Qs(p, "hover", a)), m = fn(f, Qs(p, "hover", u)), h = fn(f, Qs(p, "click", w => { w.button === 0 && c(w); })), g = fn(f, Qs(p, "focus", a)), y = fn(f, Qs(p, "focus", u)), C = fn(f, Qs(p, "contextmenu", w => { w.preventDefault(), c(w); })), b = fn(f, w => { const { code: T } = w; n.triggerKeys.includes(T) && (w.preventDefault(), c(w)); }); return t({ triggerRef: d }), (w, T) => (k(), ge(i(BD), { id: i(s), "virtual-ref": w.virtualRef, open: i(l), "virtual-triggering": w.virtualTriggering, class: O(i(o).e("trigger")), onBlur: i(y), onClick: i(h), onContextmenu: i(C), onFocus: i(g), onMouseenter: i(v), onMouseleave: i(m), onKeydown: i(b) }, { default: ie(() => [ke(w.$slots, "default")]), _: 3 }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"])); } });
var yB = Fe(gB, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
const bB = ae({ name: "ElTooltipContent", inheritAttrs: !1 }), wB = ae({ ...bB, props: On, setup(e, { expose: t }) { const n = e, { selector: o } = sw(), r = Ie("tooltip"), s = M(null), l = M(!1), { controlled: a, id: u, open: c, trigger: d, onClose: f, onOpen: p, onShow: v, onHide: m, onBeforeShow: h, onBeforeHide: g } = Ye(Kc, void 0), y = S(() => n.transition || `${r.namespace.value}-fade-in-linear`), C = S(() => n.persistent); on(() => { l.value = !0; }); const b = S(() => i(C) ? !0 : i(c)), w = S(() => n.disabled ? !1 : i(c)), T = S(() => n.appendTo || o.value), E = S(() => { var D; return (D = n.style) != null ? D : {}; }), x = S(() => !i(c)), I = () => { m(); }, L = () => { if (i(a))
        return !0; }, B = fn(L, () => { n.enterable && i(d) === "hover" && p(); }), F = fn(L, () => { i(d) === "hover" && f(); }), V = () => { var D, j; (j = (D = s.value) == null ? void 0 : D.updatePopper) == null || j.call(D), h == null || h(); }, R = () => { g == null || g(); }, K = () => { v(), U = Kp(S(() => { var D; return (D = s.value) == null ? void 0 : D.popperContentRef; }), () => { if (i(a))
        return; i(d) !== "hover" && f(); }); }, te = () => { n.virtualTriggering || f(); }; let U; return Oe(() => i(c), D => { D || U == null || U(); }, { flush: "post" }), Oe(() => n.content, () => { var D, j; (j = (D = s.value) == null ? void 0 : D.updatePopper) == null || j.call(D); }), t({ contentRef: s }), (D, j) => (k(), ge(mi, { disabled: !D.teleported, to: i(T) }, [ee(yn, { name: i(y), onAfterLeave: I, onBeforeEnter: V, onAfterEnter: K, onBeforeLeave: R }, { default: ie(() => [i(b) ? dt((k(), ge(i(uB), Ct({ key: 0, id: i(u), ref_key: "contentRef", ref: s }, D.$attrs, { "aria-label": D.ariaLabel, "aria-hidden": i(x), "boundaries-padding": D.boundariesPadding, "fallback-placements": D.fallbackPlacements, "gpu-acceleration": D.gpuAcceleration, offset: D.offset, placement: D.placement, "popper-options": D.popperOptions, strategy: D.strategy, effect: D.effect, enterable: D.enterable, pure: D.pure, "popper-class": D.popperClass, "popper-style": [D.popperStyle, i(E)], "reference-el": D.referenceEl, "trigger-target-el": D.triggerTargetEl, visible: i(w), "z-index": D.zIndex, onMouseenter: i(B), onMouseleave: i(F), onBlur: te, onClose: i(f) }), { default: ie(() => [l.value ? pe("v-if", !0) : ke(D.$slots, "default", { key: 0 })]), _: 3 }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [[Pt, i(w)]]) : pe("v-if", !0)]), _: 3 }, 8, ["name"])], 8, ["disabled", "to"])); } });
var CB = Fe(wB, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
const SB = ["innerHTML"], _B = { key: 1 }, kB = ae({ name: "ElTooltip" }), EB = ae({ ...kB, props: pB, emits: hB, setup(e, { expose: t, emit: n }) { const o = e; y6(); const r = xo(), s = M(), l = M(), a = () => { var y; const C = i(s); C && ((y = C.popperInstanceRef) == null || y.update()); }, u = M(!1), c = M(), { show: d, hide: f, hasUpdateHandler: p } = fB({ indicator: u, toggleReason: c }), { onOpen: v, onClose: m } = lw({ showAfter: an(o, "showAfter"), hideAfter: an(o, "hideAfter"), autoClose: an(o, "autoClose"), open: d, close: f }), h = S(() => wn(o.visible) && !p.value); St(Kc, { controlled: h, id: r, open: Wl(u), trigger: an(o, "trigger"), onOpen: y => { v(y); }, onClose: y => { m(y); }, onToggle: y => { i(u) ? m(y) : v(y); }, onShow: () => { n("show", c.value); }, onHide: () => { n("hide", c.value); }, onBeforeShow: () => { n("before-show", c.value); }, onBeforeHide: () => { n("before-hide", c.value); }, updatePopper: a }), Oe(() => o.disabled, y => { y && u.value && (u.value = !1); }); const g = () => { var y, C; const b = (C = (y = l.value) == null ? void 0 : y.contentRef) == null ? void 0 : C.popperContentRef; return b && b.contains(document.activeElement); }; return Xy(() => u.value && f()), t({ popperRef: s, contentRef: l, isFocusInsideContent: g, updatePopper: a, onOpen: v, onClose: m, hide: f }), (y, C) => (k(), ge(i(Lw), { ref_key: "popperRef", ref: s, role: y.role }, { default: ie(() => [ee(yB, { disabled: y.disabled, trigger: y.trigger, "trigger-keys": y.triggerKeys, "virtual-ref": y.virtualRef, "virtual-triggering": y.virtualTriggering }, { default: ie(() => [y.$slots.default ? ke(y.$slots, "default", { key: 0 }) : pe("v-if", !0)]), _: 3 }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]), ee(CB, { ref_key: "contentRef", ref: l, "aria-label": y.ariaLabel, "boundaries-padding": y.boundariesPadding, content: y.content, disabled: y.disabled, effect: y.effect, enterable: y.enterable, "fallback-placements": y.fallbackPlacements, "hide-after": y.hideAfter, "gpu-acceleration": y.gpuAcceleration, offset: y.offset, persistent: y.persistent, "popper-class": y.popperClass, "popper-style": y.popperStyle, placement: y.placement, "popper-options": y.popperOptions, pure: y.pure, "raw-content": y.rawContent, "reference-el": y.referenceEl, "trigger-target-el": y.triggerTargetEl, "show-after": y.showAfter, strategy: y.strategy, teleported: y.teleported, transition: y.transition, "virtual-triggering": y.virtualTriggering, "z-index": y.zIndex, "append-to": y.appendTo }, { default: ie(() => [ke(y.$slots, "content", {}, () => [y.rawContent ? (k(), z("span", { key: 0, innerHTML: y.content }, null, 8, SB)) : (k(), z("span", _B, Be(y.content), 1))]), y.showArrow ? (k(), ge(i(PD), { key: 0, "arrow-offset": y.arrowOffset }, null, 8, ["arrow-offset"])) : pe("v-if", !0)]), _: 3 }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])]), _: 3 }, 8, ["role"])); } });
var $B = Fe(EB, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
const Jn = vt($B), TB = Ve({ valueKey: { type: String, default: "value" }, modelValue: { type: [String, Number], default: "" }, debounce: { type: Number, default: 300 }, placement: { type: ve(String), values: ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end"], default: "bottom-start" }, fetchSuggestions: { type: ve([Function, Array]), default: Wt }, popperClass: { type: String, default: "" }, triggerOnFocus: { type: Boolean, default: !0 }, selectWhenUnmatched: { type: Boolean, default: !1 }, hideLoading: { type: Boolean, default: !1 }, label: { type: String }, teleported: On.teleported, highlightFirstItem: { type: Boolean, default: !1 }, fitInputWidth: { type: Boolean, default: !1 }, clearable: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, name: String }), OB = { [gt]: e => it(e), [qn]: e => it(e), [en]: e => it(e), focus: e => e instanceof FocusEvent, blur: e => e instanceof FocusEvent, clear: () => !0, select: e => yt(e) }, IB = ["aria-expanded", "aria-owns"], xB = { key: 0 }, AB = ["id", "aria-selected", "onClick"], Dw = "ElAutocomplete", MB = ae({ name: Dw, inheritAttrs: !1 }), NB = ae({ ...MB, props: TB, emits: OB, setup(e, { expose: t, emit: n }) { const o = e, r = dh(), s = js(), l = uo(), a = Ie("autocomplete"), u = M(), c = M(), d = M(), f = M(); let p = !1, v = !1; const m = M([]), h = M(-1), g = M(""), y = M(!1), C = M(!1), b = M(!1), w = S(() => a.b(String(Rc()))), T = S(() => s.style), E = S(() => (m.value.length > 0 || b.value) && y.value), x = S(() => !o.hideLoading && b.value), I = S(() => u.value ? Array.from(u.value.$el.querySelectorAll("input")) : []), L = async () => { await Xe(), E.value && (g.value = `${u.value.$el.offsetWidth}px`); }, B = () => { h.value = -1; }, V = Xn(async (me) => { if (C.value)
        return; const le = oe => { b.value = !1, !C.value && (qe(oe) ? (m.value = oe, h.value = o.highlightFirstItem ? 0 : -1) : _n(Dw, "autocomplete suggestions must be an array")); }; if (b.value = !0, qe(o.fetchSuggestions))
        le(o.fetchSuggestions);
    else {
        const oe = await o.fetchSuggestions(me, le);
        qe(oe) && le(oe);
    } }, o.debounce), R = me => { const le = !!me; if (n(qn, me), n(gt, me), C.value = !1, y.value || (y.value = le), !o.triggerOnFocus && !me) {
        C.value = !0, m.value = [];
        return;
    } V(me); }, K = me => { var le; l.value || (((le = me.target) == null ? void 0 : le.tagName) !== "INPUT" || I.value.includes(document.activeElement)) && (y.value = !0); }, te = me => { n(en, me); }, U = me => { v ? v = !1 : (y.value = !0, n("focus", me), o.triggerOnFocus && !p && V(String(o.modelValue))); }, D = me => { setTimeout(() => { var le; if ((le = d.value) != null && le.isFocusInsideContent()) {
        v = !0;
        return;
    } y.value && se(), n("blur", me); }); }, j = () => { y.value = !1, n(gt, ""), n("clear"); }, A = async () => { E.value && h.value >= 0 && h.value < m.value.length ? ye(m.value[h.value]) : o.selectWhenUnmatched && (n("select", { value: o.modelValue }), m.value = [], h.value = -1); }, G = me => { E.value && (me.preventDefault(), me.stopPropagation(), se()); }, se = () => { y.value = !1; }, Z = () => { var me; (me = u.value) == null || me.focus(); }, ce = () => { var me; (me = u.value) == null || me.blur(); }, ye = async (me) => { n(qn, me[o.valueKey]), n(gt, me[o.valueKey]), n("select", me), m.value = [], h.value = -1; }, Re = me => { if (!E.value || b.value)
        return; if (me < 0) {
        h.value = -1;
        return;
    } me >= m.value.length && (me = m.value.length - 1); const le = c.value.querySelector(`.${a.be("suggestion", "wrap")}`), fe = le.querySelectorAll(`.${a.be("suggestion", "list")} li`)[me], Ce = le.scrollTop, { offsetTop: Ae, scrollHeight: q } = fe; Ae + q > Ce + le.clientHeight && (le.scrollTop += q), Ae < Ce && (le.scrollTop -= q), h.value = me, u.value.ref.setAttribute("aria-activedescendant", `${w.value}-item-${h.value}`); }; return Kp(f, () => { E.value && se(); }), ft(() => { u.value.ref.setAttribute("role", "textbox"), u.value.ref.setAttribute("aria-autocomplete", "list"), u.value.ref.setAttribute("aria-controls", "id"), u.value.ref.setAttribute("aria-activedescendant", `${w.value}-item-${h.value}`), p = u.value.ref.hasAttribute("readonly"); }), t({ highlightedIndex: h, activated: y, loading: b, inputRef: u, popperRef: d, suggestions: m, handleSelect: ye, handleKeyEnter: A, focus: Z, blur: ce, close: se, highlight: Re }), (me, le) => (k(), ge(i(Jn), { ref_key: "popperRef", ref: d, visible: i(E), placement: me.placement, "fallback-placements": ["bottom-start", "top-start"], "popper-class": [i(a).e("popper"), me.popperClass], teleported: me.teleported, "gpu-acceleration": !1, pure: "", "manual-mode": "", effect: "light", trigger: "click", transition: `${i(a).namespace.value}-zoom-in-top`, persistent: "", onBeforeShow: L, onHide: B }, { content: ie(() => [Q("div", { ref_key: "regionRef", ref: c, class: O([i(a).b("suggestion"), i(a).is("loading", i(x))]), style: et({ [me.fitInputWidth ? "width" : "minWidth"]: g.value, outline: "none" }), role: "region" }, [ee(i(Or), { id: i(w), tag: "ul", "wrap-class": i(a).be("suggestion", "wrap"), "view-class": i(a).be("suggestion", "list"), role: "listbox" }, { default: ie(() => [i(x) ? (k(), z("li", xB, [ee(i(Je), { class: O(i(a).is("loading")) }, { default: ie(() => [ee(i(as))]), _: 1 }, 8, ["class"])])) : (k(!0), z(Qe, { key: 1 }, Et(m.value, (oe, fe) => (k(), z("li", { id: `${i(w)}-item-${fe}`, key: fe, class: O({ highlighted: h.value === fe }), role: "option", "aria-selected": h.value === fe, onClick: Ce => ye(oe) }, [ke(me.$slots, "default", { item: oe }, () => [Ot(Be(oe[me.valueKey]), 1)])], 10, AB))), 128))]), _: 3 }, 8, ["id", "wrap-class", "view-class"])], 6)]), default: ie(() => [Q("div", { ref_key: "listboxRef", ref: f, class: O([i(a).b(), me.$attrs.class]), style: et(i(T)), role: "combobox", "aria-haspopup": "listbox", "aria-expanded": i(E), "aria-owns": i(w) }, [ee(i(Ln), Ct({ ref_key: "inputRef", ref: u }, i(r), { clearable: me.clearable, disabled: i(l), name: me.name, "model-value": me.modelValue, onInput: R, onChange: te, onFocus: U, onBlur: D, onClear: j, onKeydown: [le[0] || (le[0] = Mt(st(oe => Re(h.value - 1), ["prevent"]), ["up"])), le[1] || (le[1] = Mt(st(oe => Re(h.value + 1), ["prevent"]), ["down"])), Mt(A, ["enter"]), Mt(se, ["tab"]), Mt(G, ["esc"])], onMousedown: K }), Cr({ _: 2 }, [me.$slots.prepend ? { name: "prepend", fn: ie(() => [ke(me.$slots, "prepend")]) } : void 0, me.$slots.append ? { name: "append", fn: ie(() => [ke(me.$slots, "append")]) } : void 0, me.$slots.prefix ? { name: "prefix", fn: ie(() => [ke(me.$slots, "prefix")]) } : void 0, me.$slots.suffix ? { name: "suffix", fn: ie(() => [ke(me.$slots, "suffix")]) } : void 0]), 1040, ["clearable", "disabled", "name", "model-value", "onKeydown"])], 14, IB)]), _: 3 }, 8, ["visible", "placement", "popper-class", "teleported", "transition"])); } });
var PB = Fe(NB, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/autocomplete/src/autocomplete.vue"]]);
const RB = vt(PB), LB = Ve({ size: { type: [Number, String], values: sr, default: "", validator: e => lt(e) }, shape: { type: String, values: ["circle", "square"], default: "circle" }, icon: { type: Zt }, src: { type: String, default: "" }, alt: String, srcSet: String, fit: { type: ve(String), default: "cover" } }), DB = { error: e => e instanceof Event }, BB = ["src", "alt", "srcset"], FB = ae({ name: "ElAvatar" }), VB = ae({ ...FB, props: LB, emits: DB, setup(e, { emit: t }) { const n = e, o = Ie("avatar"), r = M(!1), s = S(() => { const { size: c, icon: d, shape: f } = n, p = [o.b()]; return it(c) && p.push(o.m(c)), d && p.push(o.m("icon")), f && p.push(o.m(f)), p; }), l = S(() => { const { size: c } = n; return lt(c) ? o.cssVarBlock({ size: gn(c) || "" }) : void 0; }), a = S(() => ({ objectFit: n.fit })); Oe(() => n.src, () => r.value = !1); function u(c) { r.value = !0, t("error", c); } return (c, d) => (k(), z("span", { class: O(i(s)), style: et(i(l)) }, [(c.src || c.srcSet) && !r.value ? (k(), z("img", { key: 0, src: c.src, alt: c.alt, srcset: c.srcSet, style: et(i(a)), onError: u }, null, 44, BB)) : c.icon ? (k(), ge(i(Je), { key: 1 }, { default: ie(() => [(k(), ge(kt(c.icon)))]), _: 1 })) : ke(c.$slots, "default", { key: 2 })], 6)); } });
var zB = Fe(VB, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/avatar/src/avatar.vue"]]);
const HB = vt(zB), KB = { visibilityHeight: { type: Number, default: 200 }, target: { type: String, default: "" }, right: { type: Number, default: 40 }, bottom: { type: Number, default: 40 } }, jB = { click: e => e instanceof MouseEvent }, WB = (e, t, n) => { const o = Xt(), r = Xt(), s = M(!1), l = () => { o.value && (s.value = o.value.scrollTop >= e.visibilityHeight); }, a = c => { var d; (d = o.value) == null || d.scrollTo({ top: 0, behavior: "smooth" }), t("click", c); }, u = jb(l, 300, !0); return nn(r, "scroll", u), ft(() => { var c; r.value = document, o.value = document.documentElement, e.target && (o.value = (c = document.querySelector(e.target)) != null ? c : void 0, o.value || _n(n, `target does not exist: ${e.target}`), r.value = o.value), l(); }), { visible: s, handleClick: a }; }, Bw = "ElBacktop", UB = ae({ name: Bw }), qB = ae({ ...UB, props: KB, emits: jB, setup(e, { emit: t }) { const n = e, o = Ie("backtop"), { handleClick: r, visible: s } = WB(n, t, Bw), l = S(() => ({ right: `${n.right}px`, bottom: `${n.bottom}px` })); return (a, u) => (k(), ge(yn, { name: `${i(o).namespace.value}-fade-in` }, { default: ie(() => [i(s) ? (k(), z("div", { key: 0, style: et(i(l)), class: O(i(o).b()), onClick: u[0] || (u[0] = st((...c) => i(r) && i(r)(...c), ["stop"])) }, [ke(a.$slots, "default", {}, () => [ee(i(Je), { class: O(i(o).e("icon")) }, { default: ie(() => [ee(i(h4))]), _: 1 }, 8, ["class"])])], 6)) : pe("v-if", !0)]), _: 3 }, 8, ["name"])); } });
var YB = Fe(qB, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/backtop/src/backtop.vue"]]);
const GB = vt(YB), XB = Ve({ value: { type: [String, Number], default: "" }, max: { type: Number, default: 99 }, isDot: Boolean, hidden: Boolean, type: { type: String, values: ["primary", "success", "warning", "info", "danger"], default: "danger" } }), JB = ["textContent"], ZB = ae({ name: "ElBadge" }), QB = ae({ ...ZB, props: XB, setup(e, { expose: t }) { const n = e, o = Ie("badge"), r = S(() => n.isDot ? "" : lt(n.value) && lt(n.max) ? n.max < n.value ? `${n.max}+` : `${n.value}` : `${n.value}`); return t({ content: r }), (s, l) => (k(), z("div", { class: O(i(o).b()) }, [ke(s.$slots, "default"), ee(yn, { name: `${i(o).namespace.value}-zoom-in-center`, persisted: "" }, { default: ie(() => [dt(Q("sup", { class: O([i(o).e("content"), i(o).em("content", s.type), i(o).is("fixed", !!s.$slots.default), i(o).is("dot", s.isDot)]), textContent: Be(i(r)) }, null, 10, JB), [[Pt, !s.hidden && (i(r) || s.isDot)]])]), _: 1 }, 8, ["name"])], 2)); } });
var eF = Fe(QB, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);
const Fw = vt(eF), Vw = Symbol("breadcrumbKey"), tF = Ve({ separator: { type: String, default: "/" }, separatorIcon: { type: Zt } }), nF = ae({ name: "ElBreadcrumb" }), oF = ae({ ...nF, props: tF, setup(e) { const t = e, n = Ie("breadcrumb"), o = M(); return St(Vw, t), ft(() => { const r = o.value.querySelectorAll(`.${n.e("item")}`); r.length && r[r.length - 1].setAttribute("aria-current", "page"); }), (r, s) => (k(), z("div", { ref_key: "breadcrumb", ref: o, class: O(i(n).b()), "aria-label": "Breadcrumb", role: "navigation" }, [ke(r.$slots, "default")], 2)); } });
var rF = Fe(oF, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb.vue"]]);
const sF = Ve({ to: { type: ve([String, Object]), default: "" }, replace: { type: Boolean, default: !1 } }), lF = ae({ name: "ElBreadcrumbItem" }), aF = ae({ ...lF, props: sF, setup(e) { const t = e, n = ht(), o = Ye(Vw, void 0), r = Ie("breadcrumb"), { separator: s, separatorIcon: l } = Sn(o), a = n.appContext.config.globalProperties.$router, u = M(), c = () => { !t.to || !a || (t.replace ? a.replace(t.to) : a.push(t.to)); }; return (d, f) => (k(), z("span", { class: O(i(r).e("item")) }, [Q("span", { ref_key: "link", ref: u, class: O([i(r).e("inner"), i(r).is("link", !!d.to)]), role: "link", onClick: c }, [ke(d.$slots, "default")], 2), i(l) ? (k(), ge(i(Je), { key: 0, class: O(i(r).e("separator")) }, { default: ie(() => [(k(), ge(kt(i(l))))]), _: 1 }, 8, ["class"])) : (k(), z("span", { key: 1, class: O(i(r).e("separator")), role: "presentation" }, Be(i(s)), 3))], 2)); } });
var zw = Fe(aF, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb-item.vue"]]);
const iF = vt(rF, { BreadcrumbItem: zw }), uF = pn(zw), Hw = Symbol("buttonGroupContextKey"), cF = (e, t) => { tr({ from: "type.text", replacement: "link", version: "3.0.0", scope: "props", ref: "https://element-plus.org/en-US/component/button.html#button-attributes" }, S(() => e.type === "text")); const n = Ye(Hw, void 0), o = Fc("button"), { form: r } = Zn(), s = kn(S(() => n == null ? void 0 : n.size)), l = uo(), a = M(), u = An(), c = S(() => e.type || (n == null ? void 0 : n.type) || ""), d = S(() => { var m, h, g; return (g = (h = e.autoInsertSpace) != null ? h : (m = o.value) == null ? void 0 : m.autoInsertSpace) != null ? g : !1; }), f = S(() => e.tag === "button" ? { ariaDisabled: l.value || e.loading, disabled: l.value || e.loading, autofocus: e.autofocus, type: e.nativeType } : {}), p = S(() => { var m; const h = (m = u.default) == null ? void 0 : m.call(u); if (d.value && (h == null ? void 0 : h.length) === 1) {
    const g = h[0];
    if ((g == null ? void 0 : g.type) === Ul) {
        const y = g.children;
        return /^\p{Unified_Ideograph}{2}$/u.test(y.trim());
    }
} return !1; }); return { _disabled: l, _size: s, _type: c, _ref: a, _props: f, shouldAddSpace: p, handleClick: m => { e.nativeType === "reset" && (r == null || r.resetFields()), t("click", m); } }; }, kf = ["default", "primary", "success", "warning", "info", "danger", "text", ""], dF = ["button", "submit", "reset"], Ef = Ve({ size: Bn, disabled: Boolean, type: { type: String, values: kf, default: "" }, icon: { type: Zt }, nativeType: { type: String, values: dF, default: "button" }, loading: Boolean, loadingIcon: { type: Zt, default: () => as }, plain: Boolean, text: Boolean, link: Boolean, bg: Boolean, autofocus: Boolean, round: Boolean, circle: Boolean, color: String, dark: Boolean, autoInsertSpace: { type: Boolean, default: void 0 }, tag: { type: ve([String, Object]), default: "button" } }), fF = { click: e => e instanceof MouseEvent };
function Dn(e, t) { pF(e) && (e = "100%"); var n = hF(e); return e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e))), n && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? e = (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e = e % t / parseFloat(String(t)), e); }
function Gi(e) { return Math.min(1, Math.max(0, e)); }
function pF(e) { return typeof e == "string" && e.indexOf(".") !== -1 && parseFloat(e) === 1; }
function hF(e) { return typeof e == "string" && e.indexOf("%") !== -1; }
function Kw(e) { return e = parseFloat(e), (isNaN(e) || e < 0 || e > 1) && (e = 1), e; }
function Xi(e) { return e <= 1 ? "".concat(Number(e) * 100, "%") : e; }
function Ts(e) { return e.length === 1 ? "0" + e : String(e); }
function vF(e, t, n) { return { r: Dn(e, 255) * 255, g: Dn(t, 255) * 255, b: Dn(n, 255) * 255 }; }
function i0(e, t, n) { e = Dn(e, 255), t = Dn(t, 255), n = Dn(n, 255); var o = Math.max(e, t, n), r = Math.min(e, t, n), s = 0, l = 0, a = (o + r) / 2; if (o === r)
    l = 0, s = 0;
else {
    var u = o - r;
    switch (l = a > .5 ? u / (2 - o - r) : u / (o + r), o) {
        case e:
            s = (t - n) / u + (t < n ? 6 : 0);
            break;
        case t:
            s = (n - e) / u + 2;
            break;
        case n:
            s = (e - t) / u + 4;
            break;
    }
    s /= 6;
} return { h: s, s: l, l: a }; }
function $d(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * (6 * n) : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e; }
function mF(e, t, n) { var o, r, s; if (e = Dn(e, 360), t = Dn(t, 100), n = Dn(n, 100), t === 0)
    r = n, s = n, o = n;
else {
    var l = n < .5 ? n * (1 + t) : n + t - n * t, a = 2 * n - l;
    o = $d(a, l, e + 1 / 3), r = $d(a, l, e), s = $d(a, l, e - 1 / 3);
} return { r: o * 255, g: r * 255, b: s * 255 }; }
function u0(e, t, n) { e = Dn(e, 255), t = Dn(t, 255), n = Dn(n, 255); var o = Math.max(e, t, n), r = Math.min(e, t, n), s = 0, l = o, a = o - r, u = o === 0 ? 0 : a / o; if (o === r)
    s = 0;
else {
    switch (o) {
        case e:
            s = (t - n) / a + (t < n ? 6 : 0);
            break;
        case t:
            s = (n - e) / a + 2;
            break;
        case n:
            s = (e - t) / a + 4;
            break;
    }
    s /= 6;
} return { h: s, s: u, v: l }; }
function gF(e, t, n) { e = Dn(e, 360) * 6, t = Dn(t, 100), n = Dn(n, 100); var o = Math.floor(e), r = e - o, s = n * (1 - t), l = n * (1 - r * t), a = n * (1 - (1 - r) * t), u = o % 6, c = [n, l, s, s, a, n][u], d = [a, n, n, l, s, s][u], f = [s, s, a, n, n, l][u]; return { r: c * 255, g: d * 255, b: f * 255 }; }
function c0(e, t, n, o) { var r = [Ts(Math.round(e).toString(16)), Ts(Math.round(t).toString(16)), Ts(Math.round(n).toString(16))]; return o && r[0].startsWith(r[0].charAt(1)) && r[1].startsWith(r[1].charAt(1)) && r[2].startsWith(r[2].charAt(1)) ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0) : r.join(""); }
function yF(e, t, n, o, r) { var s = [Ts(Math.round(e).toString(16)), Ts(Math.round(t).toString(16)), Ts(Math.round(n).toString(16)), Ts(bF(o))]; return r && s[0].startsWith(s[0].charAt(1)) && s[1].startsWith(s[1].charAt(1)) && s[2].startsWith(s[2].charAt(1)) && s[3].startsWith(s[3].charAt(1)) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join(""); }
function bF(e) { return Math.round(parseFloat(e) * 255).toString(16); }
function d0(e) { return co(e) / 255; }
function co(e) { return parseInt(e, 16); }
function wF(e) { return { r: e >> 16, g: (e & 65280) >> 8, b: e & 255 }; }
var $f = { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", goldenrod: "#daa520", gold: "#ffd700", gray: "#808080", green: "#008000", greenyellow: "#adff2f", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", indianred: "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavenderblush: "#fff0f5", lavender: "#e6e6fa", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgray: "#d3d3d3", lightgreen: "#90ee90", lightgrey: "#d3d3d3", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370db", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#db7093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", rebeccapurple: "#663399", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", slategrey: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" };
function CF(e) { var t = { r: 0, g: 0, b: 0 }, n = 1, o = null, r = null, s = null, l = !1, a = !1; return typeof e == "string" && (e = kF(e)), typeof e == "object" && (dr(e.r) && dr(e.g) && dr(e.b) ? (t = vF(e.r, e.g, e.b), l = !0, a = String(e.r).substr(-1) === "%" ? "prgb" : "rgb") : dr(e.h) && dr(e.s) && dr(e.v) ? (o = Xi(e.s), r = Xi(e.v), t = gF(e.h, o, r), l = !0, a = "hsv") : dr(e.h) && dr(e.s) && dr(e.l) && (o = Xi(e.s), s = Xi(e.l), t = mF(e.h, o, s), l = !0, a = "hsl"), Object.prototype.hasOwnProperty.call(e, "a") && (n = e.a)), n = Kw(n), { ok: l, format: e.format || a, r: Math.min(255, Math.max(t.r, 0)), g: Math.min(255, Math.max(t.g, 0)), b: Math.min(255, Math.max(t.b, 0)), a: n }; }
var SF = "[-\\+]?\\d+%?", _F = "[-\\+]?\\d*\\.\\d+%?", jr = "(?:".concat(_F, ")|(?:").concat(SF, ")"), Td = "[\\s|\\(]+(".concat(jr, ")[,|\\s]+(").concat(jr, ")[,|\\s]+(").concat(jr, ")\\s*\\)?"), Od = "[\\s|\\(]+(".concat(jr, ")[,|\\s]+(").concat(jr, ")[,|\\s]+(").concat(jr, ")[,|\\s]+(").concat(jr, ")\\s*\\)?"), No = { CSS_UNIT: new RegExp(jr), rgb: new RegExp("rgb" + Td), rgba: new RegExp("rgba" + Od), hsl: new RegExp("hsl" + Td), hsla: new RegExp("hsla" + Od), hsv: new RegExp("hsv" + Td), hsva: new RegExp("hsva" + Od), hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/ };
function kF(e) { if (e = e.trim().toLowerCase(), e.length === 0)
    return !1; var t = !1; if ($f[e])
    e = $f[e], t = !0;
else if (e === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" }; var n = No.rgb.exec(e); return n ? { r: n[1], g: n[2], b: n[3] } : (n = No.rgba.exec(e), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = No.hsl.exec(e), n ? { h: n[1], s: n[2], l: n[3] } : (n = No.hsla.exec(e), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = No.hsv.exec(e), n ? { h: n[1], s: n[2], v: n[3] } : (n = No.hsva.exec(e), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = No.hex8.exec(e), n ? { r: co(n[1]), g: co(n[2]), b: co(n[3]), a: d0(n[4]), format: t ? "name" : "hex8" } : (n = No.hex6.exec(e), n ? { r: co(n[1]), g: co(n[2]), b: co(n[3]), format: t ? "name" : "hex" } : (n = No.hex4.exec(e), n ? { r: co(n[1] + n[1]), g: co(n[2] + n[2]), b: co(n[3] + n[3]), a: d0(n[4] + n[4]), format: t ? "name" : "hex8" } : (n = No.hex3.exec(e), n ? { r: co(n[1] + n[1]), g: co(n[2] + n[2]), b: co(n[3] + n[3]), format: t ? "name" : "hex" } : !1))))))))); }
function dr(e) { return !!No.CSS_UNIT.exec(String(e)); }
var jw = function () { function e(t, n) { t === void 0 && (t = ""), n === void 0 && (n = {}); var o; if (t instanceof e)
    return t; typeof t == "number" && (t = wF(t)), this.originalInput = t; var r = CF(t); this.originalInput = t, this.r = r.r, this.g = r.g, this.b = r.b, this.a = r.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (o = n.format) !== null && o !== void 0 ? o : r.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = r.ok; } return e.prototype.isDark = function () { return this.getBrightness() < 128; }, e.prototype.isLight = function () { return !this.isDark(); }, e.prototype.getBrightness = function () { var t = this.toRgb(); return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3; }, e.prototype.getLuminance = function () { var t = this.toRgb(), n, o, r, s = t.r / 255, l = t.g / 255, a = t.b / 255; return s <= .03928 ? n = s / 12.92 : n = Math.pow((s + .055) / 1.055, 2.4), l <= .03928 ? o = l / 12.92 : o = Math.pow((l + .055) / 1.055, 2.4), a <= .03928 ? r = a / 12.92 : r = Math.pow((a + .055) / 1.055, 2.4), .2126 * n + .7152 * o + .0722 * r; }, e.prototype.getAlpha = function () { return this.a; }, e.prototype.setAlpha = function (t) { return this.a = Kw(t), this.roundA = Math.round(100 * this.a) / 100, this; }, e.prototype.isMonochrome = function () { var t = this.toHsl().s; return t === 0; }, e.prototype.toHsv = function () { var t = u0(this.r, this.g, this.b); return { h: t.h * 360, s: t.s, v: t.v, a: this.a }; }, e.prototype.toHsvString = function () { var t = u0(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), r = Math.round(t.v * 100); return this.a === 1 ? "hsv(".concat(n, ", ").concat(o, "%, ").concat(r, "%)") : "hsva(".concat(n, ", ").concat(o, "%, ").concat(r, "%, ").concat(this.roundA, ")"); }, e.prototype.toHsl = function () { var t = i0(this.r, this.g, this.b); return { h: t.h * 360, s: t.s, l: t.l, a: this.a }; }, e.prototype.toHslString = function () { var t = i0(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), r = Math.round(t.l * 100); return this.a === 1 ? "hsl(".concat(n, ", ").concat(o, "%, ").concat(r, "%)") : "hsla(".concat(n, ", ").concat(o, "%, ").concat(r, "%, ").concat(this.roundA, ")"); }, e.prototype.toHex = function (t) { return t === void 0 && (t = !1), c0(this.r, this.g, this.b, t); }, e.prototype.toHexString = function (t) { return t === void 0 && (t = !1), "#" + this.toHex(t); }, e.prototype.toHex8 = function (t) { return t === void 0 && (t = !1), yF(this.r, this.g, this.b, this.a, t); }, e.prototype.toHex8String = function (t) { return t === void 0 && (t = !1), "#" + this.toHex8(t); }, e.prototype.toHexShortString = function (t) { return t === void 0 && (t = !1), this.a === 1 ? this.toHexString(t) : this.toHex8String(t); }, e.prototype.toRgb = function () { return { r: Math.round(this.r), g: Math.round(this.g), b: Math.round(this.b), a: this.a }; }, e.prototype.toRgbString = function () { var t = Math.round(this.r), n = Math.round(this.g), o = Math.round(this.b); return this.a === 1 ? "rgb(".concat(t, ", ").concat(n, ", ").concat(o, ")") : "rgba(".concat(t, ", ").concat(n, ", ").concat(o, ", ").concat(this.roundA, ")"); }, e.prototype.toPercentageRgb = function () { var t = function (n) { return "".concat(Math.round(Dn(n, 255) * 100), "%"); }; return { r: t(this.r), g: t(this.g), b: t(this.b), a: this.a }; }, e.prototype.toPercentageRgbString = function () { var t = function (n) { return Math.round(Dn(n, 255) * 100); }; return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")"); }, e.prototype.toName = function () { if (this.a === 0)
    return "transparent"; if (this.a < 1)
    return !1; for (var t = "#" + c0(this.r, this.g, this.b, !1), n = 0, o = Object.entries($f); n < o.length; n++) {
    var r = o[n], s = r[0], l = r[1];
    if (t === l)
        return s;
} return !1; }, e.prototype.toString = function (t) { var n = !!t; t = t ?? this.format; var o = !1, r = this.a < 1 && this.a >= 0, s = !n && r && (t.startsWith("hex") || t === "name"); return s ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (o = this.toRgbString()), t === "prgb" && (o = this.toPercentageRgbString()), (t === "hex" || t === "hex6") && (o = this.toHexString()), t === "hex3" && (o = this.toHexString(!0)), t === "hex4" && (o = this.toHex8String(!0)), t === "hex8" && (o = this.toHex8String()), t === "name" && (o = this.toName()), t === "hsl" && (o = this.toHslString()), t === "hsv" && (o = this.toHsvString()), o || this.toHexString()); }, e.prototype.toNumber = function () { return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b); }, e.prototype.clone = function () { return new e(this.toString()); }, e.prototype.lighten = function (t) { t === void 0 && (t = 10); var n = this.toHsl(); return n.l += t / 100, n.l = Gi(n.l), new e(n); }, e.prototype.brighten = function (t) { t === void 0 && (t = 10); var n = this.toRgb(); return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(t / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(t / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(t / 100)))), new e(n); }, e.prototype.darken = function (t) { t === void 0 && (t = 10); var n = this.toHsl(); return n.l -= t / 100, n.l = Gi(n.l), new e(n); }, e.prototype.tint = function (t) { return t === void 0 && (t = 10), this.mix("white", t); }, e.prototype.shade = function (t) { return t === void 0 && (t = 10), this.mix("black", t); }, e.prototype.desaturate = function (t) { t === void 0 && (t = 10); var n = this.toHsl(); return n.s -= t / 100, n.s = Gi(n.s), new e(n); }, e.prototype.saturate = function (t) { t === void 0 && (t = 10); var n = this.toHsl(); return n.s += t / 100, n.s = Gi(n.s), new e(n); }, e.prototype.greyscale = function () { return this.desaturate(100); }, e.prototype.spin = function (t) { var n = this.toHsl(), o = (n.h + t) % 360; return n.h = o < 0 ? 360 + o : o, new e(n); }, e.prototype.mix = function (t, n) { n === void 0 && (n = 50); var o = this.toRgb(), r = new e(t).toRgb(), s = n / 100, l = { r: (r.r - o.r) * s + o.r, g: (r.g - o.g) * s + o.g, b: (r.b - o.b) * s + o.b, a: (r.a - o.a) * s + o.a }; return new e(l); }, e.prototype.analogous = function (t, n) { t === void 0 && (t = 6), n === void 0 && (n = 30); var o = this.toHsl(), r = 360 / n, s = [this]; for (o.h = (o.h - (r * t >> 1) + 720) % 360; --t;)
    o.h = (o.h + r) % 360, s.push(new e(o)); return s; }, e.prototype.complement = function () { var t = this.toHsl(); return t.h = (t.h + 180) % 360, new e(t); }, e.prototype.monochromatic = function (t) { t === void 0 && (t = 6); for (var n = this.toHsv(), o = n.h, r = n.s, s = n.v, l = [], a = 1 / t; t--;)
    l.push(new e({ h: o, s: r, v: s })), s = (s + a) % 1; return l; }, e.prototype.splitcomplement = function () { var t = this.toHsl(), n = t.h; return [this, new e({ h: (n + 72) % 360, s: t.s, l: t.l }), new e({ h: (n + 216) % 360, s: t.s, l: t.l })]; }, e.prototype.onBackground = function (t) { var n = this.toRgb(), o = new e(t).toRgb(), r = n.a + o.a * (1 - n.a); return new e({ r: (n.r * n.a + o.r * o.a * (1 - n.a)) / r, g: (n.g * n.a + o.g * o.a * (1 - n.a)) / r, b: (n.b * n.a + o.b * o.a * (1 - n.a)) / r, a: r }); }, e.prototype.triad = function () { return this.polyad(3); }, e.prototype.tetrad = function () { return this.polyad(4); }, e.prototype.polyad = function (t) { for (var n = this.toHsl(), o = n.h, r = [this], s = 360 / t, l = 1; l < t; l++)
    r.push(new e({ h: (o + l * s) % 360, s: n.s, l: n.l })); return r; }, e.prototype.equals = function (t) { return this.toRgbString() === new e(t).toRgbString(); }, e; }();
function Rr(e, t = 20) { return e.mix("#141414", t).toString(); }
function EF(e) { const t = uo(), n = Ie("button"); return S(() => { let o = {}; const r = e.color; if (r) {
    const s = new jw(r), l = e.dark ? s.tint(20).toString() : Rr(s, 20);
    if (e.plain)
        o = n.cssVarBlock({ "bg-color": e.dark ? Rr(s, 90) : s.tint(90).toString(), "text-color": r, "border-color": e.dark ? Rr(s, 50) : s.tint(50).toString(), "hover-text-color": `var(${n.cssVarName("color-white")})`, "hover-bg-color": r, "hover-border-color": r, "active-bg-color": l, "active-text-color": `var(${n.cssVarName("color-white")})`, "active-border-color": l }), t.value && (o[n.cssVarBlockName("disabled-bg-color")] = e.dark ? Rr(s, 90) : s.tint(90).toString(), o[n.cssVarBlockName("disabled-text-color")] = e.dark ? Rr(s, 50) : s.tint(50).toString(), o[n.cssVarBlockName("disabled-border-color")] = e.dark ? Rr(s, 80) : s.tint(80).toString());
    else {
        const a = e.dark ? Rr(s, 30) : s.tint(30).toString(), u = s.isDark() ? `var(${n.cssVarName("color-white")})` : `var(${n.cssVarName("color-black")})`;
        if (o = n.cssVarBlock({ "bg-color": r, "text-color": u, "border-color": r, "hover-bg-color": a, "hover-text-color": u, "hover-border-color": a, "active-bg-color": l, "active-border-color": l }), t.value) {
            const c = e.dark ? Rr(s, 50) : s.tint(50).toString();
            o[n.cssVarBlockName("disabled-bg-color")] = c, o[n.cssVarBlockName("disabled-text-color")] = e.dark ? "rgba(255, 255, 255, 0.5)" : `var(${n.cssVarName("color-white")})`, o[n.cssVarBlockName("disabled-border-color")] = c;
        }
    }
} return o; }); }
const $F = ae({ name: "ElButton" }), TF = ae({ ...$F, props: Ef, emits: fF, setup(e, { expose: t, emit: n }) { const o = e, r = EF(o), s = Ie("button"), { _ref: l, _size: a, _type: u, _disabled: c, _props: d, shouldAddSpace: f, handleClick: p } = cF(o, n); return t({ ref: l, size: a, type: u, disabled: c, shouldAddSpace: f }), (v, m) => (k(), ge(kt(v.tag), Ct({ ref_key: "_ref", ref: l }, i(d), { class: [i(s).b(), i(s).m(i(u)), i(s).m(i(a)), i(s).is("disabled", i(c)), i(s).is("loading", v.loading), i(s).is("plain", v.plain), i(s).is("round", v.round), i(s).is("circle", v.circle), i(s).is("text", v.text), i(s).is("link", v.link), i(s).is("has-bg", v.bg)], style: i(r), onClick: i(p) }), { default: ie(() => [v.loading ? (k(), z(Qe, { key: 0 }, [v.$slots.loading ? ke(v.$slots, "loading", { key: 0 }) : (k(), ge(i(Je), { key: 1, class: O(i(s).is("loading")) }, { default: ie(() => [(k(), ge(kt(v.loadingIcon)))]), _: 1 }, 8, ["class"]))], 64)) : v.icon || v.$slots.icon ? (k(), ge(i(Je), { key: 1 }, { default: ie(() => [v.icon ? (k(), ge(kt(v.icon), { key: 0 })) : ke(v.$slots, "icon", { key: 1 })]), _: 3 })) : pe("v-if", !0), v.$slots.default ? (k(), z("span", { key: 2, class: O({ [i(s).em("text", "expand")]: i(f) }) }, [ke(v.$slots, "default")], 2)) : pe("v-if", !0)]), _: 3 }, 16, ["class", "style", "onClick"])); } });
var OF = Fe(TF, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
const IF = { size: Ef.size, type: Ef.type }, xF = ae({ name: "ElButtonGroup" }), AF = ae({ ...xF, props: IF, setup(e) { const t = e; St(Hw, Lt({ size: an(t, "size"), type: an(t, "type") })); const n = Ie("button"); return (o, r) => (k(), z("div", { class: O(`${i(n).b("group")}`) }, [ke(o.$slots, "default")], 2)); } });
var Ww = Fe(AF, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
const xn = vt(OF, { ButtonGroup: Ww }), Uw = pn(Ww);
var ko = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function lr(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e; }
var qw = { exports: {} };
(function (e, t) { (function (n, o) { e.exports = o(); })(ko, function () { var n = 1e3, o = 6e4, r = 36e5, s = "millisecond", l = "second", a = "minute", u = "hour", c = "day", d = "week", f = "month", p = "quarter", v = "year", m = "date", h = "Invalid Date", g = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, C = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function (R) { var K = ["th", "st", "nd", "rd"], te = R % 100; return "[" + R + (K[(te - 20) % 10] || K[te] || K[0]) + "]"; } }, b = function (R, K, te) { var U = String(R); return !U || U.length >= K ? R : "" + Array(K + 1 - U.length).join(te) + R; }, w = { s: b, z: function (R) { var K = -R.utcOffset(), te = Math.abs(K), U = Math.floor(te / 60), D = te % 60; return (K <= 0 ? "+" : "-") + b(U, 2, "0") + ":" + b(D, 2, "0"); }, m: function R(K, te) { if (K.date() < te.date())
        return -R(te, K); var U = 12 * (te.year() - K.year()) + (te.month() - K.month()), D = K.clone().add(U, f), j = te - D < 0, A = K.clone().add(U + (j ? -1 : 1), f); return +(-(U + (te - D) / (j ? D - A : A - D)) || 0); }, a: function (R) { return R < 0 ? Math.ceil(R) || 0 : Math.floor(R); }, p: function (R) { return { M: f, y: v, w: d, d: c, D: m, h: u, m: a, s: l, ms: s, Q: p }[R] || String(R || "").toLowerCase().replace(/s$/, ""); }, u: function (R) { return R === void 0; } }, T = "en", E = {}; E[T] = C; var x = function (R) { return R instanceof F; }, I = function R(K, te, U) { var D; if (!K)
    return T; if (typeof K == "string") {
    var j = K.toLowerCase();
    E[j] && (D = j), te && (E[j] = te, D = j);
    var A = K.split("-");
    if (!D && A.length > 1)
        return R(A[0]);
}
else {
    var G = K.name;
    E[G] = K, D = G;
} return !U && D && (T = D), D || !U && T; }, L = function (R, K) { if (x(R))
    return R.clone(); var te = typeof K == "object" ? K : {}; return te.date = R, te.args = arguments, new F(te); }, B = w; B.l = I, B.i = x, B.w = function (R, K) { return L(R, { locale: K.$L, utc: K.$u, x: K.$x, $offset: K.$offset }); }; var F = function () { function R(te) { this.$L = I(te.locale, null, !0), this.parse(te); } var K = R.prototype; return K.parse = function (te) { this.$d = function (U) { var D = U.date, j = U.utc; if (D === null)
    return new Date(NaN); if (B.u(D))
    return new Date; if (D instanceof Date)
    return new Date(D); if (typeof D == "string" && !/Z$/i.test(D)) {
    var A = D.match(g);
    if (A) {
        var G = A[2] - 1 || 0, se = (A[7] || "0").substring(0, 3);
        return j ? new Date(Date.UTC(A[1], G, A[3] || 1, A[4] || 0, A[5] || 0, A[6] || 0, se)) : new Date(A[1], G, A[3] || 1, A[4] || 0, A[5] || 0, A[6] || 0, se);
    }
} return new Date(D); }(te), this.$x = te.x || {}, this.init(); }, K.init = function () { var te = this.$d; this.$y = te.getFullYear(), this.$M = te.getMonth(), this.$D = te.getDate(), this.$W = te.getDay(), this.$H = te.getHours(), this.$m = te.getMinutes(), this.$s = te.getSeconds(), this.$ms = te.getMilliseconds(); }, K.$utils = function () { return B; }, K.isValid = function () { return this.$d.toString() !== h; }, K.isSame = function (te, U) { var D = L(te); return this.startOf(U) <= D && D <= this.endOf(U); }, K.isAfter = function (te, U) { return L(te) < this.startOf(U); }, K.isBefore = function (te, U) { return this.endOf(U) < L(te); }, K.$g = function (te, U, D) { return B.u(te) ? this[U] : this.set(D, te); }, K.unix = function () { return Math.floor(this.valueOf() / 1e3); }, K.valueOf = function () { return this.$d.getTime(); }, K.startOf = function (te, U) { var D = this, j = !!B.u(U) || U, A = B.p(te), G = function (oe, fe) { var Ce = B.w(D.$u ? Date.UTC(D.$y, fe, oe) : new Date(D.$y, fe, oe), D); return j ? Ce : Ce.endOf(c); }, se = function (oe, fe) { return B.w(D.toDate()[oe].apply(D.toDate("s"), (j ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(fe)), D); }, Z = this.$W, ce = this.$M, ye = this.$D, Re = "set" + (this.$u ? "UTC" : ""); switch (A) {
    case v: return j ? G(1, 0) : G(31, 11);
    case f: return j ? G(1, ce) : G(0, ce + 1);
    case d:
        var me = this.$locale().weekStart || 0, le = (Z < me ? Z + 7 : Z) - me;
        return G(j ? ye - le : ye + (6 - le), ce);
    case c:
    case m: return se(Re + "Hours", 0);
    case u: return se(Re + "Minutes", 1);
    case a: return se(Re + "Seconds", 2);
    case l: return se(Re + "Milliseconds", 3);
    default: return this.clone();
} }, K.endOf = function (te) { return this.startOf(te, !1); }, K.$set = function (te, U) { var D, j = B.p(te), A = "set" + (this.$u ? "UTC" : ""), G = (D = {}, D[c] = A + "Date", D[m] = A + "Date", D[f] = A + "Month", D[v] = A + "FullYear", D[u] = A + "Hours", D[a] = A + "Minutes", D[l] = A + "Seconds", D[s] = A + "Milliseconds", D)[j], se = j === c ? this.$D + (U - this.$W) : U; if (j === f || j === v) {
    var Z = this.clone().set(m, 1);
    Z.$d[G](se), Z.init(), this.$d = Z.set(m, Math.min(this.$D, Z.daysInMonth())).$d;
}
else
    G && this.$d[G](se); return this.init(), this; }, K.set = function (te, U) { return this.clone().$set(te, U); }, K.get = function (te) { return this[B.p(te)](); }, K.add = function (te, U) { var D, j = this; te = Number(te); var A = B.p(U), G = function (ce) { var ye = L(j); return B.w(ye.date(ye.date() + Math.round(ce * te)), j); }; if (A === f)
    return this.set(f, this.$M + te); if (A === v)
    return this.set(v, this.$y + te); if (A === c)
    return G(1); if (A === d)
    return G(7); var se = (D = {}, D[a] = o, D[u] = r, D[l] = n, D)[A] || 1, Z = this.$d.getTime() + te * se; return B.w(Z, this); }, K.subtract = function (te, U) { return this.add(-1 * te, U); }, K.format = function (te) { var U = this, D = this.$locale(); if (!this.isValid())
    return D.invalidDate || h; var j = te || "YYYY-MM-DDTHH:mm:ssZ", A = B.z(this), G = this.$H, se = this.$m, Z = this.$M, ce = D.weekdays, ye = D.months, Re = D.meridiem, me = function (fe, Ce, Ae, q) { return fe && (fe[Ce] || fe(U, j)) || Ae[Ce].slice(0, q); }, le = function (fe) { return B.s(G % 12 || 12, fe, "0"); }, oe = Re || function (fe, Ce, Ae) { var q = fe < 12 ? "AM" : "PM"; return Ae ? q.toLowerCase() : q; }; return j.replace(y, function (fe, Ce) { return Ce || function (Ae) { switch (Ae) {
    case "YY": return String(U.$y).slice(-2);
    case "YYYY": return B.s(U.$y, 4, "0");
    case "M": return Z + 1;
    case "MM": return B.s(Z + 1, 2, "0");
    case "MMM": return me(D.monthsShort, Z, ye, 3);
    case "MMMM": return me(ye, Z);
    case "D": return U.$D;
    case "DD": return B.s(U.$D, 2, "0");
    case "d": return String(U.$W);
    case "dd": return me(D.weekdaysMin, U.$W, ce, 2);
    case "ddd": return me(D.weekdaysShort, U.$W, ce, 3);
    case "dddd": return ce[U.$W];
    case "H": return String(G);
    case "HH": return B.s(G, 2, "0");
    case "h": return le(1);
    case "hh": return le(2);
    case "a": return oe(G, se, !0);
    case "A": return oe(G, se, !1);
    case "m": return String(se);
    case "mm": return B.s(se, 2, "0");
    case "s": return String(U.$s);
    case "ss": return B.s(U.$s, 2, "0");
    case "SSS": return B.s(U.$ms, 3, "0");
    case "Z": return A;
} return null; }(fe) || A.replace(":", ""); }); }, K.utcOffset = function () { return 15 * -Math.round(this.$d.getTimezoneOffset() / 15); }, K.diff = function (te, U, D) { var j, A = this, G = B.p(U), se = L(te), Z = (se.utcOffset() - this.utcOffset()) * o, ce = this - se, ye = function () { return B.m(A, se); }; switch (G) {
    case v:
        j = ye() / 12;
        break;
    case f:
        j = ye();
        break;
    case p:
        j = ye() / 3;
        break;
    case d:
        j = (ce - Z) / 6048e5;
        break;
    case c:
        j = (ce - Z) / 864e5;
        break;
    case u:
        j = ce / r;
        break;
    case a:
        j = ce / o;
        break;
    case l:
        j = ce / n;
        break;
    default: j = ce;
} return D ? j : B.a(j); }, K.daysInMonth = function () { return this.endOf(f).$D; }, K.$locale = function () { return E[this.$L]; }, K.locale = function (te, U) { if (!te)
    return this.$L; var D = this.clone(), j = I(te, U, !0); return j && (D.$L = j), D; }, K.clone = function () { return B.w(this.$d, this); }, K.toDate = function () { return new Date(this.valueOf()); }, K.toJSON = function () { return this.isValid() ? this.toISOString() : null; }, K.toISOString = function () { return this.$d.toISOString(); }, K.toString = function () { return this.$d.toUTCString(); }, R; }(), V = F.prototype; return L.prototype = V, [["$ms", s], ["$s", l], ["$m", a], ["$H", u], ["$W", c], ["$M", f], ["$y", v], ["$D", m]].forEach(function (R) { V[R[1]] = function (K) { return this.$g(K, R[0], R[1]); }; }), L.extend = function (R, K) { return R.$i || (R(K, F, L), R.$i = !0), L; }, L.locale = I, L.isDayjs = x, L.unix = function (R) { return L(1e3 * R); }, L.en = E[T], L.Ls = E, L.p = {}, L; }); })(qw);
var MF = qw.exports;
const pt = lr(MF);
var Yw = { exports: {} };
(function (e, t) { (function (n, o) { e.exports = o(); })(ko, function () { var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, o = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, r = /\d\d/, s = /\d\d?/, l = /\d*[^-_:/,()\s\d]+/, a = {}, u = function (h) { return (h = +h) + (h > 68 ? 1900 : 2e3); }, c = function (h) { return function (g) { this[h] = +g; }; }, d = [/[+-]\d\d:?(\d\d)?|Z/, function (h) { (this.zone || (this.zone = {})).offset = function (g) { if (!g || g === "Z")
        return 0; var y = g.match(/([+-]|\d\d)/g), C = 60 * y[1] + (+y[2] || 0); return C === 0 ? 0 : y[0] === "+" ? -C : C; }(h); }], f = function (h) { var g = a[h]; return g && (g.indexOf ? g : g.s.concat(g.f)); }, p = function (h, g) { var y, C = a.meridiem; if (C) {
    for (var b = 1; b <= 24; b += 1)
        if (h.indexOf(C(b, 0, g)) > -1) {
            y = b > 12;
            break;
        }
}
else
    y = h === (g ? "pm" : "PM"); return y; }, v = { A: [l, function (h) { this.afternoon = p(h, !1); }], a: [l, function (h) { this.afternoon = p(h, !0); }], S: [/\d/, function (h) { this.milliseconds = 100 * +h; }], SS: [r, function (h) { this.milliseconds = 10 * +h; }], SSS: [/\d{3}/, function (h) { this.milliseconds = +h; }], s: [s, c("seconds")], ss: [s, c("seconds")], m: [s, c("minutes")], mm: [s, c("minutes")], H: [s, c("hours")], h: [s, c("hours")], HH: [s, c("hours")], hh: [s, c("hours")], D: [s, c("day")], DD: [r, c("day")], Do: [l, function (h) { var g = a.ordinal, y = h.match(/\d+/); if (this.day = y[0], g)
            for (var C = 1; C <= 31; C += 1)
                g(C).replace(/\[|\]/g, "") === h && (this.day = C); }], M: [s, c("month")], MM: [r, c("month")], MMM: [l, function (h) { var g = f("months"), y = (f("monthsShort") || g.map(function (C) { return C.slice(0, 3); })).indexOf(h) + 1; if (y < 1)
            throw new Error; this.month = y % 12 || y; }], MMMM: [l, function (h) { var g = f("months").indexOf(h) + 1; if (g < 1)
            throw new Error; this.month = g % 12 || g; }], Y: [/[+-]?\d+/, c("year")], YY: [r, function (h) { this.year = u(h); }], YYYY: [/\d{4}/, c("year")], Z: d, ZZ: d }; function m(h) { var g, y; g = h, y = a && a.formats; for (var C = (h = g.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (L, B, F) { var V = F && F.toUpperCase(); return B || y[F] || n[F] || y[V].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (R, K, te) { return K || te.slice(1); }); })).match(o), b = C.length, w = 0; w < b; w += 1) {
    var T = C[w], E = v[T], x = E && E[0], I = E && E[1];
    C[w] = I ? { regex: x, parser: I } : T.replace(/^\[|\]$/g, "");
} return function (L) { for (var B = {}, F = 0, V = 0; F < b; F += 1) {
    var R = C[F];
    if (typeof R == "string")
        V += R.length;
    else {
        var K = R.regex, te = R.parser, U = L.slice(V), D = K.exec(U)[0];
        te.call(B, D), L = L.replace(D, "");
    }
} return function (j) { var A = j.afternoon; if (A !== void 0) {
    var G = j.hours;
    A ? G < 12 && (j.hours += 12) : G === 12 && (j.hours = 0), delete j.afternoon;
} }(B), B; }; } return function (h, g, y) { y.p.customParseFormat = !0, h && h.parseTwoDigitYear && (u = h.parseTwoDigitYear); var C = g.prototype, b = C.parse; C.parse = function (w) { var T = w.date, E = w.utc, x = w.args; this.$u = E; var I = x[1]; if (typeof I == "string") {
    var L = x[2] === !0, B = x[3] === !0, F = L || B, V = x[2];
    B && (V = x[2]), a = this.$locale(), !L && V && (a = y.Ls[V]), this.$d = function (U, D, j) { try {
        if (["x", "X"].indexOf(D) > -1)
            return new Date((D === "X" ? 1e3 : 1) * U);
        var A = m(D)(U), G = A.year, se = A.month, Z = A.day, ce = A.hours, ye = A.minutes, Re = A.seconds, me = A.milliseconds, le = A.zone, oe = new Date, fe = Z || (G || se ? 1 : oe.getDate()), Ce = G || oe.getFullYear(), Ae = 0;
        G && !se || (Ae = se > 0 ? se - 1 : oe.getMonth());
        var q = ce || 0, re = ye || 0, he = Re || 0, Ee = me || 0;
        return le ? new Date(Date.UTC(Ce, Ae, fe, q, re, he, Ee + 60 * le.offset * 1e3)) : j ? new Date(Date.UTC(Ce, Ae, fe, q, re, he, Ee)) : new Date(Ce, Ae, fe, q, re, he, Ee);
    }
    catch {
        return new Date("");
    } }(T, I, E), this.init(), V && V !== !0 && (this.$L = this.locale(V).$L), F && T != this.format(I) && (this.$d = new Date("")), a = {};
}
else if (I instanceof Array)
    for (var R = I.length, K = 1; K <= R; K += 1) {
        x[1] = I[K - 1];
        var te = y.apply(this, x);
        if (te.isValid()) {
            this.$d = te.$d, this.$L = te.$L, this.init();
            break;
        }
        K === R && (this.$d = new Date(""));
    }
else
    b.call(this, w); }; }; }); })(Yw);
var NF = Yw.exports;
const Mh = lr(NF), f0 = ["hours", "minutes", "seconds"], Tf = "HH:mm:ss", rl = "YYYY-MM-DD", PF = { date: rl, dates: rl, week: "gggg[w]ww", year: "YYYY", month: "YYYY-MM", datetime: `${rl} ${Tf}`, monthrange: "YYYY-MM", daterange: rl, datetimerange: `${rl} ${Tf}` }, Id = (e, t) => [e > 0 ? e - 1 : void 0, e, e < t ? e + 1 : void 0], Gr = e => Array.from(Array.from({ length: e }).keys()), Gw = e => e.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim(), Xw = e => e.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim(), p0 = function (e, t) { const n = Fs(e), o = Fs(t); return n && o ? e.getTime() === t.getTime() : !n && !o ? e === t : !1; }, h0 = function (e, t) { const n = qe(e), o = qe(t); return n && o ? e.length !== t.length ? !1 : e.every((r, s) => p0(r, t[s])) : !n && !o ? p0(e, t) : !1; }, v0 = function (e, t, n) { const o = wo(t) || t === "x" ? pt(e).locale(n) : pt(e, t).locale(n); return o.isValid() ? o : void 0; }, m0 = function (e, t, n) { return wo(t) ? e : t === "x" ? +e : pt(e).locale(n).format(t); }, xd = (e, t) => { var n; const o = [], r = t == null ? void 0 : t(); for (let s = 0; s < e; s++)
    o.push((n = r == null ? void 0 : r.includes(s)) != null ? n : !1); return o; }, Jw = Ve({ disabledHours: { type: ve(Function) }, disabledMinutes: { type: ve(Function) }, disabledSeconds: { type: ve(Function) } }), Zw = Ve({ visible: Boolean, actualVisible: { type: Boolean, default: void 0 }, format: { type: String, default: "" } }), Nh = Ve({ id: { type: ve([Array, String]) }, name: { type: ve([Array, String]), default: "" }, popperClass: { type: String, default: "" }, format: String, valueFormat: String, type: { type: String, default: "" }, clearable: { type: Boolean, default: !0 }, clearIcon: { type: ve([String, Object]), default: ls }, editable: { type: Boolean, default: !0 }, prefixIcon: { type: ve([String, Object]), default: "" }, size: Bn, readonly: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, placeholder: { type: String, default: "" }, popperOptions: { type: ve(Object), default: () => ({}) }, modelValue: { type: ve([Date, Array, String, Number]), default: "" }, rangeSeparator: { type: String, default: "-" }, startPlaceholder: String, endPlaceholder: String, defaultValue: { type: ve([Date, Array]) }, defaultTime: { type: ve([Date, Array]) }, isRange: { type: Boolean, default: !1 }, ...Jw, disabledDate: { type: Function }, cellClassName: { type: Function }, shortcuts: { type: Array, default: () => [] }, arrowControl: { type: Boolean, default: !1 }, label: { type: String, default: void 0 }, tabindex: { type: ve([String, Number]), default: 0 }, validateEvent: { type: Boolean, default: !0 }, unlinkPanels: Boolean }), RF = ["id", "name", "placeholder", "value", "disabled", "readonly"], LF = ["id", "name", "placeholder", "value", "disabled", "readonly"], DF = ae({ name: "Picker" }), BF = ae({ ...DF, props: Nh, emits: ["update:modelValue", "change", "focus", "blur", "calendar-change", "panel-change", "visible-change", "keydown"], setup(e, { expose: t, emit: n }) { const o = e, r = js(), { lang: s } = Nt(), l = Ie("date"), a = Ie("input"), u = Ie("range"), { form: c, formItem: d } = Zn(), f = Ye("ElPopperOptions", {}), p = M(), v = M(), m = M(!1), h = M(!1), g = M(null); let y = !1, C = !1; const b = S(() => [l.b("editor"), l.bm("editor", o.type), a.e("wrapper"), l.is("disabled", Z.value), l.is("active", m.value), u.b("editor"), Se ? u.bm("editor", Se.value) : "", r.class]), w = S(() => [a.e("icon"), u.e("close-icon"), fe.value ? "" : u.e("close-icon--hidden")]); Oe(m, J => { J ? Xe(() => { J && (g.value = o.modelValue); }) : ($e.value = null, Xe(() => { T(o.modelValue); })); }); const T = (J, we) => { (we || !h0(J, g.value)) && (n("change", J), o.validateEvent && (d == null || d.validate("change").catch(Ke => void 0))); }, E = J => { if (!h0(o.modelValue, J)) {
        let we;
        qe(J) ? we = J.map(Ke => m0(Ke, o.valueFormat, s.value)) : J && (we = m0(J, o.valueFormat, s.value)), n("update:modelValue", J && we, s.value);
    } }, x = J => { n("keydown", J); }, I = S(() => { if (v.value) {
        const J = Ne.value ? v.value : v.value.$el;
        return Array.from(J.querySelectorAll("input"));
    } return []; }), L = (J, we, Ke) => { const rt = I.value; rt.length && (!Ke || Ke === "min" ? (rt[0].setSelectionRange(J, we), rt[0].focus()) : Ke === "max" && (rt[1].setSelectionRange(J, we), rt[1].focus())); }, B = () => { j(!0, !0), Xe(() => { C = !1; }); }, F = (J = "", we = !1) => { we || (C = !0), m.value = we; let Ke; qe(J) ? Ke = J.map(rt => rt.toDate()) : Ke = J && J.toDate(), $e.value = null, E(Ke); }, V = () => { h.value = !0; }, R = () => { n("visible-change", !0); }, K = J => { (J == null ? void 0 : J.key) === tt.esc && j(!0, !0); }, te = () => { h.value = !1, m.value = !1, C = !1, n("visible-change", !1); }, U = () => { m.value = !0; }, D = () => { m.value = !1; }, j = (J = !0, we = !1) => { C = we; const [Ke, rt] = i(I); let _e = Ke; !J && Ne.value && (_e = rt), _e && _e.focus(); }, A = J => { o.readonly || Z.value || m.value || C || (m.value = !0, n("focus", J)); }; let G; const se = J => { const we = async () => { setTimeout(() => { var Ke; G === we && (!((Ke = p.value) != null && Ke.isFocusInsideContent() && !y) && I.value.filter(rt => rt.contains(document.activeElement)).length === 0 && (Pe(), m.value = !1, n("blur", J), o.validateEvent && (d == null || d.validate("blur").catch(rt => void 0))), y = !1); }, 0); }; G = we, we(); }, Z = S(() => o.disabled || (c == null ? void 0 : c.disabled)), ce = S(() => { let J; if (Ae.value ? H.value.getDefaultValue && (J = H.value.getDefaultValue()) : qe(o.modelValue) ? J = o.modelValue.map(we => v0(we, o.valueFormat, s.value)) : J = v0(o.modelValue, o.valueFormat, s.value), H.value.getRangeAvailableTime) {
        const we = H.value.getRangeAvailableTime(J);
        ro(we, J) || (J = we, E(qe(J) ? J.map(Ke => Ke.toDate()) : J.toDate()));
    } return qe(J) && J.some(we => !we) && (J = []), J; }), ye = S(() => { if (!H.value.panelReady)
        return ""; const J = je(ce.value); return qe($e.value) ? [$e.value[0] || J && J[0] || "", $e.value[1] || J && J[1] || ""] : $e.value !== null ? $e.value : !me.value && Ae.value || !m.value && Ae.value ? "" : J ? le.value ? J.join(", ") : J : ""; }), Re = S(() => o.type.includes("time")), me = S(() => o.type.startsWith("time")), le = S(() => o.type === "dates"), oe = S(() => o.prefixIcon || (Re.value ? M1 : o4)), fe = M(!1), Ce = J => { o.readonly || Z.value || fe.value && (J.stopPropagation(), B(), E(null), T(null, !0), fe.value = !1, m.value = !1, H.value.handleClear && H.value.handleClear()); }, Ae = S(() => { const { modelValue: J } = o; return !J || qe(J) && !J.filter(Boolean).length; }), q = async (J) => { var we; o.readonly || Z.value || (((we = J.target) == null ? void 0 : we.tagName) !== "INPUT" || I.value.includes(document.activeElement)) && (m.value = !0); }, re = () => { o.readonly || Z.value || !Ae.value && o.clearable && (fe.value = !0); }, he = () => { fe.value = !1; }, Ee = J => { var we; o.readonly || Z.value || (((we = J.touches[0].target) == null ? void 0 : we.tagName) !== "INPUT" || I.value.includes(document.activeElement)) && (m.value = !0); }, Ne = S(() => o.type.includes("range")), Se = kn(), De = S(() => { var J, we; return (we = (J = i(p)) == null ? void 0 : J.popperRef) == null ? void 0 : we.contentRef; }), Me = S(() => { var J; return i(Ne) ? i(v) : (J = i(v)) == null ? void 0 : J.$el; }); Kp(Me, J => { const we = i(De), Ke = i(Me); we && (J.target === we || J.composedPath().includes(we)) || J.target === Ke || J.composedPath().includes(Ke) || (m.value = !1); }); const $e = M(null), Pe = () => { if ($e.value) {
        const J = He(ye.value);
        J && Ue(J) && (E(qe(J) ? J.map(we => we.toDate()) : J.toDate()), $e.value = null);
    } $e.value === "" && (E(null), T(null), $e.value = null); }, He = J => J ? H.value.parseUserInput(J) : null, je = J => J ? H.value.formatToString(J) : null, Ue = J => H.value.isValidValue(J), Te = async (J) => { if (o.readonly || Z.value)
        return; const { code: we } = J; if (x(J), we === tt.esc) {
        m.value === !0 && (m.value = !1, J.preventDefault(), J.stopPropagation());
        return;
    } if (we === tt.down && (H.value.handleFocusPicker && (J.preventDefault(), J.stopPropagation()), m.value === !1 && (m.value = !0, await Xe()), H.value.handleFocusPicker)) {
        H.value.handleFocusPicker();
        return;
    } if (we === tt.tab) {
        y = !0;
        return;
    } if (we === tt.enter || we === tt.numpadEnter) {
        ($e.value === null || $e.value === "" || Ue(He(ye.value))) && (Pe(), m.value = !1), J.stopPropagation();
        return;
    } if ($e.value) {
        J.stopPropagation();
        return;
    } H.value.handleKeydownInput && H.value.handleKeydownInput(J); }, Ge = J => { $e.value = J, m.value || (m.value = !0); }, W = J => { const we = J.target; $e.value ? $e.value = [we.value, $e.value[1]] : $e.value = [we.value, null]; }, X = J => { const we = J.target; $e.value ? $e.value = [$e.value[0], we.value] : $e.value = [null, we.value]; }, $ = () => { var J; const we = $e.value, Ke = He(we && we[0]), rt = i(ce); if (Ke && Ke.isValid()) {
        $e.value = [je(Ke), ((J = ye.value) == null ? void 0 : J[1]) || null];
        const _e = [Ke, rt && (rt[1] || null)];
        Ue(_e) && (E(_e), $e.value = null);
    } }, Y = () => { var J; const we = i($e), Ke = He(we && we[1]), rt = i(ce); if (Ke && Ke.isValid()) {
        $e.value = [((J = i(ye)) == null ? void 0 : J[0]) || null, je(Ke)];
        const _e = [rt && rt[0], Ke];
        Ue(_e) && (E(_e), $e.value = null);
    } }, H = M({}), ue = J => { H.value[J[0]] = J[1], H.value.panelReady = !0; }, de = J => { n("calendar-change", J); }, be = (J, we, Ke) => { n("panel-change", J, we, Ke); }; return St("EP_PICKER_BASE", { props: o }), t({ focus: j, handleFocusInput: A, handleBlurInput: se, handleOpen: U, handleClose: D, onPick: F }), (J, we) => (k(), ge(i(Jn), Ct({ ref_key: "refPopper", ref: p, visible: m.value, effect: "light", pure: "", trigger: "click" }, J.$attrs, { role: "dialog", teleported: "", transition: `${i(l).namespace.value}-zoom-in-top`, "popper-class": [`${i(l).namespace.value}-picker__popper`, J.popperClass], "popper-options": i(f), "fallback-placements": ["bottom", "top", "right", "left"], "gpu-acceleration": !1, "stop-popper-mouse-event": !1, "hide-after": 0, persistent: "", onBeforeShow: V, onShow: R, onHide: te }), { default: ie(() => [i(Ne) ? (k(), z("div", { key: 1, ref_key: "inputRef", ref: v, class: O(i(b)), style: et(J.$attrs.style), onClick: A, onMouseenter: re, onMouseleave: he, onTouchstart: Ee, onKeydown: Te }, [i(oe) ? (k(), ge(i(Je), { key: 0, class: O([i(a).e("icon"), i(u).e("icon")]), onMousedown: st(q, ["prevent"]), onTouchstart: Ee }, { default: ie(() => [(k(), ge(kt(i(oe))))]), _: 1 }, 8, ["class", "onMousedown"])) : pe("v-if", !0), Q("input", { id: J.id && J.id[0], autocomplete: "off", name: J.name && J.name[0], placeholder: J.startPlaceholder, value: i(ye) && i(ye)[0], disabled: i(Z), readonly: !J.editable || J.readonly, class: O(i(u).b("input")), onMousedown: q, onInput: W, onChange: $, onFocus: A, onBlur: se }, null, 42, RF), ke(J.$slots, "range-separator", {}, () => [Q("span", { class: O(i(u).b("separator")) }, Be(J.rangeSeparator), 3)]), Q("input", { id: J.id && J.id[1], autocomplete: "off", name: J.name && J.name[1], placeholder: J.endPlaceholder, value: i(ye) && i(ye)[1], disabled: i(Z), readonly: !J.editable || J.readonly, class: O(i(u).b("input")), onMousedown: q, onFocus: A, onBlur: se, onInput: X, onChange: Y }, null, 42, LF), J.clearIcon ? (k(), ge(i(Je), { key: 1, class: O(i(w)), onClick: Ce }, { default: ie(() => [(k(), ge(kt(J.clearIcon)))]), _: 1 }, 8, ["class"])) : pe("v-if", !0)], 38)) : (k(), ge(i(Ln), { key: 0, id: J.id, ref_key: "inputRef", ref: v, "container-role": "combobox", "model-value": i(ye), name: J.name, size: i(Se), disabled: i(Z), placeholder: J.placeholder, class: O([i(l).b("editor"), i(l).bm("editor", J.type), J.$attrs.class]), style: et(J.$attrs.style), readonly: !J.editable || J.readonly || i(le) || J.type === "week", label: J.label, tabindex: J.tabindex, "validate-event": !1, onInput: Ge, onFocus: A, onBlur: se, onKeydown: Te, onChange: Pe, onMousedown: q, onMouseenter: re, onMouseleave: he, onTouchstart: Ee, onClick: we[0] || (we[0] = st(() => { }, ["stop"])) }, { prefix: ie(() => [i(oe) ? (k(), ge(i(Je), { key: 0, class: O(i(a).e("icon")), onMousedown: st(q, ["prevent"]), onTouchstart: Ee }, { default: ie(() => [(k(), ge(kt(i(oe))))]), _: 1 }, 8, ["class", "onMousedown"])) : pe("v-if", !0)]), suffix: ie(() => [fe.value && J.clearIcon ? (k(), ge(i(Je), { key: 0, class: O(`${i(a).e("icon")} clear-icon`), onClick: st(Ce, ["stop"]) }, { default: ie(() => [(k(), ge(kt(J.clearIcon)))]), _: 1 }, 8, ["class", "onClick"])) : pe("v-if", !0)]), _: 1 }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "label", "tabindex", "onKeydown"]))]), content: ie(() => [ke(J.$slots, "default", { visible: m.value, actualVisible: h.value, parsedValue: i(ce), format: J.format, unlinkPanels: J.unlinkPanels, type: J.type, defaultValue: J.defaultValue, onPick: F, onSelectRange: L, onSetPickerOption: ue, onCalendarChange: de, onPanelChange: be, onKeydown: K, onMousedown: we[1] || (we[1] = st(() => { }, ["stop"])) })]), _: 3 }, 16, ["visible", "transition", "popper-class", "popper-options"])); } });
var Qw = Fe(BF, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/common/picker.vue"]]);
const FF = Ve({ ...Zw, datetimeRole: String, parsedValue: { type: ve(Object) } }), eC = ({ getAvailableHours: e, getAvailableMinutes: t, getAvailableSeconds: n }) => { const o = (l, a, u, c) => { const d = { hour: e, minute: t, second: n }; let f = l; return ["hour", "minute", "second"].forEach(p => { if (d[p]) {
    let v;
    const m = d[p];
    switch (p) {
        case "minute": {
            v = m(f.hour(), a, c);
            break;
        }
        case "second": {
            v = m(f.hour(), f.minute(), a, c);
            break;
        }
        default: {
            v = m(a, c);
            break;
        }
    }
    if (v != null && v.length && !v.includes(f[p]())) {
        const h = u ? 0 : v.length - 1;
        f = f[p](v[h]);
    }
} }), f; }, r = {}; return { timePickerOptions: r, getAvailableTime: o, onSetOption: ([l, a]) => { r[l] = a; } }; }, Ad = e => { const t = (o, r) => o || r, n = o => o !== !0; return e.map(t).filter(n); }, tC = (e, t, n) => ({ getHoursList: (l, a) => xd(24, e && (() => e == null ? void 0 : e(l, a))), getMinutesList: (l, a, u) => xd(60, t && (() => t == null ? void 0 : t(l, a, u))), getSecondsList: (l, a, u, c) => xd(60, n && (() => n == null ? void 0 : n(l, a, u, c))) }), nC = (e, t, n) => { const { getHoursList: o, getMinutesList: r, getSecondsList: s } = tC(e, t, n); return { getAvailableHours: (c, d) => Ad(o(c, d)), getAvailableMinutes: (c, d, f) => Ad(r(c, d, f)), getAvailableSeconds: (c, d, f, p) => Ad(s(c, d, f, p)) }; }, oC = e => { const t = M(e.parsedValue); return Oe(() => e.visible, n => { n || (t.value = e.parsedValue); }), t; }, Br = new Map;
let g0;
At && (document.addEventListener("mousedown", e => g0 = e), document.addEventListener("mouseup", e => { for (const t of Br.values())
    for (const { documentHandler: n } of t)
        n(e, g0); }));
function y0(e, t) { let n = []; return Array.isArray(t.arg) ? n = t.arg : To(t.arg) && n.push(t.arg), function (o, r) { const s = t.instance.popperRef, l = o.target, a = r == null ? void 0 : r.target, u = !t || !t.instance, c = !l || !a, d = e.contains(l) || e.contains(a), f = e === l, p = n.length && n.some(m => m == null ? void 0 : m.contains(l)) || n.length && n.includes(a), v = s && (s.contains(l) || s.contains(a)); u || c || d || f || p || v || t.value(o, r); }; }
const ns = { beforeMount(e, t) { Br.has(e) || Br.set(e, []), Br.get(e).push({ documentHandler: y0(e, t), bindingFn: t.value }); }, updated(e, t) { Br.has(e) || Br.set(e, []); const n = Br.get(e), o = n.findIndex(s => s.bindingFn === t.oldValue), r = { documentHandler: y0(e, t), bindingFn: t.value }; o >= 0 ? n.splice(o, 1, r) : n.push(r); }, unmounted(e) { Br.delete(e); } }, VF = 100, zF = 600, Yu = { beforeMount(e, t) { const n = t.value, { interval: o = VF, delay: r = zF } = at(n) ? {} : n; let s, l; const a = () => at(n) ? n() : n.handler(), u = () => { l && (clearTimeout(l), l = void 0), s && (clearInterval(s), s = void 0); }; e.addEventListener("mousedown", c => { c.button === 0 && (u(), a(), document.addEventListener("mouseup", () => u(), { once: !0 }), l = setTimeout(() => { s = setInterval(() => { a(); }, o); }, r)); }); } }, Of = "_trap-focus-children", Os = [], b0 = e => { if (Os.length === 0)
    return; const t = Os[Os.length - 1][Of]; if (t.length > 0 && e.code === tt.tab) {
    if (t.length === 1) {
        e.preventDefault(), document.activeElement !== t[0] && t[0].focus();
        return;
    }
    const n = e.shiftKey, o = e.target === t[0], r = e.target === t[t.length - 1];
    o && n && (e.preventDefault(), t[t.length - 1].focus()), r && !n && (e.preventDefault(), t[0].focus());
} }, HF = { beforeMount(e) { e[Of] = Am(e), Os.push(e), Os.length <= 1 && document.addEventListener("keydown", b0); }, updated(e) { Xe(() => { e[Of] = Am(e); }); }, unmounted() { Os.shift(), Os.length === 0 && document.removeEventListener("keydown", b0); } };
var w0 = !1, _s, If, xf, pu, hu, rC, vu, Af, Mf, Nf, sC, Pf, Rf, lC, aC;
function to() { if (!w0) {
    w0 = !0;
    var e = navigator.userAgent, t = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), n = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
    if (Pf = /\b(iPhone|iP[ao]d)/.exec(e), Rf = /\b(iP[ao]d)/.exec(e), Nf = /Android/i.exec(e), lC = /FBAN\/\w+;/i.exec(e), aC = /Mobile/i.exec(e), sC = !!/Win64/.exec(e), t) {
        _s = t[1] ? parseFloat(t[1]) : t[5] ? parseFloat(t[5]) : NaN, _s && document && document.documentMode && (_s = document.documentMode);
        var o = /(?:Trident\/(\d+.\d+))/.exec(e);
        rC = o ? parseFloat(o[1]) + 4 : _s, If = t[2] ? parseFloat(t[2]) : NaN, xf = t[3] ? parseFloat(t[3]) : NaN, pu = t[4] ? parseFloat(t[4]) : NaN, pu ? (t = /(?:Chrome\/(\d+\.\d+))/.exec(e), hu = t && t[1] ? parseFloat(t[1]) : NaN) : hu = NaN;
    }
    else
        _s = If = xf = hu = pu = NaN;
    if (n) {
        if (n[1]) {
            var r = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
            vu = r ? parseFloat(r[1].replace("_", ".")) : !0;
        }
        else
            vu = !1;
        Af = !!n[2], Mf = !!n[3];
    }
    else
        vu = Af = Mf = !1;
} }
var Lf = { ie: function () { return to() || _s; }, ieCompatibilityMode: function () { return to() || rC > _s; }, ie64: function () { return Lf.ie() && sC; }, firefox: function () { return to() || If; }, opera: function () { return to() || xf; }, webkit: function () { return to() || pu; }, safari: function () { return Lf.webkit(); }, chrome: function () { return to() || hu; }, windows: function () { return to() || Af; }, osx: function () { return to() || vu; }, linux: function () { return to() || Mf; }, iphone: function () { return to() || Pf; }, mobile: function () { return to() || Pf || Rf || Nf || aC; }, nativeApp: function () { return to() || lC; }, android: function () { return to() || Nf; }, ipad: function () { return to() || Rf; } }, KF = Lf, Ji = !!(typeof window < "u" && window.document && window.document.createElement), jF = { canUseDOM: Ji, canUseWorkers: typeof Worker < "u", canUseEventListeners: Ji && !!(window.addEventListener || window.attachEvent), canUseViewport: Ji && !!window.screen, isInWorker: !Ji }, iC = jF, uC;
iC.canUseDOM && (uC = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
function WF(e, t) { if (!iC.canUseDOM || t && !("addEventListener" in document))
    return !1; var n = "on" + e, o = n in document; if (!o) {
    var r = document.createElement("div");
    r.setAttribute(n, "return;"), o = typeof r[n] == "function";
} return !o && uC && e === "wheel" && (o = document.implementation.hasFeature("Events.wheel", "3.0")), o; }
var UF = WF, C0 = 10, S0 = 40, _0 = 800;
function cC(e) { var t = 0, n = 0, o = 0, r = 0; return "detail" in e && (n = e.detail), "wheelDelta" in e && (n = -e.wheelDelta / 120), "wheelDeltaY" in e && (n = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = n, n = 0), o = t * C0, r = n * C0, "deltaY" in e && (r = e.deltaY), "deltaX" in e && (o = e.deltaX), (o || r) && e.deltaMode && (e.deltaMode == 1 ? (o *= S0, r *= S0) : (o *= _0, r *= _0)), o && !t && (t = o < 1 ? -1 : 1), r && !n && (n = r < 1 ? -1 : 1), { spinX: t, spinY: n, pixelX: o, pixelY: r }; }
cC.getEventType = function () { return KF.firefox() ? "DOMMouseScroll" : UF("wheel") ? "wheel" : "mousewheel"; };
var qF = cC; /**
* Checks if an event is supported in the current execution environment.
*
* NOTE: This will not work correctly for non-generic events such as `change`,
* `reset`, `load`, `error`, and `select`.
*
* Borrows from Modernizr.
*
* @param {string} eventNameSuffix Event name, e.g. "click".
* @param {?boolean} capture Check if the capture phase is supported.
* @return {boolean} True if the event is supported.
* @internal
* @license Modernizr 3.0.0pre (Custom Build) | MIT
*/
const YF = function (e, t) { if (e && e.addEventListener) {
    const n = function (o) { const r = qF(o); t && Reflect.apply(t, this, [o, r]); };
    e.addEventListener("wheel", n, { passive: !0 });
} }, GF = { beforeMount(e, t) { YF(e, t.value); } }, XF = Ve({ role: { type: String, required: !0 }, spinnerDate: { type: ve(Object), required: !0 }, showSeconds: { type: Boolean, default: !0 }, arrowControl: Boolean, amPmMode: { type: ve(String), default: "" }, ...Jw }), JF = ["onClick"], ZF = ["onMouseenter"], QF = ae({ __name: "basic-time-spinner", props: XF, emits: ["change", "select-range", "set-option"], setup(e, { emit: t }) { const n = e, o = Ie("time"), { getHoursList: r, getMinutesList: s, getSecondsList: l } = tC(n.disabledHours, n.disabledMinutes, n.disabledSeconds); let a = !1; const u = M(), c = M(), d = M(), f = M(), p = { hours: c, minutes: d, seconds: f }, v = S(() => n.showSeconds ? f0 : f0.slice(0, 2)), m = S(() => { const { spinnerDate: A } = n, G = A.hour(), se = A.minute(), Z = A.second(); return { hours: G, minutes: se, seconds: Z }; }), h = S(() => { const { hours: A, minutes: G } = i(m); return { hours: r(n.role), minutes: s(A, n.role), seconds: l(A, G, n.role) }; }), g = S(() => { const { hours: A, minutes: G, seconds: se } = i(m); return { hours: Id(A, 23), minutes: Id(G, 59), seconds: Id(se, 59) }; }), y = Xn(A => { a = !1, w(A); }, 200), C = A => { if (!!!n.amPmMode)
        return ""; const se = n.amPmMode === "A"; let Z = A < 12 ? " am" : " pm"; return se && (Z = Z.toUpperCase()), Z; }, b = A => { let G; switch (A) {
        case "hours":
            G = [0, 2];
            break;
        case "minutes":
            G = [3, 5];
            break;
        case "seconds":
            G = [6, 8];
            break;
    } const [se, Z] = G; t("select-range", se, Z), u.value = A; }, w = A => { x(A, i(m)[A]); }, T = () => { w("hours"), w("minutes"), w("seconds"); }, E = A => A.querySelector(`.${o.namespace.value}-scrollbar__wrap`), x = (A, G) => { if (n.arrowControl)
        return; const se = i(p[A]); se && se.$el && (E(se.$el).scrollTop = Math.max(0, G * I(A))); }, I = A => { const G = i(p[A]), se = G == null ? void 0 : G.$el.querySelector("li"); return se && Number.parseFloat(Kr(se, "height")) || 0; }, L = () => { F(1); }, B = () => { F(-1); }, F = A => { u.value || b("hours"); const G = u.value, se = i(m)[G], Z = u.value === "hours" ? 24 : 60, ce = V(G, se, A, Z); R(G, ce), x(G, ce), Xe(() => b(G)); }, V = (A, G, se, Z) => { let ce = (G + se + Z) % Z; const ye = i(h)[A]; for (; ye[ce] && ce !== G;)
        ce = (ce + se + Z) % Z; return ce; }, R = (A, G) => { if (i(h)[A][G])
        return; const { hours: ce, minutes: ye, seconds: Re } = i(m); let me; switch (A) {
        case "hours":
            me = n.spinnerDate.hour(G).minute(ye).second(Re);
            break;
        case "minutes":
            me = n.spinnerDate.hour(ce).minute(G).second(Re);
            break;
        case "seconds":
            me = n.spinnerDate.hour(ce).minute(ye).second(G);
            break;
    } t("change", me); }, K = (A, { value: G, disabled: se }) => { se || (R(A, G), b(A), x(A, G)); }, te = A => { a = !0, y(A); const G = Math.min(Math.round((E(i(p[A]).$el).scrollTop - (U(A) * .5 - 10) / I(A) + 3) / I(A)), A === "hours" ? 23 : 59); R(A, G); }, U = A => i(p[A]).$el.offsetHeight, D = () => { const A = G => { const se = i(p[G]); se && se.$el && (E(se.$el).onscroll = () => { te(G); }); }; A("hours"), A("minutes"), A("seconds"); }; ft(() => { Xe(() => { !n.arrowControl && D(), T(), n.role === "start" && b("hours"); }); }); const j = (A, G) => { p[G].value = A; }; return t("set-option", [`${n.role}_scrollDown`, F]), t("set-option", [`${n.role}_emitSelectRange`, b]), Oe(() => n.spinnerDate, () => { a || T(); }), (A, G) => (k(), z("div", { class: O([i(o).b("spinner"), { "has-seconds": A.showSeconds }]) }, [A.arrowControl ? pe("v-if", !0) : (k(!0), z(Qe, { key: 0 }, Et(i(v), se => (k(), ge(i(Or), { key: se, ref_for: !0, ref: Z => j(Z, se), class: O(i(o).be("spinner", "wrapper")), "wrap-style": "max-height: inherit;", "view-class": i(o).be("spinner", "list"), noresize: "", tag: "ul", onMouseenter: Z => b(se), onMousemove: Z => w(se) }, { default: ie(() => [(k(!0), z(Qe, null, Et(i(h)[se], (Z, ce) => (k(), z("li", { key: ce, class: O([i(o).be("spinner", "item"), i(o).is("active", ce === i(m)[se]), i(o).is("disabled", Z)]), onClick: ye => K(se, { value: ce, disabled: Z }) }, [se === "hours" ? (k(), z(Qe, { key: 0 }, [Ot(Be(("0" + (A.amPmMode ? ce % 12 || 12 : ce)).slice(-2)) + Be(C(ce)), 1)], 64)) : (k(), z(Qe, { key: 1 }, [Ot(Be(("0" + ce).slice(-2)), 1)], 64))], 10, JF))), 128))]), _: 2 }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"]))), 128)), A.arrowControl ? (k(!0), z(Qe, { key: 1 }, Et(i(v), se => (k(), z("div", { key: se, class: O([i(o).be("spinner", "wrapper"), i(o).is("arrow")]), onMouseenter: Z => b(se) }, [dt((k(), ge(i(Je), { class: O(["arrow-up", i(o).be("spinner", "arrow")]) }, { default: ie(() => [ee(i(Ic))]), _: 1 }, 8, ["class"])), [[i(Yu), B]]), dt((k(), ge(i(Je), { class: O(["arrow-down", i(o).be("spinner", "arrow")]) }, { default: ie(() => [ee(i(ss))]), _: 1 }, 8, ["class"])), [[i(Yu), L]]), Q("ul", { class: O(i(o).be("spinner", "list")) }, [(k(!0), z(Qe, null, Et(i(g)[se], (Z, ce) => (k(), z("li", { key: ce, class: O([i(o).be("spinner", "item"), i(o).is("active", Z === i(m)[se]), i(o).is("disabled", i(h)[se][Z])]) }, [typeof Z == "number" ? (k(), z(Qe, { key: 0 }, [se === "hours" ? (k(), z(Qe, { key: 0 }, [Ot(Be(("0" + (A.amPmMode ? Z % 12 || 12 : Z)).slice(-2)) + Be(C(Z)), 1)], 64)) : (k(), z(Qe, { key: 1 }, [Ot(Be(("0" + Z).slice(-2)), 1)], 64))], 64)) : pe("v-if", !0)], 2))), 128))], 2)], 42, ZF))), 128)) : pe("v-if", !0)], 2)); } });
var Df = Fe(QF, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/basic-time-spinner.vue"]]);
const e5 = ae({ __name: "panel-time-pick", props: FF, emits: ["pick", "select-range", "set-picker-option"], setup(e, { emit: t }) { const n = e, o = Ye("EP_PICKER_BASE"), { arrowControl: r, disabledHours: s, disabledMinutes: l, disabledSeconds: a, defaultValue: u } = o.props, { getAvailableHours: c, getAvailableMinutes: d, getAvailableSeconds: f } = nC(s, l, a), p = Ie("time"), { t: v, lang: m } = Nt(), h = M([0, 2]), g = oC(n), y = S(() => En(n.actualVisible) ? `${p.namespace.value}-zoom-in-top` : ""), C = S(() => n.format.includes("ss")), b = S(() => n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : ""), w = j => { const A = pt(j).locale(m.value), G = K(A); return A.isSame(G); }, T = () => { t("pick", g.value, !1); }, E = (j = !1, A = !1) => { A || t("pick", n.parsedValue, j); }, x = j => { if (!n.visible)
        return; const A = K(j).millisecond(0); t("pick", A, !0); }, I = (j, A) => { t("select-range", j, A), h.value = [j, A]; }, L = j => { const A = [0, 3].concat(C.value ? [6] : []), G = ["hours", "minutes"].concat(C.value ? ["seconds"] : []), Z = (A.indexOf(h.value[0]) + j + A.length) % A.length; F.start_emitSelectRange(G[Z]); }, B = j => { const A = j.code, { left: G, right: se, up: Z, down: ce } = tt; if ([G, se].includes(A)) {
        L(A === G ? -1 : 1), j.preventDefault();
        return;
    } if ([Z, ce].includes(A)) {
        const ye = A === Z ? -1 : 1;
        F.start_scrollDown(ye), j.preventDefault();
        return;
    } }, { timePickerOptions: F, onSetOption: V, getAvailableTime: R } = eC({ getAvailableHours: c, getAvailableMinutes: d, getAvailableSeconds: f }), K = j => R(j, n.datetimeRole || "", !0), te = j => j ? pt(j, n.format).locale(m.value) : null, U = j => j ? j.format(n.format) : null, D = () => pt(u).locale(m.value); return t("set-picker-option", ["isValidValue", w]), t("set-picker-option", ["formatToString", U]), t("set-picker-option", ["parseUserInput", te]), t("set-picker-option", ["handleKeydownInput", B]), t("set-picker-option", ["getRangeAvailableTime", K]), t("set-picker-option", ["getDefaultValue", D]), (j, A) => (k(), ge(yn, { name: i(y) }, { default: ie(() => [j.actualVisible || j.visible ? (k(), z("div", { key: 0, class: O(i(p).b("panel")) }, [Q("div", { class: O([i(p).be("panel", "content"), { "has-seconds": i(C) }]) }, [ee(Df, { ref: "spinner", role: j.datetimeRole || "start", "arrow-control": i(r), "show-seconds": i(C), "am-pm-mode": i(b), "spinner-date": j.parsedValue, "disabled-hours": i(s), "disabled-minutes": i(l), "disabled-seconds": i(a), onChange: x, onSetOption: i(V), onSelectRange: I }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onSetOption"])], 2), Q("div", { class: O(i(p).be("panel", "footer")) }, [Q("button", { type: "button", class: O([i(p).be("panel", "btn"), "cancel"]), onClick: T }, Be(i(v)("el.datepicker.cancel")), 3), Q("button", { type: "button", class: O([i(p).be("panel", "btn"), "confirm"]), onClick: A[0] || (A[0] = G => E()) }, Be(i(v)("el.datepicker.confirm")), 3)], 2)], 2)) : pe("v-if", !0)]), _: 1 }, 8, ["name"])); } });
var Gu = Fe(e5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-pick.vue"]]);
const t5 = Ve({ ...Zw, parsedValue: { type: ve(Array) } }), n5 = ["disabled"], o5 = ae({ __name: "panel-time-range", props: t5, emits: ["pick", "select-range", "set-picker-option"], setup(e, { emit: t }) { const n = e, o = (Ae, q) => { const re = []; for (let he = Ae; he <= q; he++)
        re.push(he); return re; }, { t: r, lang: s } = Nt(), l = Ie("time"), a = Ie("picker"), u = Ye("EP_PICKER_BASE"), { arrowControl: c, disabledHours: d, disabledMinutes: f, disabledSeconds: p, defaultValue: v } = u.props, m = S(() => [l.be("range-picker", "body"), l.be("panel", "content"), l.is("arrow", c), w.value ? "has-seconds" : ""]), h = S(() => [l.be("range-picker", "body"), l.be("panel", "content"), l.is("arrow", c), w.value ? "has-seconds" : ""]), g = S(() => n.parsedValue[0]), y = S(() => n.parsedValue[1]), C = oC(n), b = () => { t("pick", C.value, !1); }, w = S(() => n.format.includes("ss")), T = S(() => n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : ""), E = (Ae = !1) => { t("pick", [g.value, y.value], Ae); }, x = Ae => { B(Ae.millisecond(0), y.value); }, I = Ae => { B(g.value, Ae.millisecond(0)); }, L = Ae => { const q = Ae.map(he => pt(he).locale(s.value)), re = se(q); return q[0].isSame(re[0]) && q[1].isSame(re[1]); }, B = (Ae, q) => { t("pick", [Ae, q], !0); }, F = S(() => g.value > y.value), V = M([0, 2]), R = (Ae, q) => { t("select-range", Ae, q, "min"), V.value = [Ae, q]; }, K = S(() => w.value ? 11 : 8), te = (Ae, q) => { t("select-range", Ae, q, "max"); const re = i(K); V.value = [Ae + re, q + re]; }, U = Ae => { const q = w.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11], re = ["hours", "minutes"].concat(w.value ? ["seconds"] : []), Ee = (q.indexOf(V.value[0]) + Ae + q.length) % q.length, Ne = q.length / 2; Ee < Ne ? Re.start_emitSelectRange(re[Ee]) : Re.end_emitSelectRange(re[Ee - Ne]); }, D = Ae => { const q = Ae.code, { left: re, right: he, up: Ee, down: Ne } = tt; if ([re, he].includes(q)) {
        U(q === re ? -1 : 1), Ae.preventDefault();
        return;
    } if ([Ee, Ne].includes(q)) {
        const Se = q === Ee ? -1 : 1, De = V.value[0] < K.value ? "start" : "end";
        Re[`${De}_scrollDown`](Se), Ae.preventDefault();
        return;
    } }, j = (Ae, q) => { const re = d ? d(Ae) : [], he = Ae === "start", Ne = (q || (he ? y.value : g.value)).hour(), Se = he ? o(Ne + 1, 23) : o(0, Ne - 1); return Cd(re, Se); }, A = (Ae, q, re) => { const he = f ? f(Ae, q) : [], Ee = q === "start", Ne = re || (Ee ? y.value : g.value), Se = Ne.hour(); if (Ae !== Se)
        return he; const De = Ne.minute(), Me = Ee ? o(De + 1, 59) : o(0, De - 1); return Cd(he, Me); }, G = (Ae, q, re, he) => { const Ee = p ? p(Ae, q, re) : [], Ne = re === "start", Se = he || (Ne ? y.value : g.value), De = Se.hour(), Me = Se.minute(); if (Ae !== De || q !== Me)
        return Ee; const $e = Se.second(), Pe = Ne ? o($e + 1, 59) : o(0, $e - 1); return Cd(Ee, Pe); }, se = ([Ae, q]) => [me(Ae, "start", !0, q), me(q, "end", !1, Ae)], { getAvailableHours: Z, getAvailableMinutes: ce, getAvailableSeconds: ye } = nC(j, A, G), { timePickerOptions: Re, getAvailableTime: me, onSetOption: le } = eC({ getAvailableHours: Z, getAvailableMinutes: ce, getAvailableSeconds: ye }), oe = Ae => Ae ? qe(Ae) ? Ae.map(q => pt(q, n.format).locale(s.value)) : pt(Ae, n.format).locale(s.value) : null, fe = Ae => Ae ? qe(Ae) ? Ae.map(q => q.format(n.format)) : Ae.format(n.format) : null, Ce = () => { if (qe(v))
        return v.map(q => pt(q).locale(s.value)); const Ae = pt(v).locale(s.value); return [Ae, Ae.add(60, "m")]; }; return t("set-picker-option", ["formatToString", fe]), t("set-picker-option", ["parseUserInput", oe]), t("set-picker-option", ["isValidValue", L]), t("set-picker-option", ["handleKeydownInput", D]), t("set-picker-option", ["getDefaultValue", Ce]), t("set-picker-option", ["getRangeAvailableTime", se]), (Ae, q) => Ae.actualVisible ? (k(), z("div", { key: 0, class: O([i(l).b("range-picker"), i(a).b("panel")]) }, [Q("div", { class: O(i(l).be("range-picker", "content")) }, [Q("div", { class: O(i(l).be("range-picker", "cell")) }, [Q("div", { class: O(i(l).be("range-picker", "header")) }, Be(i(r)("el.datepicker.startTime")), 3), Q("div", { class: O(i(m)) }, [ee(Df, { ref: "minSpinner", role: "start", "show-seconds": i(w), "am-pm-mode": i(T), "arrow-control": i(c), "spinner-date": i(g), "disabled-hours": j, "disabled-minutes": A, "disabled-seconds": G, onChange: x, onSetOption: i(le), onSelectRange: R }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])], 2)], 2), Q("div", { class: O(i(l).be("range-picker", "cell")) }, [Q("div", { class: O(i(l).be("range-picker", "header")) }, Be(i(r)("el.datepicker.endTime")), 3), Q("div", { class: O(i(h)) }, [ee(Df, { ref: "maxSpinner", role: "end", "show-seconds": i(w), "am-pm-mode": i(T), "arrow-control": i(c), "spinner-date": i(y), "disabled-hours": j, "disabled-minutes": A, "disabled-seconds": G, onChange: I, onSetOption: i(le), onSelectRange: te }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])], 2)], 2)], 2), Q("div", { class: O(i(l).be("panel", "footer")) }, [Q("button", { type: "button", class: O([i(l).be("panel", "btn"), "cancel"]), onClick: q[0] || (q[0] = re => b()) }, Be(i(r)("el.datepicker.cancel")), 3), Q("button", { type: "button", class: O([i(l).be("panel", "btn"), "confirm"]), disabled: i(F), onClick: q[1] || (q[1] = re => E()) }, Be(i(r)("el.datepicker.confirm")), 11, n5)], 2)], 2)) : pe("v-if", !0); } });
var r5 = Fe(o5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-range.vue"]]);
pt.extend(Mh);
var s5 = ae({ name: "ElTimePicker", install: null, props: { ...Nh, isRange: { type: Boolean, default: !1 } }, emits: ["update:modelValue"], setup(e, t) { const n = M(), [o, r] = e.isRange ? ["timerange", r5] : ["time", Gu], s = l => t.emit("update:modelValue", l); return St("ElPopperOptions", e.popperOptions), t.expose({ focus: l => { var a; (a = n.value) == null || a.handleFocusInput(l); }, blur: l => { var a; (a = n.value) == null || a.handleBlurInput(l); }, handleOpen: () => { var l; (l = n.value) == null || l.handleOpen(); }, handleClose: () => { var l; (l = n.value) == null || l.handleClose(); } }), () => { var l; const a = (l = e.format) != null ? l : Tf; return ee(Qw, Ct(e, { ref: n, type: o, format: a, "onUpdate:modelValue": s }), { default: u => ee(r, u, null) }); }; } });
const mu = s5;
mu.install = e => { e.component(mu.name, mu); };
const l5 = mu, a5 = (e, t) => { const n = e.subtract(1, "month").endOf("month").date(); return Gr(t).map((o, r) => n - (t - r - 1)); }, i5 = e => { const t = e.daysInMonth(); return Gr(t).map((n, o) => o + 1); }, u5 = e => Gr(e.length / 7).map(t => { const n = t * 7; return e.slice(n, n + 7); }), c5 = Ve({ selectedDay: { type: ve(Object) }, range: { type: ve(Array) }, date: { type: ve(Object), required: !0 }, hideHeader: { type: Boolean } }), d5 = { pick: e => yt(e) };
var dC = { exports: {} };
(function (e, t) { (function (n, o) { e.exports = o(); })(ko, function () { return function (n, o, r) { var s = o.prototype, l = function (f) { return f && (f.indexOf ? f : f.s); }, a = function (f, p, v, m, h) { var g = f.name ? f : f.$locale(), y = l(g[p]), C = l(g[v]), b = y || C.map(function (T) { return T.slice(0, m); }); if (!h)
    return b; var w = g.weekStart; return b.map(function (T, E) { return b[(E + (w || 0)) % 7]; }); }, u = function () { return r.Ls[r.locale()]; }, c = function (f, p) { return f.formats[p] || function (v) { return v.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (m, h, g) { return h || g.slice(1); }); }(f.formats[p.toUpperCase()]); }, d = function () { var f = this; return { months: function (p) { return p ? p.format("MMMM") : a(f, "months"); }, monthsShort: function (p) { return p ? p.format("MMM") : a(f, "monthsShort", "months", 3); }, firstDayOfWeek: function () { return f.$locale().weekStart || 0; }, weekdays: function (p) { return p ? p.format("dddd") : a(f, "weekdays"); }, weekdaysMin: function (p) { return p ? p.format("dd") : a(f, "weekdaysMin", "weekdays", 2); }, weekdaysShort: function (p) { return p ? p.format("ddd") : a(f, "weekdaysShort", "weekdays", 3); }, longDateFormat: function (p) { return c(f.$locale(), p); }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal }; }; s.localeData = function () { return d.bind(this)(); }, r.localeData = function () { var f = u(); return { firstDayOfWeek: function () { return f.weekStart || 0; }, weekdays: function () { return r.weekdays(); }, weekdaysShort: function () { return r.weekdaysShort(); }, weekdaysMin: function () { return r.weekdaysMin(); }, months: function () { return r.months(); }, monthsShort: function () { return r.monthsShort(); }, longDateFormat: function (p) { return c(f, p); }, meridiem: f.meridiem, ordinal: f.ordinal }; }, r.months = function () { return a(u(), "months"); }, r.monthsShort = function () { return a(u(), "monthsShort", "months", 3); }, r.weekdays = function (f) { return a(u(), "weekdays", null, null, f); }, r.weekdaysShort = function (f) { return a(u(), "weekdaysShort", "weekdays", 3, f); }, r.weekdaysMin = function (f) { return a(u(), "weekdaysMin", "weekdays", 2, f); }; }; }); })(dC);
var f5 = dC.exports;
const fC = lr(f5), p5 = (e, t) => { pt.extend(fC); const n = pt.localeData().firstDayOfWeek(), { t: o, lang: r } = Nt(), s = pt().locale(r.value), l = S(() => !!e.range && !!e.range.length), a = S(() => { let p = []; if (l.value) {
    const [v, m] = e.range, h = Gr(m.date() - v.date() + 1).map(C => ({ text: v.date() + C, type: "current" }));
    let g = h.length % 7;
    g = g === 0 ? 0 : 7 - g;
    const y = Gr(g).map((C, b) => ({ text: b + 1, type: "next" }));
    p = h.concat(y);
}
else {
    const v = e.date.startOf("month").day(), m = a5(e.date, (v - n + 7) % 7).map(C => ({ text: C, type: "prev" })), h = i5(e.date).map(C => ({ text: C, type: "current" }));
    p = [...m, ...h];
    const g = 7 - (p.length % 7 || 7), y = Gr(g).map((C, b) => ({ text: b + 1, type: "next" }));
    p = p.concat(y);
} return u5(p); }), u = S(() => { const p = n; return p === 0 ? Sd.map(v => o(`el.datepicker.weeks.${v}`)) : Sd.slice(p).concat(Sd.slice(0, p)).map(v => o(`el.datepicker.weeks.${v}`)); }), c = (p, v) => { switch (v) {
    case "prev": return e.date.startOf("month").subtract(1, "month").date(p);
    case "next": return e.date.startOf("month").add(1, "month").date(p);
    case "current": return e.date.date(p);
} }; return { now: s, isInRange: l, rows: a, weekDays: u, getFormattedDate: c, handlePickDay: ({ text: p, type: v }) => { const m = c(p, v); t("pick", m); }, getSlotData: ({ text: p, type: v }) => { const m = c(p, v); return { isSelected: m.isSame(e.selectedDay), type: `${v}-month`, day: m.format("YYYY-MM-DD"), date: m.toDate() }; } }; }, h5 = { key: 0 }, v5 = ["onClick"], m5 = ae({ name: "DateTable" }), g5 = ae({ ...m5, props: c5, emits: d5, setup(e, { expose: t, emit: n }) { const o = e, { isInRange: r, now: s, rows: l, weekDays: a, getFormattedDate: u, handlePickDay: c, getSlotData: d } = p5(o, n), f = Ie("calendar-table"), p = Ie("calendar-day"), v = ({ text: m, type: h }) => { const g = [h]; if (h === "current") {
        const y = u(m, h);
        y.isSame(o.selectedDay, "day") && g.push(p.is("selected")), y.isSame(s, "day") && g.push(p.is("today"));
    } return g; }; return t({ getFormattedDate: u }), (m, h) => (k(), z("table", { class: O([i(f).b(), i(f).is("range", i(r))]), cellspacing: "0", cellpadding: "0" }, [m.hideHeader ? pe("v-if", !0) : (k(), z("thead", h5, [(k(!0), z(Qe, null, Et(i(a), g => (k(), z("th", { key: g }, Be(g), 1))), 128))])), Q("tbody", null, [(k(!0), z(Qe, null, Et(i(l), (g, y) => (k(), z("tr", { key: y, class: O({ [i(f).e("row")]: !0, [i(f).em("row", "hide-border")]: y === 0 && m.hideHeader }) }, [(k(!0), z(Qe, null, Et(g, (C, b) => (k(), z("td", { key: b, class: O(v(C)), onClick: w => i(c)(C) }, [Q("div", { class: O(i(p).b()) }, [ke(m.$slots, "date-cell", { data: i(d)(C) }, () => [Q("span", null, Be(C.text), 1)])], 2)], 10, v5))), 128))], 2))), 128))])], 2)); } });
var k0 = Fe(g5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/calendar/src/date-table.vue"]]);
const y5 = (e, t) => { const n = e.endOf("month"), o = t.startOf("month"), s = n.isSame(o, "week") ? o.add(1, "week") : o; return [[e, n], [s.startOf("week"), t]]; }, b5 = (e, t) => { const n = e.endOf("month"), o = e.add(1, "month").startOf("month"), r = n.isSame(o, "week") ? o.add(1, "week") : o, s = r.endOf("month"), l = t.startOf("month"), a = s.isSame(l, "week") ? l.add(1, "week") : l; return [[e, n], [r.startOf("week"), s], [a.startOf("week"), t]]; }, w5 = (e, t, n) => { const o = An(), { lang: r } = Nt(), s = M(), l = pt().locale(r.value), a = S({ get() { return e.modelValue ? c.value : s.value; }, set(y) { if (!y)
        return; s.value = y; const C = y.toDate(); t(qn, C), t(gt, C); } }), u = S(() => { if (!e.range)
    return []; const y = e.range.map(w => pt(w).locale(r.value)), [C, b] = y; return C.isAfter(b) ? [] : C.isSame(b, "month") ? m(C, b) : C.add(1, "month").month() !== b.month() ? [] : m(C, b); }), c = S(() => e.modelValue ? pt(e.modelValue).locale(r.value) : a.value || (u.value.length ? u.value[0][0] : l)), d = S(() => c.value.subtract(1, "month").date(1)), f = S(() => c.value.add(1, "month").date(1)), p = S(() => c.value.subtract(1, "year").date(1)), v = S(() => c.value.add(1, "year").date(1)), m = (y, C) => { const b = y.startOf("week"), w = C.endOf("week"), T = b.get("month"), E = w.get("month"); return T === E ? [[b, w]] : (T + 1) % 12 === E ? y5(b, w) : T + 2 === E || (T + 1) % 11 === E ? b5(b, w) : []; }, h = y => { a.value = y; }, g = y => { const b = { "prev-month": d.value, "next-month": f.value, "prev-year": p.value, "next-year": v.value, today: l }[y]; b.isSame(c.value, "day") || h(b); }; return tr({ from: '"dateCell"', replacement: '"date-cell"', scope: "ElCalendar", version: "2.3.0", ref: "https://element-plus.org/en-US/component/calendar.html#slots", type: "Slot" }, S(() => !!o.dateCell)), { calculateValidatedDateRange: m, date: c, realSelectedDay: a, pickDay: h, selectDate: g, validatedRange: u }; }, C5 = e => qe(e) && e.length === 2 && e.every(t => Fs(t)), S5 = Ve({ modelValue: { type: Date }, range: { type: ve(Array), validator: C5 } }), _5 = { [gt]: e => Fs(e), [qn]: e => Fs(e) }, k5 = "ElCalendar", E5 = ae({ name: k5 }), $5 = ae({ ...E5, props: S5, emits: _5, setup(e, { expose: t, emit: n }) { const o = e, r = Ie("calendar"), { calculateValidatedDateRange: s, date: l, pickDay: a, realSelectedDay: u, selectDate: c, validatedRange: d } = w5(o, n), { t: f } = Nt(), p = S(() => { const v = `el.datepicker.month${l.value.format("M")}`; return `${l.value.year()} ${f("el.datepicker.year")} ${f(v)}`; }); return t({ selectedDay: u, pickDay: a, selectDate: c, calculateValidatedDateRange: s }), (v, m) => (k(), z("div", { class: O(i(r).b()) }, [Q("div", { class: O(i(r).e("header")) }, [ke(v.$slots, "header", { date: i(p) }, () => [Q("div", { class: O(i(r).e("title")) }, Be(i(p)), 3), i(d).length === 0 ? (k(), z("div", { key: 0, class: O(i(r).e("button-group")) }, [ee(i(Uw), null, { default: ie(() => [ee(i(xn), { size: "small", onClick: m[0] || (m[0] = h => i(c)("prev-month")) }, { default: ie(() => [Ot(Be(i(f)("el.datepicker.prevMonth")), 1)]), _: 1 }), ee(i(xn), { size: "small", onClick: m[1] || (m[1] = h => i(c)("today")) }, { default: ie(() => [Ot(Be(i(f)("el.datepicker.today")), 1)]), _: 1 }), ee(i(xn), { size: "small", onClick: m[2] || (m[2] = h => i(c)("next-month")) }, { default: ie(() => [Ot(Be(i(f)("el.datepicker.nextMonth")), 1)]), _: 1 })]), _: 1 })], 2)) : pe("v-if", !0)])], 2), i(d).length === 0 ? (k(), z("div", { key: 0, class: O(i(r).e("body")) }, [ee(k0, { date: i(l), "selected-day": i(u), onPick: i(a) }, Cr({ _: 2 }, [v.$slots["date-cell"] || v.$slots.dateCell ? { name: "date-cell", fn: ie(h => [v.$slots["date-cell"] ? ke(v.$slots, "date-cell", Lo(Ct({ key: 0 }, h))) : ke(v.$slots, "dateCell", Lo(Ct({ key: 1 }, h)))]) } : void 0]), 1032, ["date", "selected-day", "onPick"])], 2)) : (k(), z("div", { key: 1, class: O(i(r).e("body")) }, [(k(!0), z(Qe, null, Et(i(d), (h, g) => (k(), ge(k0, { key: g, date: h[0], "selected-day": i(u), range: h, "hide-header": g !== 0, onPick: i(a) }, Cr({ _: 2 }, [v.$slots["date-cell"] || v.$slots.dateCell ? { name: "date-cell", fn: ie(y => [v.$slots["date-cell"] ? ke(v.$slots, "date-cell", Lo(Ct({ key: 0 }, y))) : ke(v.$slots, "dateCell", Lo(Ct({ key: 1 }, y)))]) } : void 0]), 1032, ["date", "selected-day", "range", "hide-header", "onPick"]))), 128))], 2))], 2)); } });
var T5 = Fe($5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/calendar/src/calendar.vue"]]);
const O5 = vt(T5), I5 = Ve({ header: { type: String, default: "" }, bodyStyle: { type: ve([String, Object, Array]), default: "" }, shadow: { type: String, values: ["always", "hover", "never"], default: "always" } }), x5 = ae({ name: "ElCard" }), A5 = ae({ ...x5, props: I5, setup(e) { const t = Ie("card"); return (n, o) => (k(), z("div", { class: O([i(t).b(), i(t).is(`${n.shadow}-shadow`)]) }, [n.$slots.header || n.header ? (k(), z("div", { key: 0, class: O(i(t).e("header")) }, [ke(n.$slots, "header", {}, () => [Ot(Be(n.header), 1)])], 2)) : pe("v-if", !0), Q("div", { class: O(i(t).e("body")), style: et(n.bodyStyle) }, [ke(n.$slots, "default")], 6)], 2)); } });
var M5 = Fe(A5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/card/src/card.vue"]]);
const N5 = vt(M5), P5 = Ve({ initialIndex: { type: Number, default: 0 }, height: { type: String, default: "" }, trigger: { type: String, values: ["hover", "click"], default: "hover" }, autoplay: { type: Boolean, default: !0 }, interval: { type: Number, default: 3e3 }, indicatorPosition: { type: String, values: ["", "none", "outside"], default: "" }, arrow: { type: String, values: ["always", "hover", "never"], default: "hover" }, type: { type: String, values: ["", "card"], default: "" }, loop: { type: Boolean, default: !0 }, direction: { type: String, values: ["horizontal", "vertical"], default: "horizontal" }, pauseOnHover: { type: Boolean, default: !0 } }), R5 = { change: (e, t) => [e, t].every(lt) }, pC = Symbol("carouselContextKey"), E0 = 300, L5 = (e, t, n) => { const { children: o, addChild: r, removeChild: s } = $h(ht(), "ElCarouselItem"), l = M(-1), a = M(null), u = M(!1), c = M(), d = M(0), f = S(() => e.arrow !== "never" && !i(m)), p = S(() => o.value.some(A => A.props.label.toString().length > 0)), v = S(() => e.type === "card"), m = S(() => e.direction === "vertical"), h = S(() => e.height !== "auto" ? { height: e.height } : { height: `${d.value}px`, overflow: "hidden" }), g = Rs(A => { T(A); }, E0, { trailing: !0 }), y = Rs(A => { R(A); }, E0); function C() { a.value && (clearInterval(a.value), a.value = null); } function b() { e.interval <= 0 || !e.autoplay || a.value || (a.value = setInterval(() => w(), e.interval)); } const w = () => { l.value < o.value.length - 1 ? l.value = l.value + 1 : e.loop && (l.value = 0); }; function T(A) { if (it(A)) {
    const Z = o.value.filter(ce => ce.props.name === A);
    Z.length > 0 && (A = o.value.indexOf(Z[0]));
} if (A = Number(A), Number.isNaN(A) || A !== Math.floor(A))
    return; const G = o.value.length, se = l.value; A < 0 ? l.value = e.loop ? G - 1 : 0 : A >= G ? l.value = e.loop ? 0 : G - 1 : l.value = A, se === l.value && E(se), U(); } function E(A) { o.value.forEach((G, se) => { G.translateItem(se, l.value, A); }); } function x(A, G) { var se, Z, ce, ye; const Re = i(o), me = Re.length; if (me === 0 || !A.states.inStage)
    return !1; const le = G + 1, oe = G - 1, fe = me - 1, Ce = Re[fe].states.active, Ae = Re[0].states.active, q = (Z = (se = Re[le]) == null ? void 0 : se.states) == null ? void 0 : Z.active, re = (ye = (ce = Re[oe]) == null ? void 0 : ce.states) == null ? void 0 : ye.active; return G === fe && Ae || q ? "left" : G === 0 && Ce || re ? "right" : !1; } function I() { u.value = !0, e.pauseOnHover && C(); } function L() { u.value = !1, b(); } function B(A) { i(m) || o.value.forEach((G, se) => { A === x(G, se) && (G.states.hover = !0); }); } function F() { i(m) || o.value.forEach(A => { A.states.hover = !1; }); } function V(A) { l.value = A; } function R(A) { e.trigger === "hover" && A !== l.value && (l.value = A); } function K() { T(l.value - 1); } function te() { T(l.value + 1); } function U() { C(), b(); } function D(A) { e.height === "auto" && (d.value = A); } Oe(() => l.value, (A, G) => { E(G), G > -1 && t("change", A, G); }), Oe(() => e.autoplay, A => { A ? b() : C(); }), Oe(() => e.loop, () => { T(l.value); }), Oe(() => e.interval, () => { U(); }), Oe(() => o.value, () => { o.value.length > 0 && T(e.initialIndex); }); const j = Xt(); return ft(() => { j.value = Vn(c.value, () => { E(); }), b(); }), on(() => { C(), c.value && j.value && j.value.stop(); }), St(pC, { root: c, isCardType: v, isVertical: m, items: o, loop: e.loop, addItem: r, removeItem: s, setActiveItem: T, setContainerHeight: D }), { root: c, activeIndex: l, arrowDisplay: f, hasLabel: p, hover: u, isCardType: v, items: o, isVertical: m, containerStyle: h, handleButtonEnter: B, handleButtonLeave: F, handleIndicatorClick: V, handleMouseEnter: I, handleMouseLeave: L, setActiveItem: T, prev: K, next: te, throttledArrowClick: g, throttledIndicatorHover: y }; }, D5 = ["onMouseenter", "onClick"], B5 = { key: 0 }, F5 = "ElCarousel", V5 = ae({ name: F5 }), z5 = ae({ ...V5, props: P5, emits: R5, setup(e, { expose: t, emit: n }) { const o = e, { root: r, activeIndex: s, arrowDisplay: l, hasLabel: a, hover: u, isCardType: c, items: d, isVertical: f, containerStyle: p, handleButtonEnter: v, handleButtonLeave: m, handleIndicatorClick: h, handleMouseEnter: g, handleMouseLeave: y, setActiveItem: C, prev: b, next: w, throttledArrowClick: T, throttledIndicatorHover: E } = L5(o, n), x = Ie("carousel"), I = S(() => { const B = [x.b(), x.m(o.direction)]; return i(c) && B.push(x.m("card")), B; }), L = S(() => { const B = [x.e("indicators"), x.em("indicators", o.direction)]; return i(a) && B.push(x.em("indicators", "labels")), o.indicatorPosition === "outside" && B.push(x.em("indicators", "outside")), i(f) && B.push(x.em("indicators", "right")), B; }); return t({ setActiveItem: C, prev: b, next: w }), (B, F) => (k(), z("div", { ref_key: "root", ref: r, class: O(i(I)), onMouseenter: F[6] || (F[6] = st((...V) => i(g) && i(g)(...V), ["stop"])), onMouseleave: F[7] || (F[7] = st((...V) => i(y) && i(y)(...V), ["stop"])) }, [Q("div", { class: O(i(x).e("container")), style: et(i(p)) }, [i(l) ? (k(), ge(yn, { key: 0, name: "carousel-arrow-left", persisted: "" }, { default: ie(() => [dt(Q("button", { type: "button", class: O([i(x).e("arrow"), i(x).em("arrow", "left")]), onMouseenter: F[0] || (F[0] = V => i(v)("left")), onMouseleave: F[1] || (F[1] = (...V) => i(m) && i(m)(...V)), onClick: F[2] || (F[2] = st(V => i(T)(i(s) - 1), ["stop"])) }, [ee(i(Je), null, { default: ie(() => [ee(i(Zr))]), _: 1 })], 34), [[Pt, (B.arrow === "always" || i(u)) && (o.loop || i(s) > 0)]])]), _: 1 })) : pe("v-if", !0), i(l) ? (k(), ge(yn, { key: 1, name: "carousel-arrow-right", persisted: "" }, { default: ie(() => [dt(Q("button", { type: "button", class: O([i(x).e("arrow"), i(x).em("arrow", "right")]), onMouseenter: F[3] || (F[3] = V => i(v)("right")), onMouseleave: F[4] || (F[4] = (...V) => i(m) && i(m)(...V)), onClick: F[5] || (F[5] = st(V => i(T)(i(s) + 1), ["stop"])) }, [ee(i(Je), null, { default: ie(() => [ee(i(Un))]), _: 1 })], 34), [[Pt, (B.arrow === "always" || i(u)) && (o.loop || i(s) < i(d).length - 1)]])]), _: 1 })) : pe("v-if", !0), ke(B.$slots, "default")], 6), B.indicatorPosition !== "none" ? (k(), z("ul", { key: 0, class: O(i(L)) }, [(k(!0), z(Qe, null, Et(i(d), (V, R) => (k(), z("li", { key: R, class: O([i(x).e("indicator"), i(x).em("indicator", B.direction), i(x).is("active", R === i(s))]), onMouseenter: K => i(E)(R), onClick: st(K => i(h)(R), ["stop"]) }, [Q("button", { class: O(i(x).e("button")) }, [i(a) ? (k(), z("span", B5, Be(V.props.label), 1)) : pe("v-if", !0)], 2)], 42, D5))), 128))], 2)) : pe("v-if", !0)], 34)); } });
var H5 = Fe(z5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel.vue"]]);
const K5 = Ve({ name: { type: String, default: "" }, label: { type: [String, Number], default: "" } }), j5 = (e, t) => { const n = Ye(pC), o = ht(), r = .83, s = M(), l = M(!1), a = M(0), u = M(1), c = M(!1), d = M(!1), f = M(!1), p = M(!1), { isCardType: v, isVertical: m } = n; function h(w, T, E) { const x = E - 1, I = T - 1, L = T + 1, B = E / 2; return T === 0 && w === x ? -1 : T === x && w === 0 ? E : w < I && T - w >= B ? E + 1 : w > L && w - T >= B ? -2 : w; } function g(w, T) { var E, x; const I = i(m) ? ((E = n.root.value) == null ? void 0 : E.offsetHeight) || 0 : ((x = n.root.value) == null ? void 0 : x.offsetWidth) || 0; return f.value ? I * ((2 - r) * (w - T) + 1) / 4 : w < T ? -(1 + r) * I / 4 : (3 + r) * I / 4; } function y(w, T, E) { const x = n.root.value; return x ? ((E ? x.offsetHeight : x.offsetWidth) || 0) * (w - T) : 0; } const C = (w, T, E) => { var x; const I = i(v), L = (x = n.items.value.length) != null ? x : Number.NaN, B = w === T; !I && !En(E) && (p.value = B || w === E), !B && L > 2 && n.loop && (w = h(w, T, L)); const F = i(m); c.value = B, I ? (f.value = Math.round(Math.abs(w - T)) <= 1, a.value = g(w, T), u.value = i(c) ? 1 : r) : a.value = y(w, T, F), d.value = !0, B && s.value && n.setContainerHeight(s.value.offsetHeight); }; function b() { if (n && i(v)) {
    const w = n.items.value.findIndex(({ uid: T }) => T === o.uid);
    n.setActiveItem(w);
} } return ft(() => { n.addItem({ props: e, states: Lt({ hover: l, translate: a, scale: u, active: c, ready: d, inStage: f, animating: p }), uid: o.uid, translateItem: C }); }), rs(() => { n.removeItem(o.uid); }), { carouselItemRef: s, active: c, animating: p, hover: l, inStage: f, isVertical: m, translate: a, isCardType: v, scale: u, ready: d, handleItemClick: b }; }, W5 = ae({ name: "ElCarouselItem" }), U5 = ae({ ...W5, props: K5, setup(e) { const t = e, n = Ie("carousel"), { carouselItemRef: o, active: r, animating: s, hover: l, inStage: a, isVertical: u, translate: c, isCardType: d, scale: f, ready: p, handleItemClick: v } = j5(t), m = S(() => { const g = `${`translate${i(u) ? "Y" : "X"}`}(${i(c)}px)`, y = `scale(${i(f)})`; return { transform: [g, y].join(" ") }; }); return (h, g) => dt((k(), z("div", { ref_key: "carouselItemRef", ref: o, class: O([i(n).e("item"), i(n).is("active", i(r)), i(n).is("in-stage", i(a)), i(n).is("hover", i(l)), i(n).is("animating", i(s)), { [i(n).em("item", "card")]: i(d), [i(n).em("item", "card-vertical")]: i(d) && i(u) }]), style: et(i(m)), onClick: g[0] || (g[0] = (...y) => i(v) && i(v)(...y)) }, [i(d) ? dt((k(), z("div", { key: 0, class: O(i(n).e("mask")) }, null, 2)), [[Pt, !i(r)]]) : pe("v-if", !0), ke(h.$slots, "default")], 6)), [[Pt, i(p)]]); } });
var hC = Fe(U5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel-item.vue"]]);
const q5 = vt(H5, { CarouselItem: hC }), Y5 = pn(hC), vC = { modelValue: { type: [Number, String, Boolean], default: void 0 }, label: { type: [String, Boolean, Number, Object] }, indeterminate: Boolean, disabled: Boolean, checked: Boolean, name: { type: String, default: void 0 }, trueLabel: { type: [String, Number], default: void 0 }, falseLabel: { type: [String, Number], default: void 0 }, id: { type: String, default: void 0 }, controls: { type: String, default: void 0 }, border: Boolean, size: Bn, tabindex: [String, Number], validateEvent: { type: Boolean, default: !0 } }, mC = { [gt]: e => it(e) || lt(e) || wn(e), change: e => it(e) || lt(e) || wn(e) }, Xl = Symbol("checkboxGroupContextKey"), G5 = ({ model: e, isChecked: t }) => { const n = Ye(Xl, void 0), o = S(() => { var s, l; const a = (s = n == null ? void 0 : n.max) == null ? void 0 : s.value, u = (l = n == null ? void 0 : n.min) == null ? void 0 : l.value; return !En(a) && e.value.length >= a && !t.value || !En(u) && e.value.length <= u && t.value; }); return { isDisabled: uo(S(() => (n == null ? void 0 : n.disabled.value) || o.value)), isLimitDisabled: o }; }, X5 = (e, { model: t, isLimitExceeded: n, hasOwnLabel: o, isDisabled: r, isLabeledByFormItem: s }) => { const l = Ye(Xl, void 0), { formItem: a } = Zn(), { emit: u } = ht(); function c(m) { var h, g; return m === e.trueLabel || m === !0 ? (h = e.trueLabel) != null ? h : !0 : (g = e.falseLabel) != null ? g : !1; } function d(m, h) { u("change", c(m), h); } function f(m) { if (n.value)
    return; const h = m.target; u("change", c(h.checked), m); } async function p(m) { n.value || !o.value && !r.value && s.value && (m.composedPath().some(y => y.tagName === "LABEL") || (t.value = c([!1, e.falseLabel].includes(t.value)), await Xe(), d(t.value, m))); } const v = S(() => (l == null ? void 0 : l.validateEvent) || e.validateEvent); return Oe(() => e.modelValue, () => { v.value && (a == null || a.validate("change").catch(m => void 0)); }), { handleChange: f, onClickRoot: p }; }, J5 = e => { const t = M(!1), { emit: n } = ht(), o = Ye(Xl, void 0), r = S(() => En(o) === !1), s = M(!1); return { model: S({ get() { var a, u; return r.value ? (a = o == null ? void 0 : o.modelValue) == null ? void 0 : a.value : (u = e.modelValue) != null ? u : t.value; }, set(a) { var u, c; r.value && qe(a) ? (s.value = ((u = o == null ? void 0 : o.max) == null ? void 0 : u.value) !== void 0 && a.length > (o == null ? void 0 : o.max.value), s.value === !1 && ((c = o == null ? void 0 : o.changeEvent) == null || c.call(o, a))) : (n(gt, a), t.value = a); } }), isGroup: r, isLimitExceeded: s }; }, Z5 = (e, t, { model: n }) => { const o = Ye(Xl, void 0), r = M(!1), s = S(() => { const c = n.value; return wn(c) ? c : qe(c) ? yt(e.label) ? c.map(Bt).some(d => ro(d, e.label)) : c.map(Bt).includes(e.label) : c != null ? c === e.trueLabel : !!c; }), l = kn(S(() => { var c; return (c = o == null ? void 0 : o.size) == null ? void 0 : c.value; }), { prop: !0 }), a = kn(S(() => { var c; return (c = o == null ? void 0 : o.size) == null ? void 0 : c.value; })), u = S(() => !!(t.default || e.label)); return { checkboxButtonSize: l, isChecked: s, isFocused: r, checkboxSize: a, hasOwnLabel: u }; }, Q5 = (e, { model: t }) => { function n() { qe(t.value) && !t.value.includes(e.label) ? t.value.push(e.label) : t.value = e.trueLabel || !0; } e.checked && n(); }, gC = (e, t) => { const { formItem: n } = Zn(), { model: o, isGroup: r, isLimitExceeded: s } = J5(e), { isFocused: l, isChecked: a, checkboxButtonSize: u, checkboxSize: c, hasOwnLabel: d } = Z5(e, t, { model: o }), { isDisabled: f } = G5({ model: o, isChecked: a }), { inputId: p, isLabeledByFormItem: v } = us(e, { formItemContext: n, disableIdGeneration: d, disableIdManagement: r }), { handleChange: m, onClickRoot: h } = X5(e, { model: o, isLimitExceeded: s, hasOwnLabel: d, isDisabled: f, isLabeledByFormItem: v }); return Q5(e, { model: o }), { inputId: p, isLabeledByFormItem: v, isChecked: a, isDisabled: f, isFocused: l, checkboxButtonSize: u, checkboxSize: c, hasOwnLabel: d, model: o, handleChange: m, onClickRoot: h }; }, eV = ["tabindex", "role", "aria-checked"], tV = ["id", "aria-hidden", "name", "tabindex", "disabled", "true-value", "false-value"], nV = ["id", "aria-hidden", "disabled", "value", "name", "tabindex"], oV = ae({ name: "ElCheckbox" }), rV = ae({ ...oV, props: vC, emits: mC, setup(e) { const t = e, n = An(), { inputId: o, isLabeledByFormItem: r, isChecked: s, isDisabled: l, isFocused: a, checkboxSize: u, hasOwnLabel: c, model: d, handleChange: f, onClickRoot: p } = gC(t, n), v = Ie("checkbox"), m = S(() => [v.b(), v.m(u.value), v.is("disabled", l.value), v.is("bordered", t.border), v.is("checked", s.value)]), h = S(() => [v.e("input"), v.is("disabled", l.value), v.is("checked", s.value), v.is("indeterminate", t.indeterminate), v.is("focus", a.value)]); return (g, y) => (k(), ge(kt(!i(c) && i(r) ? "span" : "label"), { class: O(i(m)), "aria-controls": g.indeterminate ? g.controls : null, onClick: i(p) }, { default: ie(() => [Q("span", { class: O(i(h)), tabindex: g.indeterminate ? 0 : void 0, role: g.indeterminate ? "checkbox" : void 0, "aria-checked": g.indeterminate ? "mixed" : void 0 }, [g.trueLabel || g.falseLabel ? dt((k(), z("input", { key: 0, id: i(o), "onUpdate:modelValue": y[0] || (y[0] = C => Jt(d) ? d.value = C : null), class: O(i(v).e("original")), type: "checkbox", "aria-hidden": g.indeterminate ? "true" : "false", name: g.name, tabindex: g.tabindex, disabled: i(l), "true-value": g.trueLabel, "false-value": g.falseLabel, onChange: y[1] || (y[1] = (...C) => i(f) && i(f)(...C)), onFocus: y[2] || (y[2] = C => a.value = !0), onBlur: y[3] || (y[3] = C => a.value = !1) }, null, 42, tV)), [[Bu, i(d)]]) : dt((k(), z("input", { key: 1, id: i(o), "onUpdate:modelValue": y[4] || (y[4] = C => Jt(d) ? d.value = C : null), class: O(i(v).e("original")), type: "checkbox", "aria-hidden": g.indeterminate ? "true" : "false", disabled: i(l), value: g.label, name: g.name, tabindex: g.tabindex, onChange: y[5] || (y[5] = (...C) => i(f) && i(f)(...C)), onFocus: y[6] || (y[6] = C => a.value = !0), onBlur: y[7] || (y[7] = C => a.value = !1) }, null, 42, nV)), [[Bu, i(d)]]), Q("span", { class: O(i(v).e("inner")) }, null, 2)], 10, eV), i(c) ? (k(), z("span", { key: 0, class: O(i(v).e("label")) }, [ke(g.$slots, "default"), g.$slots.default ? pe("v-if", !0) : (k(), z(Qe, { key: 0 }, [Ot(Be(g.label), 1)], 64))], 2)) : pe("v-if", !0)]), _: 3 }, 8, ["class", "aria-controls", "onClick"])); } });
var sV = Fe(rV, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
const lV = ["name", "tabindex", "disabled", "true-value", "false-value"], aV = ["name", "tabindex", "disabled", "value"], iV = ae({ name: "ElCheckboxButton" }), uV = ae({ ...iV, props: vC, emits: mC, setup(e) { const t = e, n = An(), { isFocused: o, isChecked: r, isDisabled: s, checkboxButtonSize: l, model: a, handleChange: u } = gC(t, n), c = Ye(Xl, void 0), d = Ie("checkbox"), f = S(() => { var v, m, h, g; const y = (m = (v = c == null ? void 0 : c.fill) == null ? void 0 : v.value) != null ? m : ""; return { backgroundColor: y, borderColor: y, color: (g = (h = c == null ? void 0 : c.textColor) == null ? void 0 : h.value) != null ? g : "", boxShadow: y ? `-1px 0 0 0 ${y}` : void 0 }; }), p = S(() => [d.b("button"), d.bm("button", l.value), d.is("disabled", s.value), d.is("checked", r.value), d.is("focus", o.value)]); return (v, m) => (k(), z("label", { class: O(i(p)) }, [v.trueLabel || v.falseLabel ? dt((k(), z("input", { key: 0, "onUpdate:modelValue": m[0] || (m[0] = h => Jt(a) ? a.value = h : null), class: O(i(d).be("button", "original")), type: "checkbox", name: v.name, tabindex: v.tabindex, disabled: i(s), "true-value": v.trueLabel, "false-value": v.falseLabel, onChange: m[1] || (m[1] = (...h) => i(u) && i(u)(...h)), onFocus: m[2] || (m[2] = h => o.value = !0), onBlur: m[3] || (m[3] = h => o.value = !1) }, null, 42, lV)), [[Bu, i(a)]]) : dt((k(), z("input", { key: 1, "onUpdate:modelValue": m[4] || (m[4] = h => Jt(a) ? a.value = h : null), class: O(i(d).be("button", "original")), type: "checkbox", name: v.name, tabindex: v.tabindex, disabled: i(s), value: v.label, onChange: m[5] || (m[5] = (...h) => i(u) && i(u)(...h)), onFocus: m[6] || (m[6] = h => o.value = !0), onBlur: m[7] || (m[7] = h => o.value = !1) }, null, 42, aV)), [[Bu, i(a)]]), v.$slots.default || v.label ? (k(), z("span", { key: 2, class: O(i(d).be("button", "inner")), style: et(i(r) ? i(f) : void 0) }, [ke(v.$slots, "default", {}, () => [Ot(Be(v.label), 1)])], 6)) : pe("v-if", !0)], 2)); } });
var yC = Fe(uV, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
const cV = Ve({ modelValue: { type: ve(Array), default: () => [] }, disabled: Boolean, min: Number, max: Number, size: Bn, label: String, fill: String, textColor: String, tag: { type: String, default: "div" }, validateEvent: { type: Boolean, default: !0 } }), dV = { [gt]: e => qe(e), change: e => qe(e) }, fV = ae({ name: "ElCheckboxGroup" }), pV = ae({ ...fV, props: cV, emits: dV, setup(e, { emit: t }) { const n = e, o = Ie("checkbox"), { formItem: r } = Zn(), { inputId: s, isLabeledByFormItem: l } = us(n, { formItemContext: r }), a = async (c) => { t(gt, c), await Xe(), t("change", c); }, u = S({ get() { return n.modelValue; }, set(c) { a(c); } }); return St(Xl, { ...gr(Sn(n), ["size", "min", "max", "disabled", "validateEvent", "fill", "textColor"]), modelValue: u, changeEvent: a }), Oe(() => n.modelValue, () => { n.validateEvent && (r == null || r.validate("change").catch(c => void 0)); }), (c, d) => { var f; return k(), ge(kt(c.tag), { id: i(s), class: O(i(o).b("group")), role: "group", "aria-label": i(l) ? void 0 : c.label || "checkbox-group", "aria-labelledby": i(l) ? (f = i(r)) == null ? void 0 : f.labelId : void 0 }, { default: ie(() => [ke(c.$slots, "default")]), _: 3 }, 8, ["id", "class", "aria-label", "aria-labelledby"]); }; } });
var bC = Fe(pV, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
const Ao = vt(sV, { CheckboxButton: yC, CheckboxGroup: bC }), hV = pn(yC), wC = pn(bC), CC = Ve({ size: Bn, disabled: Boolean, label: { type: [String, Number, Boolean], default: "" } }), vV = Ve({ ...CC, modelValue: { type: [String, Number, Boolean], default: "" }, name: { type: String, default: "" }, border: Boolean }), SC = { [gt]: e => it(e) || lt(e) || wn(e), [en]: e => it(e) || lt(e) || wn(e) }, _C = Symbol("radioGroupKey"), kC = (e, t) => { const n = M(), o = Ye(_C, void 0), r = S(() => !!o), s = S({ get() { return r.value ? o.modelValue : e.modelValue; }, set(d) { r.value ? o.changeEvent(d) : t && t(gt, d), n.value.checked = e.modelValue === e.label; } }), l = kn(S(() => o == null ? void 0 : o.size)), a = uo(S(() => o == null ? void 0 : o.disabled)), u = M(!1), c = S(() => a.value || r.value && s.value !== e.label ? -1 : 0); return { radioRef: n, isGroup: r, radioGroup: o, focus: u, size: l, disabled: a, tabIndex: c, modelValue: s }; }, mV = ["value", "name", "disabled"], gV = ae({ name: "ElRadio" }), yV = ae({ ...gV, props: vV, emits: SC, setup(e, { emit: t }) { const n = e, o = Ie("radio"), { radioRef: r, radioGroup: s, focus: l, size: a, disabled: u, modelValue: c } = kC(n, t); function d() { Xe(() => t("change", c.value)); } return (f, p) => { var v; return k(), z("label", { class: O([i(o).b(), i(o).is("disabled", i(u)), i(o).is("focus", i(l)), i(o).is("bordered", f.border), i(o).is("checked", i(c) === f.label), i(o).m(i(a))]) }, [Q("span", { class: O([i(o).e("input"), i(o).is("disabled", i(u)), i(o).is("checked", i(c) === f.label)]) }, [dt(Q("input", { ref_key: "radioRef", ref: r, "onUpdate:modelValue": p[0] || (p[0] = m => Jt(c) ? c.value = m : null), class: O(i(o).e("original")), value: f.label, name: f.name || ((v = i(s)) == null ? void 0 : v.name), disabled: i(u), type: "radio", onFocus: p[1] || (p[1] = m => l.value = !0), onBlur: p[2] || (p[2] = m => l.value = !1), onChange: d }, null, 42, mV), [[_b, i(c)]]), Q("span", { class: O(i(o).e("inner")) }, null, 2)], 2), Q("span", { class: O(i(o).e("label")), onKeydown: p[3] || (p[3] = st(() => { }, ["stop"])) }, [ke(f.$slots, "default", {}, () => [Ot(Be(f.label), 1)])], 34)], 2); }; } });
var bV = Fe(yV, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio.vue"]]);
const wV = Ve({ ...CC, name: { type: String, default: "" } }), CV = ["value", "name", "disabled"], SV = ae({ name: "ElRadioButton" }), _V = ae({ ...SV, props: wV, setup(e) { const t = e, n = Ie("radio"), { radioRef: o, focus: r, size: s, disabled: l, modelValue: a, radioGroup: u } = kC(t), c = S(() => ({ backgroundColor: (u == null ? void 0 : u.fill) || "", borderColor: (u == null ? void 0 : u.fill) || "", boxShadow: u != null && u.fill ? `-1px 0 0 0 ${u.fill}` : "", color: (u == null ? void 0 : u.textColor) || "" })); return (d, f) => { var p; return k(), z("label", { class: O([i(n).b("button"), i(n).is("active", i(a) === d.label), i(n).is("disabled", i(l)), i(n).is("focus", i(r)), i(n).bm("button", i(s))]) }, [dt(Q("input", { ref_key: "radioRef", ref: o, "onUpdate:modelValue": f[0] || (f[0] = v => Jt(a) ? a.value = v : null), class: O(i(n).be("button", "original-radio")), value: d.label, type: "radio", name: d.name || ((p = i(u)) == null ? void 0 : p.name), disabled: i(l), onFocus: f[1] || (f[1] = v => r.value = !0), onBlur: f[2] || (f[2] = v => r.value = !1) }, null, 42, CV), [[_b, i(a)]]), Q("span", { class: O(i(n).be("button", "inner")), style: et(i(a) === d.label ? i(c) : {}), onKeydown: f[3] || (f[3] = st(() => { }, ["stop"])) }, [ke(d.$slots, "default", {}, () => [Ot(Be(d.label), 1)])], 38)], 2); }; } });
var EC = Fe(_V, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-button.vue"]]);
const kV = Ve({ id: { type: String, default: void 0 }, size: Bn, disabled: Boolean, modelValue: { type: [String, Number, Boolean], default: "" }, fill: { type: String, default: "" }, label: { type: String, default: void 0 }, textColor: { type: String, default: "" }, name: { type: String, default: void 0 }, validateEvent: { type: Boolean, default: !0 } }), EV = SC, $V = ["id", "aria-label", "aria-labelledby"], TV = ae({ name: "ElRadioGroup" }), OV = ae({ ...TV, props: kV, emits: EV, setup(e, { emit: t }) { const n = e, o = Ie("radio"), r = xo(), s = M(), { formItem: l } = Zn(), { inputId: a, isLabeledByFormItem: u } = us(n, { formItemContext: l }), c = f => { t(gt, f), Xe(() => t("change", f)); }; ft(() => { const f = s.value.querySelectorAll("[type=radio]"), p = f[0]; !Array.from(f).some(v => v.checked) && p && (p.tabIndex = 0); }); const d = S(() => n.name || r.value); return St(_C, Lt({ ...Sn(n), changeEvent: c, name: d })), Oe(() => n.modelValue, () => { n.validateEvent && (l == null || l.validate("change").catch(f => void 0)); }), (f, p) => (k(), z("div", { id: i(a), ref_key: "radioGroupRef", ref: s, class: O(i(o).b("group")), role: "radiogroup", "aria-label": i(u) ? void 0 : f.label || "radio-group", "aria-labelledby": i(u) ? i(l).labelId : void 0 }, [ke(f.$slots, "default")], 10, $V)); } });
var $C = Fe(OV, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-group.vue"]]);
const TC = vt(bV, { RadioButton: EC, RadioGroup: $C }), IV = pn($C), xV = pn(EC);
var AV = ae({ name: "NodeContent", setup() { return { ns: Ie("cascader-node") }; }, render() { const { ns: e } = this, { node: t, panel: n } = this.$parent, { data: o, label: r } = t, { renderLabelFn: s } = n; return nt("span", { class: e.e("label") }, s ? s({ node: t, data: o }) : r); } });
const Ph = Symbol(), MV = ae({ name: "ElCascaderNode", components: { ElCheckbox: Ao, ElRadio: TC, NodeContent: AV, ElIcon: Je, Check: _i, Loading: as, ArrowRight: Un }, props: { node: { type: Object, required: !0 }, menuId: String }, emits: ["expand"], setup(e, { emit: t }) { const n = Ye(Ph), o = Ie("cascader-node"), r = S(() => n.isHoverMenu), s = S(() => n.config.multiple), l = S(() => n.config.checkStrictly), a = S(() => { var E; return (E = n.checkedNodes[0]) == null ? void 0 : E.uid; }), u = S(() => e.node.isDisabled), c = S(() => e.node.isLeaf), d = S(() => l.value && !c.value || !u.value), f = S(() => v(n.expandingNode)), p = S(() => l.value && n.checkedNodes.some(v)), v = E => { var x; const { level: I, uid: L } = e.node; return ((x = E == null ? void 0 : E.pathNodes[I - 1]) == null ? void 0 : x.uid) === L; }, m = () => { f.value || n.expandNode(e.node); }, h = E => { const { node: x } = e; E !== x.checked && n.handleCheckChange(x, E); }, g = () => { n.lazyLoad(e.node, () => { c.value || m(); }); }, y = E => { r.value && (C(), !c.value && t("expand", E)); }, C = () => { const { node: E } = e; !d.value || E.loading || (E.loaded ? m() : g()); }, b = () => { r.value && !c.value || (c.value && !u.value && !l.value && !s.value ? T(!0) : C()); }, w = E => { l.value ? (h(E), e.node.loaded && m()) : T(E); }, T = E => { e.node.loaded ? (h(E), !l.value && m()) : g(); }; return { panel: n, isHoverMenu: r, multiple: s, checkStrictly: l, checkedNodeId: a, isDisabled: u, isLeaf: c, expandable: d, inExpandingPath: f, inCheckedPath: p, ns: o, handleHoverExpand: y, handleExpand: C, handleClick: b, handleCheck: T, handleSelectCheck: w }; } }), NV = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"], PV = Q("span", null, null, -1);
function RV(e, t, n, o, r, s) {
    const l = ct("el-checkbox"), a = ct("el-radio"), u = ct("check"), c = ct("el-icon"), d = ct("node-content"), f = ct("loading"), p = ct("arrow-right");
    return k(), z("li", { id: `${e.menuId}-${e.node.uid}`, role: "menuitem", "aria-haspopup": !e.isLeaf, "aria-owns": e.isLeaf ? null : e.menuId, "aria-expanded": e.inExpandingPath, tabindex: e.expandable ? -1 : void 0, class: O([e.ns.b(), e.ns.is("selectable", e.checkStrictly), e.ns.is("active", e.node.checked), e.ns.is("disabled", !e.expandable), e.inExpandingPath && "in-active-path", e.inCheckedPath && "in-checked-path"]), onMouseenter: t[2] || (t[2] = (...v) => e.handleHoverExpand && e.handleHoverExpand(...v)), onFocus: t[3] || (t[3] = (...v) => e.handleHoverExpand && e.handleHoverExpand(...v)), onClick: t[4] || (t[4] = (...v) => e.handleClick && e.handleClick(...v)) }, [pe(" prefix "), e.multiple ? (k(), ge(l, { key: 0, "model-value": e.node.checked, indeterminate: e.node.indeterminate, disabled: e.isDisabled, onClick: t[0] || (t[0] = st(() => { }, ["stop"])), "onUpdate:modelValue": e.handleSelectCheck }, null, 8, ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : e.checkStrictly ? (k(), ge(a, { key: 1, "model-value": e.checkedNodeId, label: e.node.uid, disabled: e.isDisabled, "onUpdate:modelValue": e.handleSelectCheck, onClick: t[1] || (t[1] = st(() => { }, ["stop"])) }, { default: ie(() => [pe(`
        Add an empty element to avoid render label,
        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485
      `), PV]), _: 1 }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue"])) : e.isLeaf && e.node.checked ? (k(), ge(c, { key: 2, class: O(e.ns.e("prefix")) }, { default: ie(() => [ee(u)]), _: 1 }, 8, ["class"])) : pe("v-if", !0), pe(" content "), ee(d), pe(" postfix "), e.isLeaf ? pe("v-if", !0) : (k(), z(Qe, { key: 3 }, [e.node.loading ? (k(), ge(c, { key: 0, class: O([e.ns.is("loading"), e.ns.e("postfix")]) }, { default: ie(() => [ee(f)]), _: 1 }, 8, ["class"])) : (k(), ge(c, { key: 1, class: O(["arrow-right", e.ns.e("postfix")]) }, { default: ie(() => [ee(p)]), _: 1 }, 8, ["class"]))], 64))], 42, NV);
}
var LV = Fe(MV, [["render", RV], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/node.vue"]]);
const DV = ae({ name: "ElCascaderMenu", components: { Loading: as, ElIcon: Je, ElScrollbar: Or, ElCascaderNode: LV }, props: { nodes: { type: Array, required: !0 }, index: { type: Number, required: !0 } }, setup(e) {
        const t = ht(), n = Ie("cascader-menu"), { t: o } = Nt(), r = Rc();
        let s = null, l = null;
        const a = Ye(Ph), u = M(null), c = S(() => !e.nodes.length), d = S(() => !a.initialLoaded), f = S(() => `cascader-menu-${r}-${e.index}`), p = g => { s = g.target; }, v = g => {
            if (!(!a.isHoverMenu || !s || !u.value))
                if (s.contains(g.target)) {
                    m();
                    const y = t.vnode.el, { left: C } = y.getBoundingClientRect(), { offsetWidth: b, offsetHeight: w } = y, T = g.clientX - C, E = s.offsetTop, x = E + s.offsetHeight;
                    u.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${T} ${E} L${b} 0 V${E} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${T} ${x} L${b} ${w} V${x} Z" />
        `;
                }
                else
                    l || (l = window.setTimeout(h, a.config.hoverThreshold));
        }, m = () => { l && (clearTimeout(l), l = null); }, h = () => { u.value && (u.value.innerHTML = "", m()); };
        return { ns: n, panel: a, hoverZone: u, isEmpty: c, isLoading: d, menuId: f, t: o, handleExpand: p, handleMouseMove: v, clearHoverZone: h };
    } });
function BV(e, t, n, o, r, s) { const l = ct("el-cascader-node"), a = ct("loading"), u = ct("el-icon"), c = ct("el-scrollbar"); return k(), ge(c, { key: e.menuId, tag: "ul", role: "menu", class: O(e.ns.b()), "wrap-class": e.ns.e("wrap"), "view-class": [e.ns.e("list"), e.ns.is("empty", e.isEmpty)], onMousemove: e.handleMouseMove, onMouseleave: e.clearHoverZone }, { default: ie(() => { var d; return [(k(!0), z(Qe, null, Et(e.nodes, f => (k(), ge(l, { key: f.uid, node: f, "menu-id": e.menuId, onExpand: e.handleExpand }, null, 8, ["node", "menu-id", "onExpand"]))), 128)), e.isLoading ? (k(), z("div", { key: 0, class: O(e.ns.e("empty-text")) }, [ee(u, { size: "14", class: O(e.ns.is("loading")) }, { default: ie(() => [ee(a)]), _: 1 }, 8, ["class"]), Ot(" " + Be(e.t("el.cascader.loading")), 1)], 2)) : e.isEmpty ? (k(), z("div", { key: 1, class: O(e.ns.e("empty-text")) }, Be(e.t("el.cascader.noData")), 3)) : (d = e.panel) != null && d.isHoverMenu ? (k(), z("svg", { key: 2, ref: "hoverZone", class: O(e.ns.e("hover-zone")) }, null, 2)) : pe("v-if", !0)]; }), _: 1 }, 8, ["class", "wrap-class", "view-class", "onMousemove", "onMouseleave"]); }
var FV = Fe(DV, [["render", BV], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/menu.vue"]]);
let VV = 0;
const zV = e => { const t = [e]; let { parent: n } = e; for (; n;)
    t.unshift(n), n = n.parent; return t; };
let Bf = class Ff {
    constructor(t, n, o, r = !1) { this.data = t, this.config = n, this.parent = o, this.root = r, this.uid = VV++, this.checked = !1, this.indeterminate = !1, this.loading = !1; const { value: s, label: l, children: a } = n, u = t[a], c = zV(this); this.level = r ? 0 : o ? o.level + 1 : 1, this.value = t[s], this.label = t[l], this.pathNodes = c, this.pathValues = c.map(d => d.value), this.pathLabels = c.map(d => d.label), this.childrenData = u, this.children = (u || []).map(d => new Ff(d, n, this)), this.loaded = !n.lazy || this.isLeaf || !wo(u); }
    get isDisabled() { const { data: t, parent: n, config: o } = this, { disabled: r, checkStrictly: s } = o; return (at(r) ? r(t, this) : !!t[r]) || !s && (n == null ? void 0 : n.isDisabled); }
    get isLeaf() { const { data: t, config: n, childrenData: o, loaded: r } = this, { lazy: s, leaf: l } = n, a = at(l) ? l(t, this) : t[l]; return En(a) ? s && !r ? !1 : !(Array.isArray(o) && o.length) : !!a; }
    get valueByOption() { return this.config.emitPath ? this.pathValues : this.value; }
    appendChild(t) { const { childrenData: n, children: o } = this, r = new Ff(t, this.config, this); return Array.isArray(n) ? n.push(t) : this.childrenData = [t], o.push(r), r; }
    calcText(t, n) { const o = t ? this.pathLabels.join(n) : this.label; return this.text = o, o; }
    broadcast(t, ...n) { const o = `onParent${Xo(t)}`; this.children.forEach(r => { r && (r.broadcast(t, ...n), r[o] && r[o](...n)); }); }
    emit(t, ...n) { const { parent: o } = this, r = `onChild${Xo(t)}`; o && (o[r] && o[r](...n), o.emit(t, ...n)); }
    onParentCheck(t) { this.isDisabled || this.setCheckState(t); }
    onChildCheck() { const { children: t } = this, n = t.filter(r => !r.isDisabled), o = n.length ? n.every(r => r.checked) : !1; this.setCheckState(o); }
    setCheckState(t) { const n = this.children.length, o = this.children.reduce((r, s) => { const l = s.checked ? 1 : s.indeterminate ? .5 : 0; return r + l; }, 0); this.checked = this.loaded && this.children.filter(r => !r.isDisabled).every(r => r.loaded && r.checked) && t, this.indeterminate = this.loaded && o !== n && o > 0; }
    doCheck(t) { if (this.checked === t)
        return; const { checkStrictly: n, multiple: o } = this.config; n || !o ? this.checked = t : (this.broadcast("check", t), this.setCheckState(t), this.emit("check")); }
};
const Vf = (e, t) => e.reduce((n, o) => (o.isLeaf ? n.push(o) : (!t && n.push(o), n = n.concat(Vf(o.children, t))), n), []);
class $0 {
    constructor(t, n) { this.config = n; const o = (t || []).map(r => new Bf(r, this.config)); this.nodes = o, this.allNodes = Vf(o, !1), this.leafNodes = Vf(o, !0); }
    getNodes() { return this.nodes; }
    getFlattedNodes(t) { return t ? this.leafNodes : this.allNodes; }
    appendNode(t, n) { const o = n ? n.appendChild(t) : new Bf(t, this.config); n || this.nodes.push(o), this.allNodes.push(o), o.isLeaf && this.leafNodes.push(o); }
    appendNodes(t, n) { t.forEach(o => this.appendNode(o, n)); }
    getNodeByValue(t, n = !1) { return !t && t !== 0 ? null : this.getFlattedNodes(n).find(r => ro(r.value, t) || ro(r.pathValues, t)) || null; }
    getSameNode(t) { return t && this.getFlattedNodes(!1).find(({ value: o, level: r }) => ro(t.value, o) && t.level === r) || null; }
}
const OC = Ve({ modelValue: { type: ve([Number, String, Array]) }, options: { type: ve(Array), default: () => [] }, props: { type: ve(Object), default: () => ({}) } }), HV = { expandTrigger: "click", multiple: !1, checkStrictly: !1, emitPath: !0, lazy: !1, lazyLoad: Wt, value: "value", label: "label", children: "children", leaf: "leaf", disabled: "disabled", hoverThreshold: 500 }, KV = e => S(() => ({ ...HV, ...e.props })), T0 = e => { if (!e)
    return 0; const t = e.id.split("-"); return Number(t[t.length - 2]); }, jV = e => { if (!e)
    return; const t = e.querySelector("input"); t ? t.click() : Vb(e) && e.click(); }, WV = (e, t) => { const n = t.slice(0), o = n.map(s => s.uid), r = e.reduce((s, l) => { const a = o.indexOf(l.uid); return a > -1 && (s.push(l), n.splice(a, 1), o.splice(a, 1)), s; }, []); return r.push(...n), r; }, UV = ae({ name: "ElCascaderPanel", components: { ElCascaderMenu: FV }, props: { ...OC, border: { type: Boolean, default: !0 }, renderLabel: Function }, emits: [gt, en, "close", "expand-change"], setup(e, { emit: t, slots: n }) { let o = !1; const r = Ie("cascader"), s = KV(e); let l = null; const a = M(!0), u = M([]), c = M(null), d = M([]), f = M(null), p = M([]), v = S(() => s.value.expandTrigger === "hover"), m = S(() => e.renderLabel || n.default), h = () => { const { options: V } = e, R = s.value; o = !1, l = new $0(V, R), d.value = [l.getNodes()], R.lazy && wo(e.options) ? (a.value = !1, g(void 0, K => { K && (l = new $0(K, R), d.value = [l.getNodes()]), a.value = !0, I(!1, !0); })) : I(!1, !0); }, g = (V, R) => { const K = s.value; V = V || new Bf({}, K, void 0, !0), V.loading = !0; const te = U => { const D = V, j = D.root ? null : D; U && (l == null || l.appendNodes(U, j)), D.loading = !1, D.loaded = !0, D.childrenData = D.childrenData || [], R && R(U); }; K.lazyLoad(V, te); }, y = (V, R) => { var K; const { level: te } = V, U = d.value.slice(0, te); let D; V.isLeaf ? D = V.pathNodes[te - 2] : (D = V, U.push(V.children)), ((K = f.value) == null ? void 0 : K.uid) !== (D == null ? void 0 : D.uid) && (f.value = V, d.value = U, !R && t("expand-change", (V == null ? void 0 : V.pathValues) || [])); }, C = (V, R, K = !0) => { const { checkStrictly: te, multiple: U } = s.value, D = p.value[0]; o = !0, !U && (D == null || D.doCheck(!1)), V.doCheck(R), x(), K && !U && !te && t("close"), !K && !U && !te && b(V); }, b = V => { V && (V = V.parent, b(V), V && y(V)); }, w = V => l == null ? void 0 : l.getFlattedNodes(V), T = V => { var R; return (R = w(V)) == null ? void 0 : R.filter(K => K.checked !== !1); }, E = () => { p.value.forEach(V => V.doCheck(!1)), x(), d.value = d.value.slice(0, 1), f.value = null, t("expand-change", []); }, x = () => { var V; const { checkStrictly: R, multiple: K } = s.value, te = p.value, U = T(!R), D = WV(te, U), j = D.map(A => A.valueByOption); p.value = D, c.value = K ? j : (V = j[0]) != null ? V : null; }, I = (V = !1, R = !1) => { const { modelValue: K } = e, { lazy: te, multiple: U, checkStrictly: D } = s.value, j = !D; if (!(!a.value || o || !R && ro(K, c.value)))
        if (te && !V) {
            const G = Eg(lM(yr(K))).map(se => l == null ? void 0 : l.getNodeByValue(se)).filter(se => !!se && !se.loaded && !se.loading);
            G.length ? G.forEach(se => { g(se, () => I(!1, R)); }) : I(!0, R);
        }
        else {
            const A = U ? yr(K) : [K], G = Eg(A.map(se => l == null ? void 0 : l.getNodeByValue(se, j)));
            L(G, R), c.value = Hu(K);
        } }, L = (V, R = !0) => { const { checkStrictly: K } = s.value, te = p.value, U = V.filter(A => !!A && (K || A.isLeaf)), D = l == null ? void 0 : l.getSameNode(f.value), j = R && D || U[0]; j ? j.pathNodes.forEach(A => y(A, !0)) : f.value = null, te.forEach(A => A.doCheck(!1)), U.forEach(A => A.doCheck(!0)), p.value = U, Xe(B); }, B = () => { At && u.value.forEach(V => { const R = V == null ? void 0 : V.$el; if (R) {
        const K = R.querySelector(`.${r.namespace.value}-scrollbar__wrap`), te = R.querySelector(`.${r.b("node")}.${r.is("active")}`) || R.querySelector(`.${r.b("node")}.in-active-path`);
        x1(K, te);
    } }); }, F = V => { const R = V.target, { code: K } = V; switch (K) {
        case tt.up:
        case tt.down: {
            V.preventDefault();
            const te = K === tt.up ? -1 : 1;
            uu(zb(R, te, `.${r.b("node")}[tabindex="-1"]`));
            break;
        }
        case tt.left: {
            V.preventDefault();
            const te = u.value[T0(R) - 1], U = te == null ? void 0 : te.$el.querySelector(`.${r.b("node")}[aria-expanded="true"]`);
            uu(U);
            break;
        }
        case tt.right: {
            V.preventDefault();
            const te = u.value[T0(R) + 1], U = te == null ? void 0 : te.$el.querySelector(`.${r.b("node")}[tabindex="-1"]`);
            uu(U);
            break;
        }
        case tt.enter:
            jV(R);
            break;
    } }; return St(Ph, Lt({ config: s, expandingNode: f, checkedNodes: p, isHoverMenu: v, initialLoaded: a, renderLabelFn: m, lazyLoad: g, expandNode: y, handleCheckChange: C })), Oe([s, () => e.options], h, { deep: !0, immediate: !0 }), Oe(() => e.modelValue, () => { o = !1, I(); }, { deep: !0 }), Oe(() => c.value, V => { ro(V, e.modelValue) || (t(gt, V), t(en, V)); }), Zy(() => u.value = []), ft(() => !wo(e.modelValue) && I()), { ns: r, menuList: u, menus: d, checkedNodes: p, handleKeyDown: F, handleCheckChange: C, getFlattedNodes: w, getCheckedNodes: T, clearCheckedNodes: E, calculateCheckedValue: x, scrollToExpandingNode: B }; } });
function qV(e, t, n, o, r, s) { const l = ct("el-cascader-menu"); return k(), z("div", { class: O([e.ns.b("panel"), e.ns.is("bordered", e.border)]), onKeydown: t[0] || (t[0] = (...a) => e.handleKeyDown && e.handleKeyDown(...a)) }, [(k(!0), z(Qe, null, Et(e.menus, (a, u) => (k(), ge(l, { key: u, ref_for: !0, ref: c => e.menuList[u] = c, index: u, nodes: [...a] }, null, 8, ["index", "nodes"]))), 128))], 34); }
var gu = Fe(UV, [["render", qV], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/index.vue"]]);
gu.install = e => { e.component(gu.name, gu); };
const IC = gu, YV = IC, Rh = Ve({ type: { type: String, values: ["success", "info", "warning", "danger", ""], default: "" }, closable: Boolean, disableTransitions: Boolean, hit: Boolean, color: { type: String, default: "" }, size: { type: String, values: sr, default: "" }, effect: { type: String, values: ["dark", "light", "plain"], default: "light" }, round: Boolean }), GV = { close: e => e instanceof MouseEvent, click: e => e instanceof MouseEvent }, XV = ae({ name: "ElTag" }), JV = ae({ ...XV, props: Rh, emits: GV, setup(e, { emit: t }) { const n = e, o = kn(), r = Ie("tag"), s = S(() => { const { type: u, hit: c, effect: d, closable: f, round: p } = n; return [r.b(), r.is("closable", f), r.m(u), r.m(o.value), r.m(d), r.is("hit", c), r.is("round", p)]; }), l = u => { t("close", u); }, a = u => { t("click", u); }; return (u, c) => u.disableTransitions ? (k(), z("span", { key: 0, class: O(i(s)), style: et({ backgroundColor: u.color }), onClick: a }, [Q("span", { class: O(i(r).e("content")) }, [ke(u.$slots, "default")], 2), u.closable ? (k(), ge(i(Je), { key: 0, class: O(i(r).e("close")), onClick: st(l, ["stop"]) }, { default: ie(() => [ee(i(Ho))]), _: 1 }, 8, ["class", "onClick"])) : pe("v-if", !0)], 6)) : (k(), ge(yn, { key: 1, name: `${i(r).namespace.value}-zoom-in-center`, appear: "" }, { default: ie(() => [Q("span", { class: O(i(s)), style: et({ backgroundColor: u.color }), onClick: a }, [Q("span", { class: O(i(r).e("content")) }, [ke(u.$slots, "default")], 2), u.closable ? (k(), ge(i(Je), { key: 0, class: O(i(r).e("close")), onClick: st(l, ["stop"]) }, { default: ie(() => [ee(i(Ho))]), _: 1 }, 8, ["class", "onClick"])) : pe("v-if", !0)], 6)]), _: 3 }, 8, ["name"])); } });
var ZV = Fe(JV, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);
const ri = vt(ZV), QV = Ve({ ...OC, size: Bn, placeholder: String, disabled: Boolean, clearable: Boolean, filterable: Boolean, filterMethod: { type: ve(Function), default: (e, t) => e.text.includes(t) }, separator: { type: String, default: " / " }, showAllLevels: { type: Boolean, default: !0 }, collapseTags: Boolean, collapseTagsTooltip: { type: Boolean, default: !1 }, debounce: { type: Number, default: 300 }, beforeFilter: { type: ve(Function), default: () => !0 }, popperClass: { type: String, default: "" }, teleported: On.teleported, tagType: { ...Rh.type, default: "info" }, validateEvent: { type: Boolean, default: !0 } }), ez = { [gt]: e => !!e || e === null, [en]: e => !!e || e === null, focus: e => e instanceof FocusEvent, blur: e => e instanceof FocusEvent, visibleChange: e => wn(e), expandChange: e => !!e, removeTag: e => !!e }, tz = { key: 0 }, nz = ["placeholder", "onKeydown"], oz = ["onClick"], rz = "ElCascader", sz = ae({ name: rz }), lz = ae({ ...sz, props: QV, emits: ez, setup(e, { expose: t, emit: n }) { const o = e, r = { modifiers: [{ name: "arrowPosition", enabled: !0, phase: "main", fn: ({ state: H }) => { const { modifiersData: ue, placement: de } = H; ["right", "left", "bottom", "top"].includes(de) || (ue.arrow.x = 35); }, requires: ["arrow"] }] }, s = js(); let l = 0, a = 0; const u = Ie("cascader"), c = Ie("input"), { t: d } = Nt(), { form: f, formItem: p } = Zn(), v = M(null), m = M(null), h = M(null), g = M(null), y = M(null), C = M(!1), b = M(!1), w = M(!1), T = M(!1), E = M(""), x = M(""), I = M([]), L = M([]), B = M([]), F = M(!1), V = S(() => s.style), R = S(() => o.disabled || (f == null ? void 0 : f.disabled)), K = S(() => o.placeholder || d("el.cascader.placeholder")), te = S(() => x.value || I.value.length > 0 || F.value ? "" : K.value), U = kn(), D = S(() => ["small"].includes(U.value) ? "small" : "default"), j = S(() => !!o.props.multiple), A = S(() => !o.filterable || j.value), G = S(() => j.value ? x.value : E.value), se = S(() => { var H; return ((H = g.value) == null ? void 0 : H.checkedNodes) || []; }), Z = S(() => !o.clearable || R.value || w.value || !b.value ? !1 : !!se.value.length), ce = S(() => { const { showAllLevels: H, separator: ue } = o, de = se.value; return de.length ? j.value ? "" : de[0].calcText(H, ue) : ""; }), ye = S({ get() { return Hu(o.modelValue); }, set(H) { n(gt, H), n(en, H), o.validateEvent && (p == null || p.validate("change").catch(ue => void 0)); } }), Re = S(() => [u.b(), u.m(U.value), u.is("disabled", R.value), s.class]), me = S(() => [c.e("icon"), "icon-arrow-down", u.is("reverse", C.value)]), le = S(() => u.is("focus", C.value || T.value)), oe = S(() => { var H, ue; return (ue = (H = v.value) == null ? void 0 : H.popperRef) == null ? void 0 : ue.contentRef; }), fe = H => { var ue, de, be; R.value || (H = H ?? !C.value, H !== C.value && (C.value = H, (de = (ue = m.value) == null ? void 0 : ue.input) == null || de.setAttribute("aria-expanded", `${H}`), H ? (Ce(), Xe((be = g.value) == null ? void 0 : be.scrollToExpandingNode)) : o.filterable && je(), n("visibleChange", H))); }, Ce = () => { Xe(() => { var H; (H = v.value) == null || H.updatePopper(); }); }, Ae = () => { w.value = !1; }, q = H => { const { showAllLevels: ue, separator: de } = o; return { node: H, key: H.uid, text: H.calcText(ue, de), hitState: !1, closable: !R.value && !H.isDisabled, isCollapseTag: !1 }; }, re = H => { var ue; const de = H.node; de.doCheck(!1), (ue = g.value) == null || ue.calculateCheckedValue(), n("removeTag", de.valueByOption); }, he = () => { if (!j.value)
        return; const H = se.value, ue = [], de = []; if (H.forEach(be => de.push(q(be))), L.value = de, H.length) {
        const [be, ...J] = H, we = J.length;
        ue.push(q(be)), we && (o.collapseTags ? ue.push({ key: -1, text: `+ ${we}`, closable: !1, isCollapseTag: !0 }) : J.forEach(Ke => ue.push(q(Ke))));
    } I.value = ue; }, Ee = () => { var H, ue; const { filterMethod: de, showAllLevels: be, separator: J } = o, we = (ue = (H = g.value) == null ? void 0 : H.getFlattedNodes(!o.props.checkStrictly)) == null ? void 0 : ue.filter(Ke => Ke.isDisabled ? !1 : (Ke.calcText(be, J), de(Ke, G.value))); j.value && (I.value.forEach(Ke => { Ke.hitState = !1; }), L.value.forEach(Ke => { Ke.hitState = !1; })), w.value = !0, B.value = we, Ce(); }, Ne = () => { var H; let ue; w.value && y.value ? ue = y.value.$el.querySelector(`.${u.e("suggestion-item")}`) : ue = (H = g.value) == null ? void 0 : H.$el.querySelector(`.${u.b("node")}[tabindex="-1"]`), ue && (ue.focus(), !w.value && ue.click()); }, Se = () => { var H, ue; const de = (H = m.value) == null ? void 0 : H.input, be = h.value, J = (ue = y.value) == null ? void 0 : ue.$el; if (!(!At || !de)) {
        if (J) {
            const we = J.querySelector(`.${u.e("suggestion-list")}`);
            we.style.minWidth = `${de.offsetWidth}px`;
        }
        if (be) {
            const { offsetHeight: we } = be, Ke = I.value.length > 0 ? `${Math.max(we + 6, l)}px` : `${l}px`;
            de.style.height = Ke, Ce();
        }
    } }, De = H => { var ue; return (ue = g.value) == null ? void 0 : ue.getCheckedNodes(H); }, Me = H => { Ce(), n("expandChange", H); }, $e = H => { var ue; const de = (ue = H.target) == null ? void 0 : ue.value; if (H.type === "compositionend")
        F.value = !1, Xe(() => Y(de));
    else {
        const be = de[de.length - 1] || "";
        F.value = !Nc(be);
    } }, Pe = H => { if (!F.value)
        switch (H.code) {
            case tt.enter:
                fe();
                break;
            case tt.down:
                fe(!0), Xe(Ne), H.preventDefault();
                break;
            case tt.esc:
                C.value === !0 && (H.preventDefault(), H.stopPropagation(), fe(!1));
                break;
            case tt.tab:
                fe(!1);
                break;
        } }, He = () => { var H; (H = g.value) == null || H.clearCheckedNodes(), !C.value && o.filterable && je(), fe(!1); }, je = () => { const { value: H } = ce; E.value = H, x.value = H; }, Ue = H => { var ue, de; const { checked: be } = H; j.value ? (ue = g.value) == null || ue.handleCheckChange(H, !be, !1) : (!be && ((de = g.value) == null || de.handleCheckChange(H, !0, !1)), fe(!1)); }, Te = H => { const ue = H.target, { code: de } = H; switch (de) {
        case tt.up:
        case tt.down: {
            const be = de === tt.up ? -1 : 1;
            uu(zb(ue, be, `.${u.e("suggestion-item")}[tabindex="-1"]`));
            break;
        }
        case tt.enter:
            ue.click();
            break;
    } }, Ge = () => { const H = I.value, ue = H[H.length - 1]; a = x.value ? 0 : a + 1, !(!ue || !a || o.collapseTags && H.length > 1) && (ue.hitState ? re(ue) : ue.hitState = !0); }, W = H => { const ue = H.target, de = u.e("search-input"); ue.className === de && (T.value = !0), n("focus", H); }, X = H => { T.value = !1, n("blur", H); }, $ = Xn(() => { const { value: H } = G; if (!H)
        return; const ue = o.beforeFilter(H); Na(ue) ? ue.then(Ee).catch(() => { }) : ue !== !1 ? Ee() : Ae(); }, o.debounce), Y = (H, ue) => { !C.value && fe(!0), !(ue != null && ue.isComposing) && (H ? $() : Ae()); }; return Oe(w, Ce), Oe([se, R], he), Oe(I, () => { Xe(() => Se()); }), Oe(ce, je, { immediate: !0 }), ft(() => { const H = m.value.input, ue = Number.parseFloat(nT(c.cssVarName("input-height"), H).value) - 2; l = H.offsetHeight || ue, Vn(H, Se); }), t({ getCheckedNodes: De, cascaderPanelRef: g, togglePopperVisible: fe, contentRef: oe }), (H, ue) => (k(), ge(i(Jn), { ref_key: "tooltipRef", ref: v, visible: C.value, teleported: H.teleported, "popper-class": [i(u).e("dropdown"), H.popperClass], "popper-options": r, "fallback-placements": ["bottom-start", "bottom", "top-start", "top", "right", "left"], "stop-popper-mouse-event": !1, "gpu-acceleration": !1, placement: "bottom-start", transition: `${i(u).namespace.value}-zoom-in-top`, effect: "light", pure: "", persistent: "", onHide: Ae }, { default: ie(() => [dt((k(), z("div", { class: O(i(Re)), style: et(i(V)), onClick: ue[5] || (ue[5] = () => fe(i(A) ? void 0 : !0)), onKeydown: Pe, onMouseenter: ue[6] || (ue[6] = de => b.value = !0), onMouseleave: ue[7] || (ue[7] = de => b.value = !1) }, [ee(i(Ln), { ref_key: "input", ref: m, modelValue: E.value, "onUpdate:modelValue": ue[1] || (ue[1] = de => E.value = de), placeholder: i(te), readonly: i(A), disabled: i(R), "validate-event": !1, size: i(U), class: O(i(le)), tabindex: i(j) && H.filterable && !i(R) ? -1 : void 0, onCompositionstart: $e, onCompositionupdate: $e, onCompositionend: $e, onFocus: W, onBlur: X, onInput: Y }, { suffix: ie(() => [i(Z) ? (k(), ge(i(Je), { key: "clear", class: O([i(c).e("icon"), "icon-circle-close"]), onClick: st(He, ["stop"]) }, { default: ie(() => [ee(i(ls))]), _: 1 }, 8, ["class", "onClick"])) : (k(), ge(i(Je), { key: "arrow-down", class: O(i(me)), onClick: ue[0] || (ue[0] = st(de => fe(), ["stop"])) }, { default: ie(() => [ee(i(ss))]), _: 1 }, 8, ["class"]))]), _: 1 }, 8, ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "tabindex"]), i(j) ? (k(), z("div", { key: 0, ref_key: "tagWrapper", ref: h, class: O(i(u).e("tags")) }, [(k(!0), z(Qe, null, Et(I.value, de => (k(), ge(i(ri), { key: de.key, type: H.tagType, size: i(D), hit: de.hitState, closable: de.closable, "disable-transitions": "", onClose: be => re(de) }, { default: ie(() => [de.isCollapseTag === !1 ? (k(), z("span", tz, Be(de.text), 1)) : (k(), ge(i(Jn), { key: 1, disabled: C.value || !H.collapseTagsTooltip, "fallback-placements": ["bottom", "top", "right", "left"], placement: "bottom", effect: "light" }, { default: ie(() => [Q("span", null, Be(de.text), 1)]), content: ie(() => [Q("div", { class: O(i(u).e("collapse-tags")) }, [(k(!0), z(Qe, null, Et(L.value.slice(1), (be, J) => (k(), z("div", { key: J, class: O(i(u).e("collapse-tag")) }, [(k(), ge(i(ri), { key: be.key, class: "in-tooltip", type: H.tagType, size: i(D), hit: be.hitState, closable: be.closable, "disable-transitions": "", onClose: we => re(be) }, { default: ie(() => [Q("span", null, Be(be.text), 1)]), _: 2 }, 1032, ["type", "size", "hit", "closable", "onClose"]))], 2))), 128))], 2)]), _: 2 }, 1032, ["disabled"]))]), _: 2 }, 1032, ["type", "size", "hit", "closable", "onClose"]))), 128)), H.filterable && !i(R) ? dt((k(), z("input", { key: 0, "onUpdate:modelValue": ue[2] || (ue[2] = de => x.value = de), type: "text", class: O(i(u).e("search-input")), placeholder: i(ce) ? "" : i(K), onInput: ue[3] || (ue[3] = de => Y(x.value, de)), onClick: ue[4] || (ue[4] = st(de => fe(!0), ["stop"])), onKeydown: Mt(Ge, ["delete"]), onCompositionstart: $e, onCompositionupdate: $e, onCompositionend: $e, onFocus: W, onBlur: X }, null, 42, nz)), [[Fp, x.value]]) : pe("v-if", !0)], 2)) : pe("v-if", !0)], 38)), [[i(ns), () => fe(!1), i(oe)]])]), content: ie(() => [dt(ee(i(IC), { ref_key: "cascaderPanelRef", ref: g, modelValue: i(ye), "onUpdate:modelValue": ue[8] || (ue[8] = de => Jt(ye) ? ye.value = de : null), options: H.options, props: o.props, border: !1, "render-label": H.$slots.default, onExpandChange: Me, onClose: ue[9] || (ue[9] = de => H.$nextTick(() => fe(!1))) }, null, 8, ["modelValue", "options", "props", "render-label"]), [[Pt, !w.value]]), H.filterable ? dt((k(), ge(i(Or), { key: 0, ref_key: "suggestionPanel", ref: y, tag: "ul", class: O(i(u).e("suggestion-panel")), "view-class": i(u).e("suggestion-list"), onKeydown: Te }, { default: ie(() => [B.value.length ? (k(!0), z(Qe, { key: 0 }, Et(B.value, de => (k(), z("li", { key: de.uid, class: O([i(u).e("suggestion-item"), i(u).is("checked", de.checked)]), tabindex: -1, onClick: be => Ue(de) }, [Q("span", null, Be(de.text), 1), de.checked ? (k(), ge(i(Je), { key: 0 }, { default: ie(() => [ee(i(_i))]), _: 1 })) : pe("v-if", !0)], 10, oz))), 128)) : ke(H.$slots, "empty", { key: 1 }, () => [Q("li", { class: O(i(u).e("empty-text")) }, Be(i(d)("el.cascader.noMatch")), 3)])]), _: 3 }, 8, ["class", "view-class"])), [[Pt, w.value]]) : pe("v-if", !0)]), _: 3 }, 8, ["visible", "teleported", "popper-class", "transition"])); } });
var yu = Fe(lz, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader/src/cascader.vue"]]);
yu.install = e => { e.component(yu.name, yu); };
const az = yu, iz = az, uz = Ve({ checked: { type: Boolean, default: !1 } }), cz = { "update:checked": e => wn(e), [en]: e => wn(e) }, dz = ae({ name: "ElCheckTag" }), fz = ae({ ...dz, props: uz, emits: cz, setup(e, { emit: t }) { const n = e, o = Ie("check-tag"), r = S(() => [o.b(), o.is("checked", n.checked)]), s = () => { const l = !n.checked; t(en, l), t("update:checked", l); }; return (l, a) => (k(), z("span", { class: O(i(r)), onClick: s }, [ke(l.$slots, "default")], 2)); } });
var pz = Fe(fz, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/check-tag/src/check-tag.vue"]]);
const hz = vt(pz), xC = Symbol("rowContextKey"), vz = ["start", "center", "end", "space-around", "space-between", "space-evenly"], mz = ["top", "middle", "bottom"], gz = Ve({ tag: { type: String, default: "div" }, gutter: { type: Number, default: 0 }, justify: { type: String, values: vz, default: "start" }, align: { type: String, values: mz, default: "top" } }), yz = ae({ name: "ElRow" }), bz = ae({ ...yz, props: gz, setup(e) { const t = e, n = Ie("row"), o = S(() => t.gutter); St(xC, { gutter: o }); const r = S(() => { const l = {}; return t.gutter && (l.marginRight = l.marginLeft = `-${t.gutter / 2}px`), l; }), s = S(() => [n.b(), n.is(`justify-${t.justify}`, t.justify !== "start"), n.is(`align-${t.align}`, t.align !== "top")]); return (l, a) => (k(), ge(kt(l.tag), { class: O(i(s)), style: et(i(r)) }, { default: ie(() => [ke(l.$slots, "default")]), _: 3 }, 8, ["class", "style"])); } });
var wz = Fe(bz, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/row/src/row.vue"]]);
const Cz = vt(wz), Sz = Ve({ tag: { type: String, default: "div" }, span: { type: Number, default: 24 }, offset: { type: Number, default: 0 }, pull: { type: Number, default: 0 }, push: { type: Number, default: 0 }, xs: { type: ve([Number, Object]), default: () => ln({}) }, sm: { type: ve([Number, Object]), default: () => ln({}) }, md: { type: ve([Number, Object]), default: () => ln({}) }, lg: { type: ve([Number, Object]), default: () => ln({}) }, xl: { type: ve([Number, Object]), default: () => ln({}) } }), _z = ae({ name: "ElCol" }), kz = ae({ ..._z, props: Sz, setup(e) { const t = e, { gutter: n } = Ye(xC, { gutter: S(() => 0) }), o = Ie("col"), r = S(() => { const l = {}; return n.value && (l.paddingLeft = l.paddingRight = `${n.value / 2}px`), l; }), s = S(() => { const l = []; return ["span", "offset", "pull", "push"].forEach(c => { const d = t[c]; lt(d) && (c === "span" ? l.push(o.b(`${t[c]}`)) : d > 0 && l.push(o.b(`${c}-${t[c]}`))); }), ["xs", "sm", "md", "lg", "xl"].forEach(c => { lt(t[c]) ? l.push(o.b(`${c}-${t[c]}`)) : yt(t[c]) && Object.entries(t[c]).forEach(([d, f]) => { l.push(d !== "span" ? o.b(`${c}-${d}-${f}`) : o.b(`${c}-${f}`)); }); }), n.value && l.push(o.is("guttered")), [o.b(), l]; }); return (l, a) => (k(), ge(kt(l.tag), { class: O(i(s)), style: et(i(r)) }, { default: ie(() => [ke(l.$slots, "default")]), _: 3 }, 8, ["class", "style"])); } });
var Ez = Fe(kz, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/col/src/col.vue"]]);
const $z = vt(Ez), O0 = e => typeof lt(e), Tz = Ve({ accordion: Boolean, modelValue: { type: ve([Array, String, Number]), default: () => ln([]) } }), Oz = { [gt]: O0, [en]: O0 }, AC = Symbol("collapseContextKey"), Iz = (e, t) => { const n = M(xl(e.modelValue)), o = s => { n.value = s; const l = e.accordion ? n.value[0] : n.value; t(gt, l), t(en, l); }, r = s => { if (e.accordion)
    o([n.value[0] === s ? "" : s]);
else {
    const l = [...n.value], a = l.indexOf(s);
    a > -1 ? l.splice(a, 1) : l.push(s), o(l);
} }; return Oe(() => e.modelValue, () => n.value = xl(e.modelValue), { deep: !0 }), St(AC, { activeNames: n, handleItemClick: r }), { activeNames: n, setActiveNames: o }; }, xz = () => { const e = Ie("collapse"); return { rootKls: S(() => e.b()) }; }, Az = ae({ name: "ElCollapse" }), Mz = ae({ ...Az, props: Tz, emits: Oz, setup(e, { expose: t, emit: n }) { const o = e, { activeNames: r, setActiveNames: s } = Iz(o, n), { rootKls: l } = xz(); return t({ activeNames: r, setActiveNames: s }), (a, u) => (k(), z("div", { class: O(i(l)), role: "tablist", "aria-multiselectable": "true" }, [ke(a.$slots, "default")], 2)); } });
var Nz = Fe(Mz, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse/src/collapse.vue"]]);
const Pz = ae({ name: "ElCollapseTransition" }), Rz = ae({ ...Pz, setup(e) { const t = Ie("collapse-transition"), n = { beforeEnter(o) { o.dataset || (o.dataset = {}), o.dataset.oldPaddingTop = o.style.paddingTop, o.dataset.oldPaddingBottom = o.style.paddingBottom, o.style.maxHeight = 0, o.style.paddingTop = 0, o.style.paddingBottom = 0; }, enter(o) { o.dataset.oldOverflow = o.style.overflow, o.scrollHeight !== 0 ? (o.style.maxHeight = `${o.scrollHeight}px`, o.style.paddingTop = o.dataset.oldPaddingTop, o.style.paddingBottom = o.dataset.oldPaddingBottom) : (o.style.maxHeight = 0, o.style.paddingTop = o.dataset.oldPaddingTop, o.style.paddingBottom = o.dataset.oldPaddingBottom), o.style.overflow = "hidden"; }, afterEnter(o) { o.style.maxHeight = "", o.style.overflow = o.dataset.oldOverflow; }, beforeLeave(o) { o.dataset || (o.dataset = {}), o.dataset.oldPaddingTop = o.style.paddingTop, o.dataset.oldPaddingBottom = o.style.paddingBottom, o.dataset.oldOverflow = o.style.overflow, o.style.maxHeight = `${o.scrollHeight}px`, o.style.overflow = "hidden"; }, leave(o) { o.scrollHeight !== 0 && (o.style.maxHeight = 0, o.style.paddingTop = 0, o.style.paddingBottom = 0); }, afterLeave(o) { o.style.maxHeight = "", o.style.overflow = o.dataset.oldOverflow, o.style.paddingTop = o.dataset.oldPaddingTop, o.style.paddingBottom = o.dataset.oldPaddingBottom; } }; return (o, r) => (k(), ge(yn, Ct({ name: i(t).b() }, Sk(n)), { default: ie(() => [ke(o.$slots, "default")]), _: 3 }, 16, ["name"])); } });
var bu = Fe(Rz, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse-transition/src/collapse-transition.vue"]]);
bu.install = e => { e.component(bu.name, bu); };
const jc = bu, Lz = jc, Dz = Ve({ title: { type: String, default: "" }, name: { type: ve([String, Number]), default: () => Rc() }, disabled: Boolean }), Bz = e => { const t = Ye(AC), n = M(!1), o = M(!1), r = M(Rc()), s = S(() => t == null ? void 0 : t.activeNames.value.includes(e.name)); return { focusing: n, id: r, isActive: s, handleFocus: () => { setTimeout(() => { o.value ? o.value = !1 : n.value = !0; }, 50); }, handleHeaderClick: () => { e.disabled || (t == null || t.handleItemClick(e.name), n.value = !1, o.value = !0); }, handleEnterClick: () => { t == null || t.handleItemClick(e.name); } }; }, Fz = (e, { focusing: t, isActive: n, id: o }) => { const r = Ie("collapse"), s = S(() => [r.b("item"), r.is("active", i(n)), r.is("disabled", e.disabled)]), l = S(() => [r.be("item", "header"), r.is("active", i(n)), { focusing: i(t) && !e.disabled }]), a = S(() => [r.be("item", "arrow"), r.is("active", i(n))]), u = S(() => r.be("item", "wrap")), c = S(() => r.be("item", "content")), d = S(() => r.b(`content-${i(o)}`)), f = S(() => r.b(`head-${i(o)}`)); return { arrowKls: a, headKls: l, rootKls: s, itemWrapperKls: u, itemContentKls: c, scopedContentId: d, scopedHeadId: f }; }, Vz = ["aria-expanded", "aria-controls", "aria-describedby"], zz = ["id", "tabindex"], Hz = ["id", "aria-hidden", "aria-labelledby"], Kz = ae({ name: "ElCollapseItem" }), jz = ae({ ...Kz, props: Dz, setup(e, { expose: t }) { const n = e, { focusing: o, id: r, isActive: s, handleFocus: l, handleHeaderClick: a, handleEnterClick: u } = Bz(n), { arrowKls: c, headKls: d, rootKls: f, itemWrapperKls: p, itemContentKls: v, scopedContentId: m, scopedHeadId: h } = Fz(n, { focusing: o, isActive: s, id: r }); return t({ isActive: s }), (g, y) => (k(), z("div", { class: O(i(f)) }, [Q("div", { role: "tab", "aria-expanded": i(s), "aria-controls": i(m), "aria-describedby": i(m) }, [Q("div", { id: i(h), class: O(i(d)), role: "button", tabindex: g.disabled ? -1 : 0, onClick: y[0] || (y[0] = (...C) => i(a) && i(a)(...C)), onKeypress: y[1] || (y[1] = Mt(st((...C) => i(u) && i(u)(...C), ["stop", "prevent"]), ["space", "enter"])), onFocus: y[2] || (y[2] = (...C) => i(l) && i(l)(...C)), onBlur: y[3] || (y[3] = C => o.value = !1) }, [ke(g.$slots, "title", {}, () => [Ot(Be(g.title), 1)]), ee(i(Je), { class: O(i(c)) }, { default: ie(() => [ee(i(Un))]), _: 1 }, 8, ["class"])], 42, zz)], 8, Vz), ee(i(jc), null, { default: ie(() => [dt(Q("div", { id: i(m), class: O(i(p)), role: "tabpanel", "aria-hidden": !i(s), "aria-labelledby": i(h) }, [Q("div", { class: O(i(v)) }, [ke(g.$slots, "default")], 2)], 10, Hz), [[Pt, i(s)]])]), _: 3 })], 2)); } });
var MC = Fe(jz, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse/src/collapse-item.vue"]]);
const Wz = vt(Nz, { CollapseItem: MC }), Uz = pn(MC), qz = Ve({ color: { type: ve(Object), required: !0 }, vertical: { type: Boolean, default: !1 } });
let Md = !1;
function si(e, t) { if (!At)
    return; const n = function (s) { var l; (l = t.drag) == null || l.call(t, s); }, o = function (s) { var l; document.removeEventListener("mousemove", n), document.removeEventListener("mouseup", o), document.removeEventListener("touchmove", n), document.removeEventListener("touchend", o), document.onselectstart = null, document.ondragstart = null, Md = !1, (l = t.end) == null || l.call(t, s); }, r = function (s) { var l; Md || (s.preventDefault(), document.onselectstart = () => !1, document.ondragstart = () => !1, document.addEventListener("mousemove", n), document.addEventListener("mouseup", o), document.addEventListener("touchmove", n), document.addEventListener("touchend", o), Md = !0, (l = t.start) == null || l.call(t, s)); }; e.addEventListener("mousedown", r), e.addEventListener("touchstart", r); }
const Yz = e => { const t = ht(), n = Xt(), o = Xt(); function r(l) { l.target !== n.value && s(l); } function s(l) { if (!o.value || !n.value)
    return; const u = t.vnode.el.getBoundingClientRect(), { clientX: c, clientY: d } = jp(l); if (e.vertical) {
    let f = d - u.top;
    f = Math.max(n.value.offsetHeight / 2, f), f = Math.min(f, u.height - n.value.offsetHeight / 2), e.color.set("alpha", Math.round((f - n.value.offsetHeight / 2) / (u.height - n.value.offsetHeight) * 100));
}
else {
    let f = c - u.left;
    f = Math.max(n.value.offsetWidth / 2, f), f = Math.min(f, u.width - n.value.offsetWidth / 2), e.color.set("alpha", Math.round((f - n.value.offsetWidth / 2) / (u.width - n.value.offsetWidth) * 100));
} } return { thumb: n, bar: o, handleDrag: s, handleClick: r }; }, Gz = (e, { bar: t, thumb: n, handleDrag: o }) => { const r = ht(), s = Ie("color-alpha-slider"), l = M(0), a = M(0), u = M(); function c() { if (!n.value || e.vertical)
    return 0; const C = r.vnode.el, b = e.color.get("alpha"); return C ? Math.round(b * (C.offsetWidth - n.value.offsetWidth / 2) / 100) : 0; } function d() { if (!n.value)
    return 0; const C = r.vnode.el; if (!e.vertical)
    return 0; const b = e.color.get("alpha"); return C ? Math.round(b * (C.offsetHeight - n.value.offsetHeight / 2) / 100) : 0; } function f() { if (e.color && e.color.value) {
    const { r: C, g: b, b: w } = e.color.toRgb();
    return `linear-gradient(to right, rgba(${C}, ${b}, ${w}, 0) 0%, rgba(${C}, ${b}, ${w}, 1) 100%)`;
} return ""; } function p() { l.value = c(), a.value = d(), u.value = f(); } ft(() => { if (!t.value || !n.value)
    return; const C = { drag: b => { o(b); }, end: b => { o(b); } }; si(t.value, C), si(n.value, C), p(); }), Oe(() => e.color.get("alpha"), () => p()), Oe(() => e.color.value, () => p()); const v = S(() => [s.b(), s.is("vertical", e.vertical)]), m = S(() => s.e("bar")), h = S(() => s.e("thumb")), g = S(() => ({ background: u.value })), y = S(() => ({ left: gn(l.value), top: gn(a.value) })); return { rootKls: v, barKls: m, barStyle: g, thumbKls: h, thumbStyle: y, update: p }; }, Xz = "ElColorAlphaSlider", Jz = ae({ name: Xz }), Zz = ae({ ...Jz, props: qz, setup(e, { expose: t }) { const n = e, { bar: o, thumb: r, handleDrag: s, handleClick: l } = Yz(n), { rootKls: a, barKls: u, barStyle: c, thumbKls: d, thumbStyle: f, update: p } = Gz(n, { bar: o, thumb: r, handleDrag: s }); return t({ update: p, bar: o, thumb: r }), (v, m) => (k(), z("div", { class: O(i(a)) }, [Q("div", { ref_key: "bar", ref: o, class: O(i(u)), style: et(i(c)), onClick: m[0] || (m[0] = (...h) => i(l) && i(l)(...h)) }, null, 6), Q("div", { ref_key: "thumb", ref: r, class: O(i(d)), style: et(i(f)) }, null, 6)], 2)); } });
var Qz = Fe(Zz, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/alpha-slider.vue"]]);
const eH = ae({ name: "ElColorHueSlider", props: { color: { type: Object, required: !0 }, vertical: Boolean }, setup(e) { const t = Ie("color-hue-slider"), n = ht(), o = M(), r = M(), s = M(0), l = M(0), a = S(() => e.color.get("hue")); Oe(() => a.value, () => { p(); }); function u(v) { v.target !== o.value && c(v); } function c(v) { if (!r.value || !o.value)
        return; const h = n.vnode.el.getBoundingClientRect(), { clientX: g, clientY: y } = jp(v); let C; if (e.vertical) {
        let b = y - h.top;
        b = Math.min(b, h.height - o.value.offsetHeight / 2), b = Math.max(o.value.offsetHeight / 2, b), C = Math.round((b - o.value.offsetHeight / 2) / (h.height - o.value.offsetHeight) * 360);
    }
    else {
        let b = g - h.left;
        b = Math.min(b, h.width - o.value.offsetWidth / 2), b = Math.max(o.value.offsetWidth / 2, b), C = Math.round((b - o.value.offsetWidth / 2) / (h.width - o.value.offsetWidth) * 360);
    } e.color.set("hue", C); } function d() { if (!o.value)
        return 0; const v = n.vnode.el; if (e.vertical)
        return 0; const m = e.color.get("hue"); return v ? Math.round(m * (v.offsetWidth - o.value.offsetWidth / 2) / 360) : 0; } function f() { if (!o.value)
        return 0; const v = n.vnode.el; if (!e.vertical)
        return 0; const m = e.color.get("hue"); return v ? Math.round(m * (v.offsetHeight - o.value.offsetHeight / 2) / 360) : 0; } function p() { s.value = d(), l.value = f(); } return ft(() => { if (!r.value || !o.value)
        return; const v = { drag: m => { c(m); }, end: m => { c(m); } }; si(r.value, v), si(o.value, v), p(); }), { bar: r, thumb: o, thumbLeft: s, thumbTop: l, hueValue: a, handleClick: u, update: p, ns: t }; } });
function tH(e, t, n, o, r, s) { return k(), z("div", { class: O([e.ns.b(), e.ns.is("vertical", e.vertical)]) }, [Q("div", { ref: "bar", class: O(e.ns.e("bar")), onClick: t[0] || (t[0] = (...l) => e.handleClick && e.handleClick(...l)) }, null, 2), Q("div", { ref: "thumb", class: O(e.ns.e("thumb")), style: et({ left: e.thumbLeft + "px", top: e.thumbTop + "px" }) }, null, 6)], 2); }
var nH = Fe(eH, [["render", tH], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/hue-slider.vue"]]);
const oH = Ve({ modelValue: String, id: String, showAlpha: Boolean, colorFormat: String, disabled: Boolean, size: Bn, popperClass: { type: String, default: "" }, label: { type: String, default: void 0 }, tabindex: { type: [String, Number], default: 0 }, predefine: { type: ve(Array) }, validateEvent: { type: Boolean, default: !0 } }), rH = { [gt]: e => it(e) || bn(e), [en]: e => it(e) || bn(e), activeChange: e => it(e) || bn(e) }, NC = Symbol("colorPickerContextKey"), I0 = function (e, t, n) { return [e, t * n / ((e = (2 - t) * n) < 1 ? e : 2 - e) || 0, e / 2]; }, sH = function (e) { return typeof e == "string" && e.includes(".") && Number.parseFloat(e) === 1; }, lH = function (e) { return typeof e == "string" && e.includes("%"); }, yl = function (e, t) { sH(e) && (e = "100%"); const n = lH(e); return e = Math.min(t, Math.max(0, Number.parseFloat(`${e}`))), n && (e = Number.parseInt(`${e * t}`, 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : e % t / Number.parseFloat(t); }, x0 = { 10: "A", 11: "B", 12: "C", 13: "D", 14: "E", 15: "F" }, wu = e => { e = Math.min(Math.round(e), 255); const t = Math.floor(e / 16), n = e % 16; return `${x0[t] || t}${x0[n] || n}`; }, A0 = function ({ r: e, g: t, b: n }) { return Number.isNaN(+e) || Number.isNaN(+t) || Number.isNaN(+n) ? "" : `#${wu(e)}${wu(t)}${wu(n)}`; }, Nd = { A: 10, B: 11, C: 12, D: 13, E: 14, F: 15 }, ys = function (e) { return e.length === 2 ? (Nd[e[0].toUpperCase()] || +e[0]) * 16 + (Nd[e[1].toUpperCase()] || +e[1]) : Nd[e[1].toUpperCase()] || +e[1]; }, aH = function (e, t, n) { t = t / 100, n = n / 100; let o = t; const r = Math.max(n, .01); n *= 2, t *= n <= 1 ? n : 2 - n, o *= r <= 1 ? r : 2 - r; const s = (n + t) / 2, l = n === 0 ? 2 * o / (r + o) : 2 * t / (n + t); return { h: e, s: l * 100, v: s * 100 }; }, M0 = (e, t, n) => { e = yl(e, 255), t = yl(t, 255), n = yl(n, 255); const o = Math.max(e, t, n), r = Math.min(e, t, n); let s; const l = o, a = o - r, u = o === 0 ? 0 : a / o; if (o === r)
    s = 0;
else {
    switch (o) {
        case e: {
            s = (t - n) / a + (t < n ? 6 : 0);
            break;
        }
        case t: {
            s = (n - e) / a + 2;
            break;
        }
        case n: {
            s = (e - t) / a + 4;
            break;
        }
    }
    s /= 6;
} return { h: s * 360, s: u * 100, v: l * 100 }; }, ua = function (e, t, n) { e = yl(e, 360) * 6, t = yl(t, 100), n = yl(n, 100); const o = Math.floor(e), r = e - o, s = n * (1 - t), l = n * (1 - r * t), a = n * (1 - (1 - r) * t), u = o % 6, c = [n, l, s, s, a, n][u], d = [a, n, n, l, s, s][u], f = [s, s, a, n, n, l][u]; return { r: Math.round(c * 255), g: Math.round(d * 255), b: Math.round(f * 255) }; };
class Ia {
    constructor(t = {}) { this._hue = 0, this._saturation = 100, this._value = 100, this._alpha = 100, this.enableAlpha = !1, this.format = "hex", this.value = ""; for (const n in t)
        Tt(t, n) && (this[n] = t[n]); t.value ? this.fromString(t.value) : this.doOnChange(); }
    set(t, n) { if (arguments.length === 1 && typeof t == "object") {
        for (const o in t)
            Tt(t, o) && this.set(o, t[o]);
        return;
    } this[`_${t}`] = n, this.doOnChange(); }
    get(t) { return t === "alpha" ? Math.floor(this[`_${t}`]) : this[`_${t}`]; }
    toRgb() { return ua(this._hue, this._saturation, this._value); }
    fromString(t) { if (!t) {
        this._hue = 0, this._saturation = 100, this._value = 100, this.doOnChange();
        return;
    } const n = (o, r, s) => { this._hue = Math.max(0, Math.min(360, o)), this._saturation = Math.max(0, Math.min(100, r)), this._value = Math.max(0, Math.min(100, s)), this.doOnChange(); }; if (t.includes("hsl")) {
        const o = t.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter(r => r !== "").map((r, s) => s > 2 ? Number.parseFloat(r) : Number.parseInt(r, 10));
        if (o.length === 4 ? this._alpha = Number.parseFloat(o[3]) * 100 : o.length === 3 && (this._alpha = 100), o.length >= 3) {
            const { h: r, s, v: l } = aH(o[0], o[1], o[2]);
            n(r, s, l);
        }
    }
    else if (t.includes("hsv")) {
        const o = t.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter(r => r !== "").map((r, s) => s > 2 ? Number.parseFloat(r) : Number.parseInt(r, 10));
        o.length === 4 ? this._alpha = Number.parseFloat(o[3]) * 100 : o.length === 3 && (this._alpha = 100), o.length >= 3 && n(o[0], o[1], o[2]);
    }
    else if (t.includes("rgb")) {
        const o = t.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter(r => r !== "").map((r, s) => s > 2 ? Number.parseFloat(r) : Number.parseInt(r, 10));
        if (o.length === 4 ? this._alpha = Number.parseFloat(o[3]) * 100 : o.length === 3 && (this._alpha = 100), o.length >= 3) {
            const { h: r, s, v: l } = M0(o[0], o[1], o[2]);
            n(r, s, l);
        }
    }
    else if (t.includes("#")) {
        const o = t.replace("#", "").trim();
        if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(o))
            return;
        let r, s, l;
        o.length === 3 ? (r = ys(o[0] + o[0]), s = ys(o[1] + o[1]), l = ys(o[2] + o[2])) : (o.length === 6 || o.length === 8) && (r = ys(o.slice(0, 2)), s = ys(o.slice(2, 4)), l = ys(o.slice(4, 6))), o.length === 8 ? this._alpha = ys(o.slice(6)) / 255 * 100 : (o.length === 3 || o.length === 6) && (this._alpha = 100);
        const { h: a, s: u, v: c } = M0(r, s, l);
        n(a, u, c);
    } }
    compare(t) { return Math.abs(t._hue - this._hue) < 2 && Math.abs(t._saturation - this._saturation) < 1 && Math.abs(t._value - this._value) < 1 && Math.abs(t._alpha - this._alpha) < 1; }
    doOnChange() { const { _hue: t, _saturation: n, _value: o, _alpha: r, format: s } = this; if (this.enableAlpha)
        switch (s) {
            case "hsl": {
                const l = I0(t, n / 100, o / 100);
                this.value = `hsla(${t}, ${Math.round(l[1] * 100)}%, ${Math.round(l[2] * 100)}%, ${this.get("alpha") / 100})`;
                break;
            }
            case "hsv": {
                this.value = `hsva(${t}, ${Math.round(n)}%, ${Math.round(o)}%, ${this.get("alpha") / 100})`;
                break;
            }
            case "hex": {
                this.value = `${A0(ua(t, n, o))}${wu(r * 255 / 100)}`;
                break;
            }
            default: {
                const { r: l, g: a, b: u } = ua(t, n, o);
                this.value = `rgba(${l}, ${a}, ${u}, ${this.get("alpha") / 100})`;
            }
        }
    else
        switch (s) {
            case "hsl": {
                const l = I0(t, n / 100, o / 100);
                this.value = `hsl(${t}, ${Math.round(l[1] * 100)}%, ${Math.round(l[2] * 100)}%)`;
                break;
            }
            case "hsv": {
                this.value = `hsv(${t}, ${Math.round(n)}%, ${Math.round(o)}%)`;
                break;
            }
            case "rgb": {
                const { r: l, g: a, b: u } = ua(t, n, o);
                this.value = `rgb(${l}, ${a}, ${u})`;
                break;
            }
            default: this.value = A0(ua(t, n, o));
        } }
}
const iH = ae({ props: { colors: { type: Array, required: !0 }, color: { type: Object, required: !0 } }, setup(e) { const t = Ie("color-predefine"), { currentColor: n } = Ye(NC), o = M(s(e.colors, e.color)); Oe(() => n.value, l => { const a = new Ia; a.fromString(l), o.value.forEach(u => { u.selected = a.compare(u); }); }), mo(() => { o.value = s(e.colors, e.color); }); function r(l) { e.color.fromString(e.colors[l]); } function s(l, a) { return l.map(u => { const c = new Ia; return c.enableAlpha = !0, c.format = "rgba", c.fromString(u), c.selected = c.value === a.value, c; }); } return { rgbaColors: o, handleSelect: r, ns: t }; } }), uH = ["onClick"];
function cH(e, t, n, o, r, s) { return k(), z("div", { class: O(e.ns.b()) }, [Q("div", { class: O(e.ns.e("colors")) }, [(k(!0), z(Qe, null, Et(e.rgbaColors, (l, a) => (k(), z("div", { key: e.colors[a], class: O([e.ns.e("color-selector"), e.ns.is("alpha", l._alpha < 100), { selected: l.selected }]), onClick: u => e.handleSelect(a) }, [Q("div", { style: et({ backgroundColor: l.value }) }, null, 4)], 10, uH))), 128))], 2)], 2); }
var dH = Fe(iH, [["render", cH], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/predefine.vue"]]);
const fH = ae({ name: "ElSlPanel", props: { color: { type: Object, required: !0 } }, setup(e) { const t = Ie("color-svpanel"), n = ht(), o = M(0), r = M(0), s = M("hsl(0, 100%, 50%)"), l = S(() => { const c = e.color.get("hue"), d = e.color.get("value"); return { hue: c, value: d }; }); function a() { const c = e.color.get("saturation"), d = e.color.get("value"), f = n.vnode.el, { clientWidth: p, clientHeight: v } = f; r.value = c * p / 100, o.value = (100 - d) * v / 100, s.value = `hsl(${e.color.get("hue")}, 100%, 50%)`; } function u(c) { const f = n.vnode.el.getBoundingClientRect(), { clientX: p, clientY: v } = jp(c); let m = p - f.left, h = v - f.top; m = Math.max(0, m), m = Math.min(m, f.width), h = Math.max(0, h), h = Math.min(h, f.height), r.value = m, o.value = h, e.color.set({ saturation: m / f.width * 100, value: 100 - h / f.height * 100 }); } return Oe(() => l.value, () => { a(); }), ft(() => { si(n.vnode.el, { drag: c => { u(c); }, end: c => { u(c); } }), a(); }), { cursorTop: o, cursorLeft: r, background: s, colorValue: l, handleDrag: u, update: a, ns: t }; } }), pH = Q("div", null, null, -1), hH = [pH];
function vH(e, t, n, o, r, s) { return k(), z("div", { class: O(e.ns.b()), style: et({ backgroundColor: e.background }) }, [Q("div", { class: O(e.ns.e("white")) }, null, 2), Q("div", { class: O(e.ns.e("black")) }, null, 2), Q("div", { class: O(e.ns.e("cursor")), style: et({ top: e.cursorTop + "px", left: e.cursorLeft + "px" }) }, hH, 6)], 6); }
var mH = Fe(fH, [["render", vH], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/sv-panel.vue"]]);
const gH = ["id", "aria-label", "aria-labelledby", "aria-description", "tabindex", "onKeydown"], yH = ae({ name: "ElColorPicker" }), bH = ae({ ...yH, props: oH, emits: rH, setup(e, { expose: t, emit: n }) { const o = e, { t: r } = Nt(), s = Ie("color"), { formItem: l } = Zn(), a = kn(), u = uo(), { inputId: c, isLabeledByFormItem: d } = us(o, { formItemContext: l }), f = M(), p = M(), v = M(), m = M(); let h = !0; const g = Lt(new Ia({ enableAlpha: o.showAlpha, format: o.colorFormat || "", value: o.modelValue })), y = M(!1), C = M(!1), b = M(""), w = S(() => !o.modelValue && !C.value ? "transparent" : L(g, o.showAlpha)), T = S(() => !o.modelValue && !C.value ? "" : g.value), E = S(() => d.value ? void 0 : o.label || r("el.colorpicker.defaultLabel")), x = S(() => d.value ? l == null ? void 0 : l.labelId : void 0), I = S(() => [s.b("picker"), s.is("disabled", u.value), s.bm("picker", a.value)]); function L(A, G) { if (!(A instanceof Ia))
        throw new TypeError("color should be instance of _color Class"); const { r: se, g: Z, b: ce } = A.toRgb(); return G ? `rgba(${se}, ${Z}, ${ce}, ${A.get("alpha") / 100})` : `rgb(${se}, ${Z}, ${ce})`; } function B(A) { y.value = A; } const F = Xn(B, 100); function V() { u.value || B(!0); } function R() { F(!1), K(); } function K() { Xe(() => { o.modelValue ? g.fromString(o.modelValue) : (g.value = "", Xe(() => { C.value = !1; })); }); } function te() { u.value || F(!y.value); } function U() { g.fromString(b.value); } function D() { const A = g.value; n(gt, A), n("change", A), o.validateEvent && (l == null || l.validate("change").catch(G => void 0)), F(!1), Xe(() => { const G = new Ia({ enableAlpha: o.showAlpha, format: o.colorFormat || "", value: o.modelValue }); g.compare(G) || K(); }); } function j() { F(!1), n(gt, null), n("change", null), o.modelValue !== null && o.validateEvent && (l == null || l.validate("change").catch(A => void 0)), K(); } return ft(() => { o.modelValue && (b.value = T.value); }), Oe(() => o.modelValue, A => { A ? A && A !== g.value && (h = !1, g.fromString(A)) : C.value = !1; }), Oe(() => T.value, A => { b.value = A, h && n("activeChange", A), h = !0; }), Oe(() => g.value, () => { !o.modelValue && !C.value && (C.value = !0); }), Oe(() => y.value, () => { Xe(() => { var A, G, se; (A = f.value) == null || A.update(), (G = p.value) == null || G.update(), (se = v.value) == null || se.update(); }); }), St(NC, { currentColor: T }), t({ color: g, show: V, hide: R }), (A, G) => (k(), ge(i(Jn), { ref_key: "popper", ref: m, visible: y.value, "show-arrow": !1, "fallback-placements": ["bottom", "top", "right", "left"], offset: 0, "gpu-acceleration": !1, "popper-class": [i(s).be("picker", "panel"), i(s).b("dropdown"), A.popperClass], "stop-popper-mouse-event": !1, effect: "light", trigger: "click", transition: `${i(s).namespace.value}-zoom-in-top`, persistent: "" }, { content: ie(() => [dt((k(), z("div", null, [Q("div", { class: O(i(s).be("dropdown", "main-wrapper")) }, [ee(nH, { ref_key: "hue", ref: f, class: "hue-slider", color: i(g), vertical: "" }, null, 8, ["color"]), ee(mH, { ref_key: "sv", ref: p, color: i(g) }, null, 8, ["color"])], 2), A.showAlpha ? (k(), ge(Qz, { key: 0, ref_key: "alpha", ref: v, color: i(g) }, null, 8, ["color"])) : pe("v-if", !0), A.predefine ? (k(), ge(dH, { key: 1, ref: "predefine", color: i(g), colors: A.predefine }, null, 8, ["color", "colors"])) : pe("v-if", !0), Q("div", { class: O(i(s).be("dropdown", "btns")) }, [Q("span", { class: O(i(s).be("dropdown", "value")) }, [ee(i(Ln), { modelValue: b.value, "onUpdate:modelValue": G[0] || (G[0] = se => b.value = se), "validate-event": !1, size: "small", onKeyup: Mt(U, ["enter"]), onBlur: U }, null, 8, ["modelValue", "onKeyup"])], 2), ee(i(xn), { class: O(i(s).be("dropdown", "link-btn")), text: "", size: "small", onClick: j }, { default: ie(() => [Ot(Be(i(r)("el.colorpicker.clear")), 1)]), _: 1 }, 8, ["class"]), ee(i(xn), { plain: "", size: "small", class: O(i(s).be("dropdown", "btn")), onClick: D }, { default: ie(() => [Ot(Be(i(r)("el.colorpicker.confirm")), 1)]), _: 1 }, 8, ["class"])], 2)])), [[i(ns), R]])]), default: ie(() => [Q("div", { id: i(c), class: O(i(I)), role: "button", "aria-label": i(E), "aria-labelledby": i(x), "aria-description": i(r)("el.colorpicker.description", { color: A.modelValue || "" }), tabindex: A.tabindex, onKeydown: Mt(te, ["enter"]) }, [i(u) ? (k(), z("div", { key: 0, class: O(i(s).be("picker", "mask")) }, null, 2)) : pe("v-if", !0), Q("div", { class: O(i(s).be("picker", "trigger")), onClick: te }, [Q("span", { class: O([i(s).be("picker", "color"), i(s).is("alpha", A.showAlpha)]) }, [Q("span", { class: O(i(s).be("picker", "color-inner")), style: et({ backgroundColor: i(w) }) }, [dt(ee(i(Je), { class: O([i(s).be("picker", "icon"), i(s).is("icon-arrow-down")]) }, { default: ie(() => [ee(i(ss))]), _: 1 }, 8, ["class"]), [[Pt, A.modelValue || C.value]]), !A.modelValue && !C.value ? (k(), ge(i(Je), { key: 0, class: O([i(s).be("picker", "empty"), i(s).is("icon-close")]) }, { default: ie(() => [ee(i(Ho))]), _: 1 }, 8, ["class"])) : pe("v-if", !0)], 6)], 2)], 2)], 42, gH)]), _: 1 }, 8, ["visible", "popper-class", "transition"])); } });
var wH = Fe(bH, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/color-picker.vue"]]);
const CH = vt(wH), SH = ae({ name: "ElContainer" }), _H = ae({ ...SH, props: { direction: { type: String } }, setup(e) { const t = e, n = An(), o = Ie("container"), r = S(() => t.direction === "vertical" ? !0 : t.direction === "horizontal" ? !1 : n && n.default ? n.default().some(l => { const a = l.type.name; return a === "ElHeader" || a === "ElFooter"; }) : !1); return (s, l) => (k(), z("section", { class: O([i(o).b(), i(o).is("vertical", i(r))]) }, [ke(s.$slots, "default")], 2)); } });
var kH = Fe(_H, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/container.vue"]]);
const EH = ae({ name: "ElAside" }), $H = ae({ ...EH, props: { width: { type: String, default: null } }, setup(e) { const t = e, n = Ie("aside"), o = S(() => t.width ? n.cssVarBlock({ width: t.width }) : {}); return (r, s) => (k(), z("aside", { class: O(i(n).b()), style: et(i(o)) }, [ke(r.$slots, "default")], 6)); } });
var PC = Fe($H, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/aside.vue"]]);
const TH = ae({ name: "ElFooter" }), OH = ae({ ...TH, props: { height: { type: String, default: null } }, setup(e) { const t = e, n = Ie("footer"), o = S(() => t.height ? n.cssVarBlock({ height: t.height }) : {}); return (r, s) => (k(), z("footer", { class: O(i(n).b()), style: et(i(o)) }, [ke(r.$slots, "default")], 6)); } });
var RC = Fe(OH, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/footer.vue"]]);
const IH = ae({ name: "ElHeader" }), xH = ae({ ...IH, props: { height: { type: String, default: null } }, setup(e) { const t = e, n = Ie("header"), o = S(() => t.height ? n.cssVarBlock({ height: t.height }) : {}); return (r, s) => (k(), z("header", { class: O(i(n).b()), style: et(i(o)) }, [ke(r.$slots, "default")], 6)); } });
var LC = Fe(xH, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/header.vue"]]);
const AH = ae({ name: "ElMain" }), MH = ae({ ...AH, setup(e) { const t = Ie("main"); return (n, o) => (k(), z("main", { class: O(i(t).b()) }, [ke(n.$slots, "default")], 2)); } });
var DC = Fe(MH, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/main.vue"]]);
const NH = vt(kH, { Aside: PC, Footer: RC, Header: LC, Main: DC }), PH = pn(PC), RH = pn(RC), LH = pn(LC), DH = pn(DC);
var BC = { exports: {} };
(function (e, t) { (function (n, o) { e.exports = o(); })(ko, function () { return function (n, o) { var r = o.prototype, s = r.format; r.format = function (l) { var a = this, u = this.$locale(); if (!this.isValid())
    return s.bind(this)(l); var c = this.$utils(), d = (l || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function (f) { switch (f) {
    case "Q": return Math.ceil((a.$M + 1) / 3);
    case "Do": return u.ordinal(a.$D);
    case "gggg": return a.weekYear();
    case "GGGG": return a.isoWeekYear();
    case "wo": return u.ordinal(a.week(), "W");
    case "w":
    case "ww": return c.s(a.week(), f === "w" ? 1 : 2, "0");
    case "W":
    case "WW": return c.s(a.isoWeek(), f === "W" ? 1 : 2, "0");
    case "k":
    case "kk": return c.s(String(a.$H === 0 ? 24 : a.$H), f === "k" ? 1 : 2, "0");
    case "X": return Math.floor(a.$d.getTime() / 1e3);
    case "x": return a.$d.getTime();
    case "z": return "[" + a.offsetName() + "]";
    case "zzz": return "[" + a.offsetName("long") + "]";
    default: return f;
} }); return s.bind(this)(d); }; }; }); })(BC);
var BH = BC.exports;
const FH = lr(BH);
var FC = { exports: {} };
(function (e, t) { (function (n, o) { e.exports = o(); })(ko, function () { var n = "week", o = "year"; return function (r, s, l) { var a = s.prototype; a.week = function (u) { if (u === void 0 && (u = null), u !== null)
    return this.add(7 * (u - this.week()), "day"); var c = this.$locale().yearStart || 1; if (this.month() === 11 && this.date() > 25) {
    var d = l(this).startOf(o).add(1, o).date(c), f = l(this).endOf(n);
    if (d.isBefore(f))
        return 1;
} var p = l(this).startOf(o).date(c).startOf(n).subtract(1, "millisecond"), v = this.diff(p, n, !0); return v < 0 ? l(this).startOf("week").week() : Math.ceil(v); }, a.weeks = function (u) { return u === void 0 && (u = null), this.week(u); }; }; }); })(FC);
var VH = FC.exports;
const zH = lr(VH);
var VC = { exports: {} };
(function (e, t) { (function (n, o) { e.exports = o(); })(ko, function () { return function (n, o) { o.prototype.weekYear = function () { var r = this.month(), s = this.week(), l = this.year(); return s === 1 && r === 11 ? l + 1 : r === 0 && s >= 52 ? l - 1 : l; }; }; }); })(VC);
var HH = VC.exports;
const KH = lr(HH);
var zC = { exports: {} };
(function (e, t) { (function (n, o) { e.exports = o(); })(ko, function () { return function (n, o, r) { o.prototype.dayOfYear = function (s) { var l = Math.round((r(this).startOf("day") - r(this).startOf("year")) / 864e5) + 1; return s == null ? l : this.add(s - l, "day"); }; }; }); })(zC);
var jH = zC.exports;
const WH = lr(jH);
var HC = { exports: {} };
(function (e, t) { (function (n, o) { e.exports = o(); })(ko, function () { return function (n, o) { o.prototype.isSameOrAfter = function (r, s) { return this.isSame(r, s) || this.isAfter(r, s); }; }; }); })(HC);
var UH = HC.exports;
const qH = lr(UH);
var KC = { exports: {} };
(function (e, t) { (function (n, o) { e.exports = o(); })(ko, function () { return function (n, o) { o.prototype.isSameOrBefore = function (r, s) { return this.isSame(r, s) || this.isBefore(r, s); }; }; }); })(KC);
var YH = KC.exports;
const GH = lr(YH), Lh = Symbol(), XH = Ve({ ...Nh, type: { type: ve(String), default: "date" } }), JH = ["date", "dates", "year", "month", "week", "range"], Dh = Ve({ disabledDate: { type: ve(Function) }, date: { type: ve(Object), required: !0 }, minDate: { type: ve(Object) }, maxDate: { type: ve(Object) }, parsedValue: { type: ve([Object, Array]) }, rangeState: { type: ve(Object), default: () => ({ endDate: null, selecting: !1 }) } }), jC = Ve({ type: { type: ve(String), required: !0, values: YR } }), WC = Ve({ unlinkPanels: Boolean, parsedValue: { type: ve(Array) } }), UC = e => ({ type: String, values: JH, default: e }), ZH = Ve({ ...jC, parsedValue: { type: ve([Object, Array]) }, visible: { type: Boolean }, format: { type: String, default: "" } }), QH = Ve({ ...Dh, cellClassName: { type: ve(Function) }, showWeekNumber: Boolean, selectionMode: UC("date") }), zf = e => { if (!qe(e))
    return !1; const [t, n] = e; return pt.isDayjs(t) && pt.isDayjs(n) && t.isSameOrBefore(n); }, qC = (e, { lang: t, unit: n, unlinkPanels: o }) => { let r; if (qe(e)) {
    let [s, l] = e.map(a => pt(a).locale(t));
    return o || (l = s.add(1, n)), [s, l];
}
else
    e ? r = pt(e) : r = pt(); return r = r.locale(t), [r, r.add(1, n)]; }, eK = (e, t, { columnIndexOffset: n, startDate: o, nextEndDate: r, now: s, unit: l, relativeDateGetter: a, setCellMetadata: u, setRowMetadata: c }) => { for (let d = 0; d < e.row; d++) {
    const f = t[d];
    for (let p = 0; p < e.column; p++) {
        let v = f[p + n];
        v || (v = { row: d, column: p, type: "normal", inRange: !1, start: !1, end: !1 });
        const m = d * e.column + p, h = a(m);
        v.dayjs = h, v.date = h.toDate(), v.timestamp = h.valueOf(), v.type = "normal", v.inRange = !!(o && h.isSameOrAfter(o, l) && r && h.isSameOrBefore(r, l)) || !!(o && h.isSameOrBefore(o, l) && r && h.isSameOrAfter(r, l)), o != null && o.isSameOrAfter(r) ? (v.start = !!r && h.isSame(r, l), v.end = o && h.isSame(o, l)) : (v.start = !!o && h.isSame(o, l), v.end = !!r && h.isSame(r, l)), h.isSame(s, l) && (v.type = "today"), u == null || u(v, { rowIndex: d, columnIndex: p }), f[p + n] = v;
    }
    c == null || c(f);
} }, tK = Ve({ cell: { type: ve(Object) } });
var nK = ae({ name: "ElDatePickerCell", props: tK, setup(e) { const t = Ie("date-table-cell"), { slots: n } = Ye(Lh); return () => { const { cell: o } = e; if (n.default) {
        const r = n.default(o).filter(s => s.patchFlag !== -2 && s.type.toString() !== "Symbol(Comment)");
        if (r.length)
            return r;
    } return ee("div", { class: t.b() }, [ee("span", { class: t.e("text") }, [o == null ? void 0 : o.text])]); }; } });
const oK = ["aria-label", "onMousedown"], rK = { key: 0, scope: "col" }, sK = ["aria-label"], lK = ["aria-current", "aria-selected", "tabindex"], aK = ae({ __name: "basic-date-table", props: QH, emits: ["changerange", "pick", "select"], setup(e, { expose: t, emit: n }) { const o = e, r = Ie("date-table"), { t: s, lang: l } = Nt(), a = M(), u = M(), c = M(), d = M(), f = M([[], [], [], [], [], []]); let p = !1; const v = o.date.$locale().weekStart || 7, m = o.date.locale("en").localeData().weekdaysShort().map(Z => Z.toLowerCase()), h = S(() => v > 3 ? 7 - v : -v), g = S(() => { const Z = o.date.startOf("month"); return Z.subtract(Z.day() || 7, "day"); }), y = S(() => m.concat(m).slice(v, v + 7)), C = S(() => s1(I.value).some(Z => Z.isCurrent)), b = S(() => { const Z = o.date.startOf("month"), ce = Z.day() || 7, ye = Z.daysInMonth(), Re = Z.subtract(1, "month").daysInMonth(); return { startOfMonthDay: ce, dateCountOfMonth: ye, dateCountOfLastMonth: Re }; }), w = S(() => o.selectionMode === "dates" ? yr(o.parsedValue) : []), T = (Z, { count: ce, rowIndex: ye, columnIndex: Re }) => { const { startOfMonthDay: me, dateCountOfMonth: le, dateCountOfLastMonth: oe } = i(b), fe = i(h); if (ye >= 0 && ye <= 1) {
        const Ce = me + fe < 0 ? 7 + me + fe : me + fe;
        if (Re + ye * 7 >= Ce)
            return Z.text = ce, !0;
        Z.text = oe - (Ce - Re % 7) + 1 + ye * 7, Z.type = "prev-month";
    }
    else
        return ce <= le ? Z.text = ce : (Z.text = ce - le, Z.type = "next-month"), !0; return !1; }, E = (Z, { columnIndex: ce, rowIndex: ye }, Re) => { const { disabledDate: me, cellClassName: le } = o, oe = i(w), fe = T(Z, { count: Re, rowIndex: ye, columnIndex: ce }), Ce = Z.dayjs.toDate(); return Z.selected = oe.find(Ae => Ae.valueOf() === Z.dayjs.valueOf()), Z.isSelected = !!Z.selected, Z.isCurrent = F(Z), Z.disabled = me == null ? void 0 : me(Ce), Z.customClass = le == null ? void 0 : le(Ce), fe; }, x = Z => { if (o.selectionMode === "week") {
        const [ce, ye] = o.showWeekNumber ? [1, 7] : [0, 6], Re = se(Z[ce + 1]);
        Z[ce].inRange = Re, Z[ce].start = Re, Z[ye].inRange = Re, Z[ye].end = Re;
    } }, I = S(() => { const { minDate: Z, maxDate: ce, rangeState: ye, showWeekNumber: Re } = o, me = h.value, le = f.value, oe = "day"; let fe = 1; if (Re)
        for (let Ce = 0; Ce < 6; Ce++)
            le[Ce][0] || (le[Ce][0] = { type: "week", text: g.value.add(Ce * 7 + 1, oe).week() }); return eK({ row: 6, column: 7 }, le, { startDate: Z, columnIndexOffset: Re ? 1 : 0, nextEndDate: ye.endDate || ce || ye.selecting && Z || null, now: pt().locale(i(l)).startOf(oe), unit: oe, relativeDateGetter: Ce => g.value.add(Ce - me, oe), setCellMetadata: (...Ce) => { E(...Ce, fe) && (fe += 1); }, setRowMetadata: x }), le; }); Oe(() => o.date, async () => { var Z, ce; (Z = a.value) != null && Z.contains(document.activeElement) && (await Xe(), (ce = u.value) == null || ce.focus()); }); const L = async () => { var Z; (Z = u.value) == null || Z.focus(); }, B = (Z = "") => ["normal", "today"].includes(Z), F = Z => o.selectionMode === "date" && B(Z.type) && V(Z, o.parsedValue), V = (Z, ce) => ce ? pt(ce).locale(l.value).isSame(o.date.date(Number(Z.text)), "day") : !1, R = Z => { const ce = []; return B(Z.type) && !Z.disabled ? (ce.push("available"), Z.type === "today" && ce.push("today")) : ce.push(Z.type), F(Z) && ce.push("current"), Z.inRange && (B(Z.type) || o.selectionMode === "week") && (ce.push("in-range"), Z.start && ce.push("start-date"), Z.end && ce.push("end-date")), Z.disabled && ce.push("disabled"), Z.selected && ce.push("selected"), Z.customClass && ce.push(Z.customClass), ce.join(" "); }, K = (Z, ce) => { const ye = Z * 7 + (ce - (o.showWeekNumber ? 1 : 0)) - h.value; return g.value.add(ye, "day"); }, te = Z => { var ce; if (!o.rangeState.selecting)
        return; let ye = Z.target; if (ye.tagName === "SPAN" && (ye = (ce = ye.parentNode) == null ? void 0 : ce.parentNode), ye.tagName === "DIV" && (ye = ye.parentNode), ye.tagName !== "TD")
        return; const Re = ye.parentNode.rowIndex - 1, me = ye.cellIndex; I.value[Re][me].disabled || (Re !== c.value || me !== d.value) && (c.value = Re, d.value = me, n("changerange", { selecting: !0, endDate: K(Re, me) })); }, U = Z => !C.value && (Z == null ? void 0 : Z.text) === 1 && Z.type === "normal" || Z.isCurrent, D = Z => { p || C.value || o.selectionMode !== "date" || G(Z, !0); }, j = Z => { Z.target.closest("td") && (p = !0); }, A = Z => { Z.target.closest("td") && (p = !1); }, G = (Z, ce = !1) => { const ye = Z.target.closest("td"); if (!ye)
        return; const Re = ye.parentNode.rowIndex - 1, me = ye.cellIndex, le = I.value[Re][me]; if (le.disabled || le.type === "week")
        return; const oe = K(Re, me); if (o.selectionMode === "range")
        !o.rangeState.selecting || !o.minDate ? (n("pick", { minDate: oe, maxDate: null }), n("select", !0)) : (oe >= o.minDate ? n("pick", { minDate: o.minDate, maxDate: oe }) : n("pick", { minDate: oe, maxDate: o.minDate }), n("select", !1));
    else if (o.selectionMode === "date")
        n("pick", oe, ce);
    else if (o.selectionMode === "week") {
        const fe = oe.week(), Ce = `${oe.year()}w${fe}`;
        n("pick", { year: oe.year(), week: fe, value: Ce, date: oe.startOf("week") });
    }
    else if (o.selectionMode === "dates") {
        const fe = le.selected ? yr(o.parsedValue).filter(Ce => (Ce == null ? void 0 : Ce.valueOf()) !== oe.valueOf()) : yr(o.parsedValue).concat([oe]);
        n("pick", fe);
    } }, se = Z => { if (o.selectionMode !== "week")
        return !1; let ce = o.date.startOf("day"); if (Z.type === "prev-month" && (ce = ce.subtract(1, "month")), Z.type === "next-month" && (ce = ce.add(1, "month")), ce = ce.date(Number.parseInt(Z.text, 10)), o.parsedValue && !Array.isArray(o.parsedValue)) {
        const ye = (o.parsedValue.day() - v + 7) % 7 - 1;
        return o.parsedValue.subtract(ye, "day").isSame(ce, "day");
    } return !1; }; return t({ focus: L }), (Z, ce) => (k(), z("table", { role: "grid", "aria-label": i(s)("el.datepicker.dateTablePrompt"), cellspacing: "0", cellpadding: "0", class: O([i(r).b(), { "is-week-mode": Z.selectionMode === "week" }]), onClick: G, onMousemove: te, onMousedown: st(j, ["prevent"]), onMouseup: A }, [Q("tbody", { ref_key: "tbodyRef", ref: a }, [Q("tr", null, [Z.showWeekNumber ? (k(), z("th", rK, Be(i(s)("el.datepicker.week")), 1)) : pe("v-if", !0), (k(!0), z(Qe, null, Et(i(y), (ye, Re) => (k(), z("th", { key: Re, scope: "col", "aria-label": i(s)("el.datepicker.weeksFull." + ye) }, Be(i(s)("el.datepicker.weeks." + ye)), 9, sK))), 128))]), (k(!0), z(Qe, null, Et(i(I), (ye, Re) => (k(), z("tr", { key: Re, class: O([i(r).e("row"), { current: se(ye[1]) }]) }, [(k(!0), z(Qe, null, Et(ye, (me, le) => (k(), z("td", { key: `${Re}.${le}`, ref_for: !0, ref: oe => U(me) && (u.value = oe), class: O(R(me)), "aria-current": me.isCurrent ? "date" : void 0, "aria-selected": me.isCurrent, tabindex: U(me) ? 0 : -1, onFocus: D }, [ee(i(nK), { cell: me }, null, 8, ["cell"])], 42, lK))), 128))], 2))), 128))], 512)], 42, oK)); } });
var Hf = Fe(aK, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-date-table.vue"]]);
const iK = Ve({ ...Dh, selectionMode: UC("month") }), uK = ["aria-label"], cK = ["aria-selected", "aria-label", "tabindex", "onKeydown"], dK = { class: "cell" }, fK = ae({ __name: "basic-month-table", props: iK, emits: ["changerange", "pick", "select"], setup(e, { expose: t, emit: n }) { const o = e, r = (w, T, E) => { const x = pt().locale(E).startOf("month").month(T).year(w), I = x.daysInMonth(); return Gr(I).map(L => x.add(L, "day").toDate()); }, s = Ie("month-table"), { t: l, lang: a } = Nt(), u = M(), c = M(), d = M(o.date.locale("en").localeData().monthsShort().map(w => w.toLowerCase())), f = M([[], [], []]), p = M(), v = M(), m = S(() => { var w, T; const E = f.value, x = pt().locale(a.value).startOf("month"); for (let I = 0; I < 3; I++) {
        const L = E[I];
        for (let B = 0; B < 4; B++) {
            const F = L[B] || (L[B] = { row: I, column: B, type: "normal", inRange: !1, start: !1, end: !1, text: -1, disabled: !1 });
            F.type = "normal";
            const V = I * 4 + B, R = o.date.startOf("year").month(V), K = o.rangeState.endDate || o.maxDate || o.rangeState.selecting && o.minDate || null;
            F.inRange = !!(o.minDate && R.isSameOrAfter(o.minDate, "month") && K && R.isSameOrBefore(K, "month")) || !!(o.minDate && R.isSameOrBefore(o.minDate, "month") && K && R.isSameOrAfter(K, "month")), (w = o.minDate) != null && w.isSameOrAfter(K) ? (F.start = !!(K && R.isSame(K, "month")), F.end = o.minDate && R.isSame(o.minDate, "month")) : (F.start = !!(o.minDate && R.isSame(o.minDate, "month")), F.end = !!(K && R.isSame(K, "month"))), x.isSame(R) && (F.type = "today"), F.text = V, F.disabled = ((T = o.disabledDate) == null ? void 0 : T.call(o, R.toDate())) || !1;
        }
    } return E; }), h = () => { var w; (w = c.value) == null || w.focus(); }, g = w => { const T = {}, E = o.date.year(), x = new Date, I = w.text; return T.disabled = o.disabledDate ? r(E, I, a.value).every(o.disabledDate) : !1, T.current = yr(o.parsedValue).findIndex(L => pt.isDayjs(L) && L.year() === E && L.month() === I) >= 0, T.today = x.getFullYear() === E && x.getMonth() === I, w.inRange && (T["in-range"] = !0, w.start && (T["start-date"] = !0), w.end && (T["end-date"] = !0)), T; }, y = w => { const T = o.date.year(), E = w.text; return yr(o.date).findIndex(x => x.year() === T && x.month() === E) >= 0; }, C = w => { var T; if (!o.rangeState.selecting)
        return; let E = w.target; if (E.tagName === "A" && (E = (T = E.parentNode) == null ? void 0 : T.parentNode), E.tagName === "DIV" && (E = E.parentNode), E.tagName !== "TD")
        return; const x = E.parentNode.rowIndex, I = E.cellIndex; m.value[x][I].disabled || (x !== p.value || I !== v.value) && (p.value = x, v.value = I, n("changerange", { selecting: !0, endDate: o.date.startOf("year").month(x * 4 + I) })); }, b = w => { var T; const E = (T = w.target) == null ? void 0 : T.closest("td"); if ((E == null ? void 0 : E.tagName) !== "TD" || Vo(E, "disabled"))
        return; const x = E.cellIndex, L = E.parentNode.rowIndex * 4 + x, B = o.date.startOf("year").month(L); o.selectionMode === "range" ? o.rangeState.selecting ? (o.minDate && B >= o.minDate ? n("pick", { minDate: o.minDate, maxDate: B }) : n("pick", { minDate: B, maxDate: o.minDate }), n("select", !1)) : (n("pick", { minDate: B, maxDate: null }), n("select", !0)) : n("pick", L); }; return Oe(() => o.date, async () => { var w, T; (w = u.value) != null && w.contains(document.activeElement) && (await Xe(), (T = c.value) == null || T.focus()); }), t({ focus: h }), (w, T) => (k(), z("table", { role: "grid", "aria-label": i(l)("el.datepicker.monthTablePrompt"), class: O(i(s).b()), onClick: b, onMousemove: C }, [Q("tbody", { ref_key: "tbodyRef", ref: u }, [(k(!0), z(Qe, null, Et(i(m), (E, x) => (k(), z("tr", { key: x }, [(k(!0), z(Qe, null, Et(E, (I, L) => (k(), z("td", { key: L, ref_for: !0, ref: B => y(I) && (c.value = B), class: O(g(I)), "aria-selected": `${y(I)}`, "aria-label": i(l)(`el.datepicker.month${+I.text + 1}`), tabindex: y(I) ? 0 : -1, onKeydown: [Mt(st(b, ["prevent", "stop"]), ["space"]), Mt(st(b, ["prevent", "stop"]), ["enter"])] }, [Q("div", null, [Q("span", dK, Be(i(l)("el.datepicker.months." + d.value[I.text])), 1)])], 42, cK))), 128))]))), 128))], 512)], 42, uK)); } });
var Kf = Fe(fK, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-month-table.vue"]]);
const { date: pK, disabledDate: hK, parsedValue: vK } = Dh, mK = Ve({ date: pK, disabledDate: hK, parsedValue: vK }), gK = ["aria-label"], yK = ["aria-selected", "tabindex", "onKeydown"], bK = { class: "cell" }, wK = { key: 1 }, CK = ae({ __name: "basic-year-table", props: mK, emits: ["pick"], setup(e, { expose: t, emit: n }) { const o = e, r = (h, g) => { const y = pt(String(h)).locale(g).startOf("year"), b = y.endOf("year").dayOfYear(); return Gr(b).map(w => y.add(w, "day").toDate()); }, s = Ie("year-table"), { t: l, lang: a } = Nt(), u = M(), c = M(), d = S(() => Math.floor(o.date.year() / 10) * 10), f = () => { var h; (h = c.value) == null || h.focus(); }, p = h => { const g = {}, y = pt().locale(a.value); return g.disabled = o.disabledDate ? r(h, a.value).every(o.disabledDate) : !1, g.current = yr(o.parsedValue).findIndex(C => C.year() === h) >= 0, g.today = y.year() === h, g; }, v = h => h === d.value && o.date.year() < d.value && o.date.year() > d.value + 9 || yr(o.date).findIndex(g => g.year() === h) >= 0, m = h => { const y = h.target.closest("td"); if (y && y.textContent) {
        if (Vo(y, "disabled"))
            return;
        const C = y.textContent || y.innerText;
        n("pick", Number(C));
    } }; return Oe(() => o.date, async () => { var h, g; (h = u.value) != null && h.contains(document.activeElement) && (await Xe(), (g = c.value) == null || g.focus()); }), t({ focus: f }), (h, g) => (k(), z("table", { role: "grid", "aria-label": i(l)("el.datepicker.yearTablePrompt"), class: O(i(s).b()), onClick: m }, [Q("tbody", { ref_key: "tbodyRef", ref: u }, [(k(), z(Qe, null, Et(3, (y, C) => Q("tr", { key: C }, [(k(), z(Qe, null, Et(4, (b, w) => (k(), z(Qe, { key: C + "_" + w }, [C * 4 + w < 10 ? (k(), z("td", { key: 0, ref_for: !0, ref: T => v(i(d) + C * 4 + w) && (c.value = T), class: O(["available", p(i(d) + C * 4 + w)]), "aria-selected": `${v(i(d) + C * 4 + w)}`, tabindex: v(i(d) + C * 4 + w) ? 0 : -1, onKeydown: [Mt(st(m, ["prevent", "stop"]), ["space"]), Mt(st(m, ["prevent", "stop"]), ["enter"])] }, [Q("span", bK, Be(i(d) + C * 4 + w), 1)], 42, yK)) : (k(), z("td", wK))], 64))), 64))])), 64))], 512)], 10, gK)); } });
var SK = Fe(CK, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-year-table.vue"]]);
const _K = ["onClick"], kK = ["aria-label"], EK = ["aria-label"], $K = ["aria-label"], TK = ["aria-label"], OK = ae({ __name: "panel-date-pick", props: ZH, emits: ["pick", "set-picker-option", "panel-change"], setup(e, { emit: t }) { const n = e, o = ($, Y, H) => !0, r = Ie("picker-panel"), s = Ie("date-picker"), l = js(), a = An(), { t: u, lang: c } = Nt(), d = Ye("EP_PICKER_BASE"), f = Ye(Kc), { shortcuts: p, disabledDate: v, cellClassName: m, defaultTime: h, arrowControl: g } = d.props, y = an(d.props, "defaultValue"), C = M(), b = M(pt().locale(c.value)), w = M(!1), T = S(() => pt(h).locale(c.value)), E = S(() => b.value.month()), x = S(() => b.value.year()), I = M([]), L = M(null), B = M(null), F = $ => I.value.length > 0 ? o($, I.value, n.format || "HH:mm:ss") : !0, V = $ => h && !q.value && !w.value ? T.value.year($.year()).month($.month()).date($.date()) : me.value ? $.millisecond(0) : $.startOf("day"), R = ($, ...Y) => { if (!$)
        t("pick", $, ...Y);
    else if (qe($)) {
        const H = $.map(V);
        t("pick", H, ...Y);
    }
    else
        t("pick", V($), ...Y); L.value = null, B.value = null, w.value = !1; }, K = ($, Y) => { if (G.value === "date") {
        $ = $;
        let H = n.parsedValue ? n.parsedValue.year($.year()).month($.month()).date($.date()) : $;
        F(H) || (H = I.value[0][0].year($.year()).month($.month()).date($.date())), b.value = H, R(H, me.value || Y);
    }
    else
        G.value === "week" ? R($.date) : G.value === "dates" && R($, !0); }, te = $ => { const Y = $ ? "add" : "subtract"; b.value = b.value[Y](1, "month"), X("month"); }, U = $ => { const Y = b.value, H = $ ? "add" : "subtract"; b.value = D.value === "year" ? Y[H](10, "year") : Y[H](1, "year"), X("year"); }, D = M("date"), j = S(() => { const $ = u("el.datepicker.year"); if (D.value === "year") {
        const Y = Math.floor(x.value / 10) * 10;
        return $ ? `${Y} ${$} - ${Y + 9} ${$}` : `${Y} - ${Y + 9}`;
    } return `${x.value} ${$}`; }), A = $ => { const Y = at($.value) ? $.value() : $.value; if (Y) {
        R(pt(Y).locale(c.value));
        return;
    } $.onClick && $.onClick({ attrs: l, slots: a, emit: t }); }, G = S(() => { const { type: $ } = n; return ["week", "month", "year", "dates"].includes($) ? $ : "date"; }), se = S(() => G.value === "date" ? D.value : G.value), Z = S(() => !!p.length), ce = async ($) => { b.value = b.value.startOf("month").month($), G.value === "month" ? R(b.value, !1) : (D.value = "date", ["month", "year", "date", "week"].includes(G.value) && (R(b.value, !0), await Xe(), Te())), X("month"); }, ye = async ($) => { G.value === "year" ? (b.value = b.value.startOf("year").year($), R(b.value, !1)) : (b.value = b.value.year($), D.value = "month", ["month", "year", "date", "week"].includes(G.value) && (R(b.value, !0), await Xe(), Te())), X("year"); }, Re = async ($) => { D.value = $, await Xe(), Te(); }, me = S(() => n.type === "datetime" || n.type === "datetimerange"), le = S(() => me.value || G.value === "dates"), oe = () => { if (G.value === "dates")
        R(n.parsedValue);
    else {
        let $ = n.parsedValue;
        if (!$) {
            const Y = pt(h).locale(c.value), H = Ue();
            $ = Y.year(H.year()).month(H.month()).date(H.date());
        }
        b.value = $, R($);
    } }, fe = () => { const Y = pt().locale(c.value).toDate(); w.value = !0, (!v || !v(Y)) && F(Y) && (b.value = pt().locale(c.value), R(b.value)); }, Ce = S(() => Xw(n.format)), Ae = S(() => Gw(n.format)), q = S(() => { if (B.value)
        return B.value; if (!(!n.parsedValue && !y.value))
        return (n.parsedValue || b.value).format(Ce.value); }), re = S(() => { if (L.value)
        return L.value; if (!(!n.parsedValue && !y.value))
        return (n.parsedValue || b.value).format(Ae.value); }), he = M(!1), Ee = () => { he.value = !0; }, Ne = () => { he.value = !1; }, Se = $ => ({ hour: $.hour(), minute: $.minute(), second: $.second(), year: $.year(), month: $.month(), date: $.date() }), De = ($, Y, H) => { const { hour: ue, minute: de, second: be } = Se($), J = n.parsedValue ? n.parsedValue.hour(ue).minute(de).second(be) : $; b.value = J, R(b.value, !0), H || (he.value = Y); }, Me = $ => { const Y = pt($, Ce.value).locale(c.value); if (Y.isValid() && F(Y)) {
        const { year: H, month: ue, date: de } = Se(b.value);
        b.value = Y.year(H).month(ue).date(de), B.value = null, he.value = !1, R(b.value, !0);
    } }, $e = $ => { const Y = pt($, Ae.value).locale(c.value); if (Y.isValid()) {
        if (v && v(Y.toDate()))
            return;
        const { hour: H, minute: ue, second: de } = Se(b.value);
        b.value = Y.hour(H).minute(ue).second(de), L.value = null, R(b.value, !0);
    } }, Pe = $ => pt.isDayjs($) && $.isValid() && (v ? !v($.toDate()) : !0), He = $ => G.value === "dates" ? $.map(Y => Y.format(n.format)) : $.format(n.format), je = $ => pt($, n.format).locale(c.value), Ue = () => { const $ = pt(y.value).locale(c.value); if (!y.value) {
        const Y = T.value;
        return pt().hour(Y.hour()).minute(Y.minute()).second(Y.second()).locale(c.value);
    } return $; }, Te = async () => { var $; ["week", "month", "year", "date"].includes(G.value) && (($ = C.value) == null || $.focus(), G.value === "week" && W(tt.down)); }, Ge = $ => { const { code: Y } = $; [tt.up, tt.down, tt.left, tt.right, tt.home, tt.end, tt.pageUp, tt.pageDown].includes(Y) && (W(Y), $.stopPropagation(), $.preventDefault()), [tt.enter, tt.space, tt.numpadEnter].includes(Y) && L.value === null && B.value === null && ($.preventDefault(), R(b.value, !1)); }, W = $ => { var Y; const { up: H, down: ue, left: de, right: be, home: J, end: we, pageUp: Ke, pageDown: rt } = tt, _e = { year: { [H]: -4, [ue]: 4, [de]: -1, [be]: 1, offset: (We, ut) => We.setFullYear(We.getFullYear() + ut) }, month: { [H]: -4, [ue]: 4, [de]: -1, [be]: 1, offset: (We, ut) => We.setMonth(We.getMonth() + ut) }, week: { [H]: -1, [ue]: 1, [de]: -1, [be]: 1, offset: (We, ut) => We.setDate(We.getDate() + ut * 7) }, date: { [H]: -7, [ue]: 7, [de]: -1, [be]: 1, [J]: We => -We.getDay(), [we]: We => -We.getDay() + 6, [Ke]: We => -new Date(We.getFullYear(), We.getMonth(), 0).getDate(), [rt]: We => new Date(We.getFullYear(), We.getMonth() + 1, 0).getDate(), offset: (We, ut) => We.setDate(We.getDate() + ut) } }, ze = b.value.toDate(); for (; Math.abs(b.value.diff(ze, "year", !0)) < 1;) {
        const We = _e[se.value];
        if (!We)
            return;
        if (We.offset(ze, at(We[$]) ? We[$](ze) : (Y = We[$]) != null ? Y : 0), v && v(ze))
            break;
        const ut = pt(ze).locale(c.value);
        b.value = ut, t("pick", ut, !0);
        break;
    } }, X = $ => { t("panel-change", b.value.toDate(), $, D.value); }; return Oe(() => G.value, $ => { if (["month", "year"].includes($)) {
        D.value = $;
        return;
    } D.value = "date"; }, { immediate: !0 }), Oe(() => D.value, () => { f == null || f.updatePopper(); }), Oe(() => y.value, $ => { $ && (b.value = Ue()); }, { immediate: !0 }), Oe(() => n.parsedValue, $ => { if ($) {
        if (G.value === "dates" || Array.isArray($))
            return;
        b.value = $;
    }
    else
        b.value = Ue(); }, { immediate: !0 }), t("set-picker-option", ["isValidValue", Pe]), t("set-picker-option", ["formatToString", He]), t("set-picker-option", ["parseUserInput", je]), t("set-picker-option", ["handleFocusPicker", Te]), ($, Y) => (k(), z("div", { class: O([i(r).b(), i(s).b(), { "has-sidebar": $.$slots.sidebar || i(Z), "has-time": i(me) }]) }, [Q("div", { class: O(i(r).e("body-wrapper")) }, [ke($.$slots, "sidebar", { class: O(i(r).e("sidebar")) }), i(Z) ? (k(), z("div", { key: 0, class: O(i(r).e("sidebar")) }, [(k(!0), z(Qe, null, Et(i(p), (H, ue) => (k(), z("button", { key: ue, type: "button", class: O(i(r).e("shortcut")), onClick: de => A(H) }, Be(H.text), 11, _K))), 128))], 2)) : pe("v-if", !0), Q("div", { class: O(i(r).e("body")) }, [i(me) ? (k(), z("div", { key: 0, class: O(i(s).e("time-header")) }, [Q("span", { class: O(i(s).e("editor-wrap")) }, [ee(i(Ln), { placeholder: i(u)("el.datepicker.selectDate"), "model-value": i(re), size: "small", "validate-event": !1, onInput: Y[0] || (Y[0] = H => L.value = H), onChange: $e }, null, 8, ["placeholder", "model-value"])], 2), dt((k(), z("span", { class: O(i(s).e("editor-wrap")) }, [ee(i(Ln), { placeholder: i(u)("el.datepicker.selectTime"), "model-value": i(q), size: "small", "validate-event": !1, onFocus: Ee, onInput: Y[1] || (Y[1] = H => B.value = H), onChange: Me }, null, 8, ["placeholder", "model-value"]), ee(i(Gu), { visible: he.value, format: i(Ce), "time-arrow-control": i(g), "parsed-value": b.value, onPick: De }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])], 2)), [[i(ns), Ne]])], 2)) : pe("v-if", !0), dt(Q("div", { class: O([i(s).e("header"), (D.value === "year" || D.value === "month") && i(s).e("header--bordered")]) }, [Q("span", { class: O(i(s).e("prev-btn")) }, [Q("button", { type: "button", "aria-label": i(u)("el.datepicker.prevYear"), class: O(["d-arrow-left", i(r).e("icon-btn")]), onClick: Y[2] || (Y[2] = H => U(!1)) }, [ee(i(Je), null, { default: ie(() => [ee(i(Al))]), _: 1 })], 10, kK), dt(Q("button", { type: "button", "aria-label": i(u)("el.datepicker.prevMonth"), class: O([i(r).e("icon-btn"), "arrow-left"]), onClick: Y[3] || (Y[3] = H => te(!1)) }, [ee(i(Je), null, { default: ie(() => [ee(i(Zr))]), _: 1 })], 10, EK), [[Pt, D.value === "date"]])], 2), Q("span", { role: "button", class: O(i(s).e("header-label")), "aria-live": "polite", tabindex: "0", onKeydown: Y[4] || (Y[4] = Mt(H => Re("year"), ["enter"])), onClick: Y[5] || (Y[5] = H => Re("year")) }, Be(i(j)), 35), dt(Q("span", { role: "button", "aria-live": "polite", tabindex: "0", class: O([i(s).e("header-label"), { active: D.value === "month" }]), onKeydown: Y[6] || (Y[6] = Mt(H => Re("month"), ["enter"])), onClick: Y[7] || (Y[7] = H => Re("month")) }, Be(i(u)(`el.datepicker.month${i(E) + 1}`)), 35), [[Pt, D.value === "date"]]), Q("span", { class: O(i(s).e("next-btn")) }, [dt(Q("button", { type: "button", "aria-label": i(u)("el.datepicker.nextMonth"), class: O([i(r).e("icon-btn"), "arrow-right"]), onClick: Y[8] || (Y[8] = H => te(!0)) }, [ee(i(Je), null, { default: ie(() => [ee(i(Un))]), _: 1 })], 10, $K), [[Pt, D.value === "date"]]), Q("button", { type: "button", "aria-label": i(u)("el.datepicker.nextYear"), class: O([i(r).e("icon-btn"), "d-arrow-right"]), onClick: Y[9] || (Y[9] = H => U(!0)) }, [ee(i(Je), null, { default: ie(() => [ee(i(Ml))]), _: 1 })], 10, TK)], 2)], 2), [[Pt, D.value !== "time"]]), Q("div", { class: O(i(r).e("content")), onKeydown: Ge }, [D.value === "date" ? (k(), ge(Hf, { key: 0, ref_key: "currentViewRef", ref: C, "selection-mode": i(G), date: b.value, "parsed-value": $.parsedValue, "disabled-date": i(v), "cell-class-name": i(m), onPick: K }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "cell-class-name"])) : pe("v-if", !0), D.value === "year" ? (k(), ge(SK, { key: 1, ref_key: "currentViewRef", ref: C, date: b.value, "disabled-date": i(v), "parsed-value": $.parsedValue, onPick: ye }, null, 8, ["date", "disabled-date", "parsed-value"])) : pe("v-if", !0), D.value === "month" ? (k(), ge(Kf, { key: 2, ref_key: "currentViewRef", ref: C, date: b.value, "parsed-value": $.parsedValue, "disabled-date": i(v), onPick: ce }, null, 8, ["date", "parsed-value", "disabled-date"])) : pe("v-if", !0)], 34)], 2)], 2), dt(Q("div", { class: O(i(r).e("footer")) }, [dt(ee(i(xn), { text: "", size: "small", class: O(i(r).e("link-btn")), onClick: fe }, { default: ie(() => [Ot(Be(i(u)("el.datepicker.now")), 1)]), _: 1 }, 8, ["class"]), [[Pt, i(G) !== "dates"]]), ee(i(xn), { plain: "", size: "small", class: O(i(r).e("link-btn")), onClick: oe }, { default: ie(() => [Ot(Be(i(u)("el.datepicker.confirm")), 1)]), _: 1 }, 8, ["class"])], 2), [[Pt, i(le) && D.value === "date"]])], 2)); } });
var IK = Fe(OK, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-pick.vue"]]);
const xK = Ve({ ...jC, ...WC }), AK = e => { const { emit: t } = ht(), n = js(), o = An(); return s => { const l = at(s.value) ? s.value() : s.value; if (l) {
    t("pick", [pt(l[0]).locale(e.value), pt(l[1]).locale(e.value)]);
    return;
} s.onClick && s.onClick({ attrs: n, slots: o, emit: t }); }; }, YC = (e, { defaultValue: t, leftDate: n, rightDate: o, unit: r, onParsedValueChanged: s }) => { const { emit: l } = ht(), { pickerNs: a } = Ye(Lh), u = Ie("date-range-picker"), { t: c, lang: d } = Nt(), f = AK(d), p = M(), v = M(), m = M({ endDate: null, selecting: !1 }), h = b => { m.value = b; }, g = (b = !1) => { const w = i(p), T = i(v); zf([w, T]) && l("pick", [w, T], b); }, y = b => { m.value.selecting = b, b || (m.value.endDate = null); }, C = () => { const [b, w] = qC(i(t), { lang: i(d), unit: r, unlinkPanels: e.unlinkPanels }); p.value = void 0, v.value = void 0, n.value = b, o.value = w; }; return Oe(t, b => { b && C(); }, { immediate: !0 }), Oe(() => e.parsedValue, b => { if (qe(b) && b.length === 2) {
    const [w, T] = b;
    p.value = w, n.value = w, v.value = T, s(i(p), i(v));
}
else
    C(); }, { immediate: !0 }), { minDate: p, maxDate: v, rangeState: m, lang: d, ppNs: a, drpNs: u, handleChangeRange: h, handleRangeConfirm: g, handleShortcutClick: f, onSelect: y, t: c }; }, MK = ["onClick"], NK = ["disabled"], PK = ["disabled"], RK = ["disabled"], LK = ["disabled"], Zi = "month", DK = ae({ __name: "panel-date-range", props: xK, emits: ["pick", "set-picker-option", "calendar-change", "panel-change"], setup(e, { emit: t }) { const n = e, o = Ye("EP_PICKER_BASE"), { disabledDate: r, cellClassName: s, format: l, defaultTime: a, arrowControl: u, clearable: c } = o.props, d = an(o.props, "shortcuts"), f = an(o.props, "defaultValue"), { lang: p } = Nt(), v = M(pt().locale(p.value)), m = M(pt().locale(p.value).add(1, Zi)), { minDate: h, maxDate: g, rangeState: y, ppNs: C, drpNs: b, handleChangeRange: w, handleRangeConfirm: T, handleShortcutClick: E, onSelect: x, t: I } = YC(n, { defaultValue: f, leftDate: v, rightDate: m, unit: Zi, onParsedValueChanged: ue }), L = M({ min: null, max: null }), B = M({ min: null, max: null }), F = S(() => `${v.value.year()} ${I("el.datepicker.year")} ${I(`el.datepicker.month${v.value.month() + 1}`)}`), V = S(() => `${m.value.year()} ${I("el.datepicker.year")} ${I(`el.datepicker.month${m.value.month() + 1}`)}`), R = S(() => v.value.year()), K = S(() => v.value.month()), te = S(() => m.value.year()), U = S(() => m.value.month()), D = S(() => !!d.value.length), j = S(() => L.value.min !== null ? L.value.min : h.value ? h.value.format(ce.value) : ""), A = S(() => L.value.max !== null ? L.value.max : g.value || h.value ? (g.value || h.value).format(ce.value) : ""), G = S(() => B.value.min !== null ? B.value.min : h.value ? h.value.format(Z.value) : ""), se = S(() => B.value.max !== null ? B.value.max : g.value || h.value ? (g.value || h.value).format(Z.value) : ""), Z = S(() => Xw(l)), ce = S(() => Gw(l)), ye = () => { v.value = v.value.subtract(1, "year"), n.unlinkPanels || (m.value = v.value.add(1, "month")), q("year"); }, Re = () => { v.value = v.value.subtract(1, "month"), n.unlinkPanels || (m.value = v.value.add(1, "month")), q("month"); }, me = () => { n.unlinkPanels ? m.value = m.value.add(1, "year") : (v.value = v.value.add(1, "year"), m.value = v.value.add(1, "month")), q("year"); }, le = () => { n.unlinkPanels ? m.value = m.value.add(1, "month") : (v.value = v.value.add(1, "month"), m.value = v.value.add(1, "month")), q("month"); }, oe = () => { v.value = v.value.add(1, "year"), q("year"); }, fe = () => { v.value = v.value.add(1, "month"), q("month"); }, Ce = () => { m.value = m.value.subtract(1, "year"), q("year"); }, Ae = () => { m.value = m.value.subtract(1, "month"), q("month"); }, q = de => { t("panel-change", [v.value.toDate(), m.value.toDate()], de); }, re = S(() => { const de = (K.value + 1) % 12, be = K.value + 1 >= 12 ? 1 : 0; return n.unlinkPanels && new Date(R.value + be, de) < new Date(te.value, U.value); }), he = S(() => n.unlinkPanels && te.value * 12 + U.value - (R.value * 12 + K.value + 1) >= 12), Ee = S(() => !(h.value && g.value && !y.value.selecting && zf([h.value, g.value]))), Ne = S(() => n.type === "datetime" || n.type === "datetimerange"), Se = (de, be) => { if (de)
        return a ? pt(a[be] || a).locale(p.value).year(de.year()).month(de.month()).date(de.date()) : de; }, De = (de, be = !0) => { const J = de.minDate, we = de.maxDate, Ke = Se(J, 0), rt = Se(we, 1); g.value === rt && h.value === Ke || (t("calendar-change", [J.toDate(), we && we.toDate()]), g.value = rt, h.value = Ke, !(!be || Ne.value) && T()); }, Me = M(!1), $e = M(!1), Pe = () => { Me.value = !1; }, He = () => { $e.value = !1; }, je = (de, be) => { L.value[be] = de; const J = pt(de, ce.value).locale(p.value); if (J.isValid()) {
        if (r && r(J.toDate()))
            return;
        be === "min" ? (v.value = J, h.value = (h.value || v.value).year(J.year()).month(J.month()).date(J.date()), !n.unlinkPanels && (!g.value || g.value.isBefore(h.value)) && (m.value = J.add(1, "month"), g.value = h.value.add(1, "month"))) : (m.value = J, g.value = (g.value || m.value).year(J.year()).month(J.month()).date(J.date()), !n.unlinkPanels && (!h.value || h.value.isAfter(g.value)) && (v.value = J.subtract(1, "month"), h.value = g.value.subtract(1, "month")));
    } }, Ue = (de, be) => { L.value[be] = null; }, Te = (de, be) => { B.value[be] = de; const J = pt(de, Z.value).locale(p.value); J.isValid() && (be === "min" ? (Me.value = !0, h.value = (h.value || v.value).hour(J.hour()).minute(J.minute()).second(J.second()), (!g.value || g.value.isBefore(h.value)) && (g.value = h.value)) : ($e.value = !0, g.value = (g.value || m.value).hour(J.hour()).minute(J.minute()).second(J.second()), m.value = g.value, g.value && g.value.isBefore(h.value) && (h.value = g.value))); }, Ge = (de, be) => { B.value[be] = null, be === "min" ? (v.value = h.value, Me.value = !1) : (m.value = g.value, $e.value = !1); }, W = (de, be, J) => { B.value.min || (de && (v.value = de, h.value = (h.value || v.value).hour(de.hour()).minute(de.minute()).second(de.second())), J || (Me.value = be), (!g.value || g.value.isBefore(h.value)) && (g.value = h.value, m.value = de)); }, X = (de, be, J) => { B.value.max || (de && (m.value = de, g.value = (g.value || m.value).hour(de.hour()).minute(de.minute()).second(de.second())), J || ($e.value = be), g.value && g.value.isBefore(h.value) && (h.value = g.value)); }, $ = () => { v.value = qC(i(f), { lang: i(p), unit: "month", unlinkPanels: n.unlinkPanels })[0], m.value = v.value.add(1, "month"), t("pick", null); }, Y = de => qe(de) ? de.map(be => be.format(l)) : de.format(l), H = de => qe(de) ? de.map(be => pt(be, l).locale(p.value)) : pt(de, l).locale(p.value); function ue(de, be) { if (n.unlinkPanels && be) {
        const J = (de == null ? void 0 : de.year()) || 0, we = (de == null ? void 0 : de.month()) || 0, Ke = be.year(), rt = be.month();
        m.value = J === Ke && we === rt ? be.add(1, Zi) : be;
    }
    else
        m.value = v.value.add(1, Zi), be && (m.value = m.value.hour(be.hour()).minute(be.minute()).second(be.second())); } return t("set-picker-option", ["isValidValue", zf]), t("set-picker-option", ["parseUserInput", H]), t("set-picker-option", ["formatToString", Y]), t("set-picker-option", ["handleClear", $]), (de, be) => (k(), z("div", { class: O([i(C).b(), i(b).b(), { "has-sidebar": de.$slots.sidebar || i(D), "has-time": i(Ne) }]) }, [Q("div", { class: O(i(C).e("body-wrapper")) }, [ke(de.$slots, "sidebar", { class: O(i(C).e("sidebar")) }), i(D) ? (k(), z("div", { key: 0, class: O(i(C).e("sidebar")) }, [(k(!0), z(Qe, null, Et(i(d), (J, we) => (k(), z("button", { key: we, type: "button", class: O(i(C).e("shortcut")), onClick: Ke => i(E)(J) }, Be(J.text), 11, MK))), 128))], 2)) : pe("v-if", !0), Q("div", { class: O(i(C).e("body")) }, [i(Ne) ? (k(), z("div", { key: 0, class: O(i(b).e("time-header")) }, [Q("span", { class: O(i(b).e("editors-wrap")) }, [Q("span", { class: O(i(b).e("time-picker-wrap")) }, [ee(i(Ln), { size: "small", disabled: i(y).selecting, placeholder: i(I)("el.datepicker.startDate"), class: O(i(b).e("editor")), "model-value": i(j), "validate-event": !1, onInput: be[0] || (be[0] = J => je(J, "min")), onChange: be[1] || (be[1] = J => Ue(J, "min")) }, null, 8, ["disabled", "placeholder", "class", "model-value"])], 2), dt((k(), z("span", { class: O(i(b).e("time-picker-wrap")) }, [ee(i(Ln), { size: "small", class: O(i(b).e("editor")), disabled: i(y).selecting, placeholder: i(I)("el.datepicker.startTime"), "model-value": i(G), "validate-event": !1, onFocus: be[2] || (be[2] = J => Me.value = !0), onInput: be[3] || (be[3] = J => Te(J, "min")), onChange: be[4] || (be[4] = J => Ge(J, "min")) }, null, 8, ["class", "disabled", "placeholder", "model-value"]), ee(i(Gu), { visible: Me.value, format: i(Z), "datetime-role": "start", "time-arrow-control": i(u), "parsed-value": v.value, onPick: W }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])], 2)), [[i(ns), Pe]])], 2), Q("span", null, [ee(i(Je), null, { default: ie(() => [ee(i(Un))]), _: 1 })]), Q("span", { class: O([i(b).e("editors-wrap"), "is-right"]) }, [Q("span", { class: O(i(b).e("time-picker-wrap")) }, [ee(i(Ln), { size: "small", class: O(i(b).e("editor")), disabled: i(y).selecting, placeholder: i(I)("el.datepicker.endDate"), "model-value": i(A), readonly: !i(h), "validate-event": !1, onInput: be[5] || (be[5] = J => je(J, "max")), onChange: be[6] || (be[6] = J => Ue(J, "max")) }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"])], 2), dt((k(), z("span", { class: O(i(b).e("time-picker-wrap")) }, [ee(i(Ln), { size: "small", class: O(i(b).e("editor")), disabled: i(y).selecting, placeholder: i(I)("el.datepicker.endTime"), "model-value": i(se), readonly: !i(h), "validate-event": !1, onFocus: be[7] || (be[7] = J => i(h) && ($e.value = !0)), onInput: be[8] || (be[8] = J => Te(J, "max")), onChange: be[9] || (be[9] = J => Ge(J, "max")) }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"]), ee(i(Gu), { "datetime-role": "end", visible: $e.value, format: i(Z), "time-arrow-control": i(u), "parsed-value": m.value, onPick: X }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])], 2)), [[i(ns), He]])], 2)], 2)) : pe("v-if", !0), Q("div", { class: O([[i(C).e("content"), i(b).e("content")], "is-left"]) }, [Q("div", { class: O(i(b).e("header")) }, [Q("button", { type: "button", class: O([i(C).e("icon-btn"), "d-arrow-left"]), onClick: ye }, [ee(i(Je), null, { default: ie(() => [ee(i(Al))]), _: 1 })], 2), Q("button", { type: "button", class: O([i(C).e("icon-btn"), "arrow-left"]), onClick: Re }, [ee(i(Je), null, { default: ie(() => [ee(i(Zr))]), _: 1 })], 2), de.unlinkPanels ? (k(), z("button", { key: 0, type: "button", disabled: !i(he), class: O([[i(C).e("icon-btn"), { "is-disabled": !i(he) }], "d-arrow-right"]), onClick: oe }, [ee(i(Je), null, { default: ie(() => [ee(i(Ml))]), _: 1 })], 10, NK)) : pe("v-if", !0), de.unlinkPanels ? (k(), z("button", { key: 1, type: "button", disabled: !i(re), class: O([[i(C).e("icon-btn"), { "is-disabled": !i(re) }], "arrow-right"]), onClick: fe }, [ee(i(Je), null, { default: ie(() => [ee(i(Un))]), _: 1 })], 10, PK)) : pe("v-if", !0), Q("div", null, Be(i(F)), 1)], 2), ee(Hf, { "selection-mode": "range", date: v.value, "min-date": i(h), "max-date": i(g), "range-state": i(y), "disabled-date": i(r), "cell-class-name": i(s), onChangerange: i(w), onPick: De, onSelect: i(x) }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])], 2), Q("div", { class: O([[i(C).e("content"), i(b).e("content")], "is-right"]) }, [Q("div", { class: O(i(b).e("header")) }, [de.unlinkPanels ? (k(), z("button", { key: 0, type: "button", disabled: !i(he), class: O([[i(C).e("icon-btn"), { "is-disabled": !i(he) }], "d-arrow-left"]), onClick: Ce }, [ee(i(Je), null, { default: ie(() => [ee(i(Al))]), _: 1 })], 10, RK)) : pe("v-if", !0), de.unlinkPanels ? (k(), z("button", { key: 1, type: "button", disabled: !i(re), class: O([[i(C).e("icon-btn"), { "is-disabled": !i(re) }], "arrow-left"]), onClick: Ae }, [ee(i(Je), null, { default: ie(() => [ee(i(Zr))]), _: 1 })], 10, LK)) : pe("v-if", !0), Q("button", { type: "button", class: O([i(C).e("icon-btn"), "d-arrow-right"]), onClick: me }, [ee(i(Je), null, { default: ie(() => [ee(i(Ml))]), _: 1 })], 2), Q("button", { type: "button", class: O([i(C).e("icon-btn"), "arrow-right"]), onClick: le }, [ee(i(Je), null, { default: ie(() => [ee(i(Un))]), _: 1 })], 2), Q("div", null, Be(i(V)), 1)], 2), ee(Hf, { "selection-mode": "range", date: m.value, "min-date": i(h), "max-date": i(g), "range-state": i(y), "disabled-date": i(r), "cell-class-name": i(s), onChangerange: i(w), onPick: De, onSelect: i(x) }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])], 2)], 2)], 2), i(Ne) ? (k(), z("div", { key: 0, class: O(i(C).e("footer")) }, [i(c) ? (k(), ge(i(xn), { key: 0, text: "", size: "small", class: O(i(C).e("link-btn")), onClick: $ }, { default: ie(() => [Ot(Be(i(I)("el.datepicker.clear")), 1)]), _: 1 }, 8, ["class"])) : pe("v-if", !0), ee(i(xn), { plain: "", size: "small", class: O(i(C).e("link-btn")), disabled: i(Ee), onClick: be[10] || (be[10] = J => i(T)(!1)) }, { default: ie(() => [Ot(Be(i(I)("el.datepicker.confirm")), 1)]), _: 1 }, 8, ["class", "disabled"])], 2)) : pe("v-if", !0)], 2)); } });
var BK = Fe(DK, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-range.vue"]]);
const FK = Ve({ ...WC }), VK = ["pick", "set-picker-option"], zK = ({ unlinkPanels: e, leftDate: t, rightDate: n }) => { const { t: o } = Nt(), r = () => { t.value = t.value.subtract(1, "year"), e.value || (n.value = n.value.subtract(1, "year")); }, s = () => { e.value || (t.value = t.value.add(1, "year")), n.value = n.value.add(1, "year"); }, l = () => { t.value = t.value.add(1, "year"); }, a = () => { n.value = n.value.subtract(1, "year"); }, u = S(() => `${t.value.year()} ${o("el.datepicker.year")}`), c = S(() => `${n.value.year()} ${o("el.datepicker.year")}`), d = S(() => t.value.year()), f = S(() => n.value.year() === t.value.year() ? t.value.year() + 1 : n.value.year()); return { leftPrevYear: r, rightNextYear: s, leftNextYear: l, rightPrevYear: a, leftLabel: u, rightLabel: c, leftYear: d, rightYear: f }; }, HK = ["onClick"], KK = ["disabled"], jK = ["disabled"], Qi = "year", WK = ae({ name: "DatePickerMonthRange" }), UK = ae({ ...WK, props: FK, emits: VK, setup(e, { emit: t }) { const n = e, { lang: o } = Nt(), r = Ye("EP_PICKER_BASE"), { shortcuts: s, disabledDate: l, format: a } = r.props, u = an(r.props, "defaultValue"), c = M(pt().locale(o.value)), d = M(pt().locale(o.value).add(1, Qi)), { minDate: f, maxDate: p, rangeState: v, ppNs: m, drpNs: h, handleChangeRange: g, handleRangeConfirm: y, handleShortcutClick: C, onSelect: b } = YC(n, { defaultValue: u, leftDate: c, rightDate: d, unit: Qi, onParsedValueChanged: U }), w = S(() => !!s.length), { leftPrevYear: T, rightNextYear: E, leftNextYear: x, rightPrevYear: I, leftLabel: L, rightLabel: B, leftYear: F, rightYear: V } = zK({ unlinkPanels: an(n, "unlinkPanels"), leftDate: c, rightDate: d }), R = S(() => n.unlinkPanels && V.value > F.value + 1), K = (D, j = !0) => { const A = D.minDate, G = D.maxDate; p.value === G && f.value === A || (p.value = G, f.value = A, j && y()); }, te = D => D.map(j => j.format(a)); function U(D, j) { if (n.unlinkPanels && j) {
        const A = (D == null ? void 0 : D.year()) || 0, G = j.year();
        d.value = A === G ? j.add(1, Qi) : j;
    }
    else
        d.value = c.value.add(1, Qi); } return t("set-picker-option", ["formatToString", te]), (D, j) => (k(), z("div", { class: O([i(m).b(), i(h).b(), { "has-sidebar": !!D.$slots.sidebar || i(w) }]) }, [Q("div", { class: O(i(m).e("body-wrapper")) }, [ke(D.$slots, "sidebar", { class: O(i(m).e("sidebar")) }), i(w) ? (k(), z("div", { key: 0, class: O(i(m).e("sidebar")) }, [(k(!0), z(Qe, null, Et(i(s), (A, G) => (k(), z("button", { key: G, type: "button", class: O(i(m).e("shortcut")), onClick: se => i(C)(A) }, Be(A.text), 11, HK))), 128))], 2)) : pe("v-if", !0), Q("div", { class: O(i(m).e("body")) }, [Q("div", { class: O([[i(m).e("content"), i(h).e("content")], "is-left"]) }, [Q("div", { class: O(i(h).e("header")) }, [Q("button", { type: "button", class: O([i(m).e("icon-btn"), "d-arrow-left"]), onClick: j[0] || (j[0] = (...A) => i(T) && i(T)(...A)) }, [ee(i(Je), null, { default: ie(() => [ee(i(Al))]), _: 1 })], 2), D.unlinkPanels ? (k(), z("button", { key: 0, type: "button", disabled: !i(R), class: O([[i(m).e("icon-btn"), { [i(m).is("disabled")]: !i(R) }], "d-arrow-right"]), onClick: j[1] || (j[1] = (...A) => i(x) && i(x)(...A)) }, [ee(i(Je), null, { default: ie(() => [ee(i(Ml))]), _: 1 })], 10, KK)) : pe("v-if", !0), Q("div", null, Be(i(L)), 1)], 2), ee(Kf, { "selection-mode": "range", date: c.value, "min-date": i(f), "max-date": i(p), "range-state": i(v), "disabled-date": i(l), onChangerange: i(g), onPick: K, onSelect: i(b) }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])], 2), Q("div", { class: O([[i(m).e("content"), i(h).e("content")], "is-right"]) }, [Q("div", { class: O(i(h).e("header")) }, [D.unlinkPanels ? (k(), z("button", { key: 0, type: "button", disabled: !i(R), class: O([[i(m).e("icon-btn"), { "is-disabled": !i(R) }], "d-arrow-left"]), onClick: j[2] || (j[2] = (...A) => i(I) && i(I)(...A)) }, [ee(i(Je), null, { default: ie(() => [ee(i(Al))]), _: 1 })], 10, jK)) : pe("v-if", !0), Q("button", { type: "button", class: O([i(m).e("icon-btn"), "d-arrow-right"]), onClick: j[3] || (j[3] = (...A) => i(E) && i(E)(...A)) }, [ee(i(Je), null, { default: ie(() => [ee(i(Ml))]), _: 1 })], 2), Q("div", null, Be(i(B)), 1)], 2), ee(Kf, { "selection-mode": "range", date: d.value, "min-date": i(f), "max-date": i(p), "range-state": i(v), "disabled-date": i(l), onChangerange: i(g), onPick: K, onSelect: i(b) }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])], 2)], 2)], 2)], 2)); } });
var qK = Fe(UK, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-month-range.vue"]]);
const YK = function (e) { switch (e) {
    case "daterange":
    case "datetimerange": return BK;
    case "monthrange": return qK;
    default: return IK;
} };
pt.extend(fC);
pt.extend(FH);
pt.extend(Mh);
pt.extend(zH);
pt.extend(KH);
pt.extend(WH);
pt.extend(qH);
pt.extend(GH);
var GK = ae({ name: "ElDatePicker", install: null, props: XH, emits: ["update:modelValue"], setup(e, { expose: t, emit: n, slots: o }) { const r = Ie("picker-panel"); St("ElPopperOptions", Lt(an(e, "popperOptions"))), St(Lh, { slots: o, pickerNs: r }); const s = M(); t({ focus: (u = !0) => { var c; (c = s.value) == null || c.focus(u); }, handleOpen: () => { var u; (u = s.value) == null || u.handleOpen(); }, handleClose: () => { var u; (u = s.value) == null || u.handleClose(); } }); const a = u => { n("update:modelValue", u); }; return () => { var u; const c = (u = e.format) != null ? u : PF[e.type] || rl, d = YK(e.type); return ee(Qw, Ct(e, { format: c, type: e.type, ref: s, "onUpdate:modelValue": a }), { default: f => ee(d, f, null), "range-separator": o["range-separator"] }); }; } });
const Cu = GK;
Cu.install = e => { e.component(Cu.name, Cu); };
const XK = Cu, Bh = Symbol("elDescriptions");
var ca = ae({ name: "ElDescriptionsCell", props: { cell: { type: Object }, tag: { type: String }, type: { type: String } }, setup() { return { descriptions: Ye(Bh, {}) }; }, render() { var e, t, n, o, r, s; const l = QR(this.cell), { border: a, direction: u } = this.descriptions, c = u === "vertical", d = ((n = (t = (e = this.cell) == null ? void 0 : e.children) == null ? void 0 : t.label) == null ? void 0 : n.call(t)) || l.label, f = (s = (r = (o = this.cell) == null ? void 0 : o.children) == null ? void 0 : r.default) == null ? void 0 : s.call(r), p = l.span, v = l.align ? `is-${l.align}` : "", m = l.labelAlign ? `is-${l.labelAlign}` : v, h = l.className, g = l.labelClassName, y = { width: gn(l.width), minWidth: gn(l.minWidth) }, C = Ie("descriptions"); switch (this.type) {
        case "label": return nt(this.tag, { style: y, class: [C.e("cell"), C.e("label"), C.is("bordered-label", a), C.is("vertical-label", c), m, g], colSpan: c ? p : 1 }, d);
        case "content": return nt(this.tag, { style: y, class: [C.e("cell"), C.e("content"), C.is("bordered-content", a), C.is("vertical-content", c), v, h], colSpan: c ? p : p * 2 - 1 }, f);
        default: return nt("td", { style: y, class: [C.e("cell"), v], colSpan: p }, [bn(d) ? void 0 : nt("span", { class: [C.e("label"), g] }, d), nt("span", { class: [C.e("content"), h] }, f)]);
    } } });
const JK = Ve({ row: { type: Array, default: () => [] } }), ZK = { key: 1 }, QK = ae({ name: "ElDescriptionsRow" }), e9 = ae({ ...QK, props: JK, setup(e) { const t = Ye(Bh, {}); return (n, o) => i(t).direction === "vertical" ? (k(), z(Qe, { key: 0 }, [Q("tr", null, [(k(!0), z(Qe, null, Et(n.row, (r, s) => (k(), ge(i(ca), { key: `tr1-${s}`, cell: r, tag: "th", type: "label" }, null, 8, ["cell"]))), 128))]), Q("tr", null, [(k(!0), z(Qe, null, Et(n.row, (r, s) => (k(), ge(i(ca), { key: `tr2-${s}`, cell: r, tag: "td", type: "content" }, null, 8, ["cell"]))), 128))])], 64)) : (k(), z("tr", ZK, [(k(!0), z(Qe, null, Et(n.row, (r, s) => (k(), z(Qe, { key: `tr3-${s}` }, [i(t).border ? (k(), z(Qe, { key: 0 }, [ee(i(ca), { cell: r, tag: "td", type: "label" }, null, 8, ["cell"]), ee(i(ca), { cell: r, tag: "td", type: "content" }, null, 8, ["cell"])], 64)) : (k(), ge(i(ca), { key: 1, cell: r, tag: "td", type: "both" }, null, 8, ["cell"]))], 64))), 128))])); } });
var t9 = Fe(e9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/descriptions-row.vue"]]);
const n9 = Ve({ border: { type: Boolean, default: !1 }, column: { type: Number, default: 3 }, direction: { type: String, values: ["horizontal", "vertical"], default: "horizontal" }, size: Bn, title: { type: String, default: "" }, extra: { type: String, default: "" } }), o9 = ae({ name: "ElDescriptions" }), r9 = ae({ ...o9, props: n9, setup(e) { const t = e, n = Ie("descriptions"), o = kn(), r = An(); St(Bh, t); const s = S(() => [n.b(), n.m(o.value)]), l = (u, c, d, f = !1) => (u.props || (u.props = {}), c > d && (u.props.span = d), f && (u.props.span = c), u), a = () => { var u; const c = ml((u = r.default) == null ? void 0 : u.call(r)).filter(m => { var h; return ((h = m == null ? void 0 : m.type) == null ? void 0 : h.name) === "ElDescriptionsItem"; }), d = []; let f = [], p = t.column, v = 0; return c.forEach((m, h) => { var g; const y = ((g = m.props) == null ? void 0 : g.span) || 1; if (h < c.length - 1 && (v += y > p ? p : y), h === c.length - 1) {
        const C = t.column - v % t.column;
        f.push(l(m, C, p, !0)), d.push(f);
        return;
    } y < p ? (p -= y, f.push(m)) : (f.push(l(m, y, p)), d.push(f), p = t.column, f = []); }), d; }; return (u, c) => (k(), z("div", { class: O(i(s)) }, [u.title || u.extra || u.$slots.title || u.$slots.extra ? (k(), z("div", { key: 0, class: O(i(n).e("header")) }, [Q("div", { class: O(i(n).e("title")) }, [ke(u.$slots, "title", {}, () => [Ot(Be(u.title), 1)])], 2), Q("div", { class: O(i(n).e("extra")) }, [ke(u.$slots, "extra", {}, () => [Ot(Be(u.extra), 1)])], 2)], 2)) : pe("v-if", !0), Q("div", { class: O(i(n).e("body")) }, [Q("table", { class: O([i(n).e("table"), i(n).is("bordered", u.border)]) }, [Q("tbody", null, [(k(!0), z(Qe, null, Et(a(), (d, f) => (k(), ge(t9, { key: f, row: d }, null, 8, ["row"]))), 128))])], 2)], 2)], 2)); } });
var s9 = Fe(r9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/description.vue"]]), GC = ae({ name: "ElDescriptionsItem", props: { label: { type: String, default: "" }, span: { type: Number, default: 1 }, width: { type: [String, Number], default: "" }, minWidth: { type: [String, Number], default: "" }, align: { type: String, default: "left" }, labelAlign: { type: String, default: "" }, className: { type: String, default: "" }, labelClassName: { type: String, default: "" } } });
const l9 = vt(s9, { DescriptionsItem: GC }), a9 = pn(GC), i9 = Ve({ mask: { type: Boolean, default: !0 }, customMaskEvent: { type: Boolean, default: !1 }, overlayClass: { type: ve([String, Array, Object]) }, zIndex: { type: ve([String, Number]) } }), u9 = { click: e => e instanceof MouseEvent }, c9 = "overlay";
var d9 = ae({ name: "ElOverlay", props: i9, emits: u9, setup(e, { slots: t, emit: n }) { const o = Ie(c9), r = u => { n("click", u); }, { onClick: s, onMousedown: l, onMouseup: a } = Ch(e.customMaskEvent ? void 0 : r); return () => e.mask ? ee("div", { class: [o.b(), e.overlayClass], style: { zIndex: e.zIndex }, onClick: s, onMousedown: l, onMouseup: a }, [ke(t, "default")], bo.STYLE | bo.CLASS | bo.PROPS, ["onClick", "onMouseup", "onMousedown"]) : nt("div", { class: e.overlayClass, style: { zIndex: e.zIndex, position: "fixed", top: "0px", right: "0px", bottom: "0px", left: "0px" } }, [ke(t, "default")]); } });
const Fh = d9, XC = Symbol("dialogInjectionKey"), JC = Ve({ center: { type: Boolean, default: !1 }, alignCenter: { type: Boolean, default: !1 }, closeIcon: { type: Zt }, customClass: { type: String, default: "" }, draggable: { type: Boolean, default: !1 }, fullscreen: { type: Boolean, default: !1 }, showClose: { type: Boolean, default: !0 }, title: { type: String, default: "" } }), f9 = { close: () => !0 }, p9 = ["aria-label"], h9 = ["id"], v9 = ae({ name: "ElDialogContent" }), m9 = ae({ ...v9, props: JC, emits: f9, setup(e) { const t = e, { t: n } = Nt(), { Close: o } = D1, { dialogRef: r, headerRef: s, bodyId: l, ns: a, style: u } = Ye(XC), { focusTrapRef: c } = Ye(Ih), d = Ac(c, r), f = S(() => t.draggable); return V1(r, s, f), (p, v) => (k(), z("div", { ref: i(d), class: O([i(a).b(), i(a).is("fullscreen", p.fullscreen), i(a).is("draggable", i(f)), i(a).is("align-center", p.alignCenter), { [i(a).m("center")]: p.center }, p.customClass]), style: et(i(u)), tabindex: "-1" }, [Q("header", { ref_key: "headerRef", ref: s, class: O(i(a).e("header")) }, [ke(p.$slots, "header", {}, () => [Q("span", { role: "heading", class: O(i(a).e("title")) }, Be(p.title), 3)]), p.showClose ? (k(), z("button", { key: 0, "aria-label": i(n)("el.dialog.close"), class: O(i(a).e("headerbtn")), type: "button", onClick: v[0] || (v[0] = m => p.$emit("close")) }, [ee(i(Je), { class: O(i(a).e("close")) }, { default: ie(() => [(k(), ge(kt(p.closeIcon || i(o))))]), _: 1 }, 8, ["class"])], 10, p9)) : pe("v-if", !0)], 2), Q("div", { id: i(l), class: O(i(a).e("body")) }, [ke(p.$slots, "default")], 10, h9), p.$slots.footer ? (k(), z("footer", { key: 0, class: O(i(a).e("footer")) }, [ke(p.$slots, "footer")], 2)) : pe("v-if", !0)], 6)); } });
var g9 = Fe(m9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog-content.vue"]]);
const ZC = Ve({ ...JC, appendToBody: { type: Boolean, default: !1 }, beforeClose: { type: ve(Function) }, destroyOnClose: { type: Boolean, default: !1 }, closeOnClickModal: { type: Boolean, default: !0 }, closeOnPressEscape: { type: Boolean, default: !0 }, lockScroll: { type: Boolean, default: !0 }, modal: { type: Boolean, default: !0 }, openDelay: { type: Number, default: 0 }, closeDelay: { type: Number, default: 0 }, top: { type: String }, modelValue: { type: Boolean, default: !1 }, modalClass: String, width: { type: [String, Number] }, zIndex: { type: Number }, trapFocus: { type: Boolean, default: !1 } }), QC = { open: () => !0, opened: () => !0, close: () => !0, closed: () => !0, [gt]: e => wn(e), openAutoFocus: () => !0, closeAutoFocus: () => !0 }, e2 = (e, t) => { const o = ht().emit, { nextZIndex: r } = Gl(); let s = ""; const l = xo(), a = xo(), u = M(!1), c = M(!1), d = M(!1), f = M(e.zIndex || r()); let p, v; const m = Fc("namespace", ju), h = S(() => { const K = {}, te = `--${m.value}-dialog`; return e.fullscreen || (e.top && (K[`${te}-margin-top`] = e.top), e.width && (K[`${te}-width`] = gn(e.width))), K; }), g = S(() => e.alignCenter ? { display: "flex" } : {}); function y() { o("opened"); } function C() { o("closed"), o(gt, !1), e.destroyOnClose && (d.value = !1); } function b() { o("close"); } function w() { v == null || v(), p == null || p(), e.openDelay && e.openDelay > 0 ? { stop: p } = Vs(() => I(), e.openDelay) : I(); } function T() { p == null || p(), v == null || v(), e.closeDelay && e.closeDelay > 0 ? { stop: v } = Vs(() => L(), e.closeDelay) : L(); } function E() { function K(te) { te || (c.value = !0, u.value = !1); } e.beforeClose ? e.beforeClose(K) : T(); } function x() { e.closeOnClickModal && E(); } function I() { At && (u.value = !0); } function L() { u.value = !1; } function B() { o("openAutoFocus"); } function F() { o("closeAutoFocus"); } function V(K) { var te; ((te = K.detail) == null ? void 0 : te.focusReason) === "pointer" && K.preventDefault(); } e.lockScroll && K1(u); function R() { e.closeOnPressEscape && E(); } return Oe(() => e.modelValue, K => { K ? (c.value = !1, w(), d.value = !0, f.value = e.zIndex ? f.value++ : r(), Xe(() => { o("open"), t.value && (t.value.scrollTop = 0); })) : u.value && T(); }), Oe(() => e.fullscreen, K => { t.value && (K ? (s = t.value.style.transform, t.value.style.transform = "") : t.value.style.transform = s); }), ft(() => { e.modelValue && (u.value = !0, d.value = !0, w()); }), { afterEnter: y, afterLeave: C, beforeLeave: b, handleClose: E, onModalClick: x, close: T, doClose: L, onOpenAutoFocus: B, onCloseAutoFocus: F, onCloseRequested: R, onFocusoutPrevented: V, titleId: l, bodyId: a, closed: c, style: h, overlayDialogStyle: g, rendered: d, visible: u, zIndex: f }; }, y9 = ["aria-label", "aria-labelledby", "aria-describedby"], b9 = ae({ name: "ElDialog", inheritAttrs: !1 }), w9 = ae({ ...b9, props: ZC, emits: QC, setup(e, { expose: t }) { const n = e, o = An(); tr({ scope: "el-dialog", from: "the title slot", replacement: "the header slot", version: "3.0.0", ref: "https://element-plus.org/en-US/component/dialog.html#slots" }, S(() => !!o.title)), tr({ scope: "el-dialog", from: "custom-class", replacement: "class", version: "2.3.0", ref: "https://element-plus.org/en-US/component/dialog.html#attributes", type: "Attribute" }, S(() => !!n.customClass)); const r = Ie("dialog"), s = M(), l = M(), a = M(), { visible: u, titleId: c, bodyId: d, style: f, overlayDialogStyle: p, rendered: v, zIndex: m, afterEnter: h, afterLeave: g, beforeLeave: y, handleClose: C, onModalClick: b, onOpenAutoFocus: w, onCloseAutoFocus: T, onCloseRequested: E, onFocusoutPrevented: x } = e2(n, s); St(XC, { dialogRef: s, headerRef: l, bodyId: d, ns: r, rendered: v, style: f }); const I = Ch(b), L = S(() => n.draggable && !n.fullscreen); return t({ visible: u, dialogContentRef: a }), (B, F) => (k(), ge(mi, { to: "body", disabled: !B.appendToBody }, [ee(yn, { name: "dialog-fade", onAfterEnter: i(h), onAfterLeave: i(g), onBeforeLeave: i(y), persisted: "" }, { default: ie(() => [dt(ee(i(Fh), { "custom-mask-event": "", mask: B.modal, "overlay-class": B.modalClass, "z-index": i(m) }, { default: ie(() => [Q("div", { role: "dialog", "aria-modal": "true", "aria-label": B.title || void 0, "aria-labelledby": B.title ? void 0 : i(c), "aria-describedby": i(d), class: O(`${i(r).namespace.value}-overlay-dialog`), style: et(i(p)), onClick: F[0] || (F[0] = (...V) => i(I).onClick && i(I).onClick(...V)), onMousedown: F[1] || (F[1] = (...V) => i(I).onMousedown && i(I).onMousedown(...V)), onMouseup: F[2] || (F[2] = (...V) => i(I).onMouseup && i(I).onMouseup(...V)) }, [ee(i(Hc), { loop: "", trapped: i(u), "focus-start-el": "container", onFocusAfterTrapped: i(w), onFocusAfterReleased: i(T), onFocusoutPrevented: i(x), onReleaseRequested: i(E) }, { default: ie(() => [i(v) ? (k(), ge(g9, Ct({ key: 0, ref_key: "dialogContentRef", ref: a }, B.$attrs, { "custom-class": B.customClass, center: B.center, "align-center": B.alignCenter, "close-icon": B.closeIcon, draggable: i(L), fullscreen: B.fullscreen, "show-close": B.showClose, title: B.title, onClose: i(C) }), Cr({ header: ie(() => [B.$slots.title ? ke(B.$slots, "title", { key: 1 }) : ke(B.$slots, "header", { key: 0, close: i(C), titleId: i(c), titleClass: i(r).e("title") })]), default: ie(() => [ke(B.$slots, "default")]), _: 2 }, [B.$slots.footer ? { name: "footer", fn: ie(() => [ke(B.$slots, "footer")]) } : void 0]), 1040, ["custom-class", "center", "align-center", "close-icon", "draggable", "fullscreen", "show-close", "title", "onClose"])) : pe("v-if", !0)]), _: 3 }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])], 46, y9)]), _: 3 }, 8, ["mask", "overlay-class", "z-index"]), [[Pt, i(u)]])]), _: 3 }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])], 8, ["disabled"])); } });
var C9 = Fe(w9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog.vue"]]);
const S9 = vt(C9), _9 = Ve({ direction: { type: String, values: ["horizontal", "vertical"], default: "horizontal" }, contentPosition: { type: String, values: ["left", "center", "right"], default: "center" }, borderStyle: { type: ve(String), default: "solid" } }), k9 = ae({ name: "ElDivider" }), E9 = ae({ ...k9, props: _9, setup(e) { const t = e, n = Ie("divider"), o = S(() => n.cssVar({ "border-style": t.borderStyle })); return (r, s) => (k(), z("div", { class: O([i(n).b(), i(n).m(r.direction)]), style: et(i(o)), role: "separator" }, [r.$slots.default && r.direction !== "vertical" ? (k(), z("div", { key: 0, class: O([i(n).e("text"), i(n).is(r.contentPosition)]) }, [ke(r.$slots, "default")], 2)) : pe("v-if", !0)], 6)); } });
var $9 = Fe(E9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/divider/src/divider.vue"]]);
const t2 = vt($9), T9 = Ve({ ...ZC, direction: { type: String, default: "rtl", values: ["ltr", "rtl", "ttb", "btt"] }, size: { type: [String, Number], default: "30%" }, withHeader: { type: Boolean, default: !0 }, modalFade: { type: Boolean, default: !0 } }), O9 = QC, I9 = ae({ name: "ElDrawer", components: { ElOverlay: Fh, ElFocusTrap: Hc, ElIcon: Je, Close: Ho }, inheritAttrs: !1, props: T9, emits: O9, setup(e, { slots: t }) { tr({ scope: "el-drawer", from: "the title slot", replacement: "the header slot", version: "3.0.0", ref: "https://element-plus.org/en-US/component/drawer.html#slots" }, S(() => !!t.title)), tr({ scope: "el-drawer", from: "custom-class", replacement: "class", version: "2.3.0", ref: "https://element-plus.org/en-US/component/drawer.html#attributes", type: "Attribute" }, S(() => !!e.customClass)); const n = M(), o = M(), r = Ie("drawer"), { t: s } = Nt(), l = S(() => e.direction === "rtl" || e.direction === "ltr"), a = S(() => gn(e.size)); return { ...e2(e, n), drawerRef: n, focusStartRef: o, isHorizontal: l, drawerSize: a, ns: r, t: s }; } }), x9 = ["aria-label", "aria-labelledby", "aria-describedby"], A9 = ["id"], M9 = ["aria-label"], N9 = ["id"];
function P9(e, t, n, o, r, s) { const l = ct("close"), a = ct("el-icon"), u = ct("el-focus-trap"), c = ct("el-overlay"); return k(), ge(mi, { to: "body", disabled: !e.appendToBody }, [ee(yn, { name: e.ns.b("fade"), onAfterEnter: e.afterEnter, onAfterLeave: e.afterLeave, onBeforeLeave: e.beforeLeave, persisted: "" }, { default: ie(() => [dt(ee(c, { mask: e.modal, "overlay-class": e.modalClass, "z-index": e.zIndex, onClick: e.onModalClick }, { default: ie(() => [ee(u, { loop: "", trapped: e.visible, "focus-trap-el": e.drawerRef, "focus-start-el": e.focusStartRef, onReleaseRequested: e.onCloseRequested }, { default: ie(() => [Q("div", Ct({ ref: "drawerRef", "aria-modal": "true", "aria-label": e.title || void 0, "aria-labelledby": e.title ? void 0 : e.titleId, "aria-describedby": e.bodyId }, e.$attrs, { class: [e.ns.b(), e.direction, e.visible && "open", e.customClass], style: e.isHorizontal ? "width: " + e.drawerSize : "height: " + e.drawerSize, role: "dialog", onClick: t[1] || (t[1] = st(() => { }, ["stop"])) }), [Q("span", { ref: "focusStartRef", class: O(e.ns.e("sr-focus")), tabindex: "-1" }, null, 2), e.withHeader ? (k(), z("header", { key: 0, class: O(e.ns.e("header")) }, [e.$slots.title ? ke(e.$slots, "title", { key: 1 }, () => [pe(" DEPRECATED SLOT ")]) : ke(e.$slots, "header", { key: 0, close: e.handleClose, titleId: e.titleId, titleClass: e.ns.e("title") }, () => [e.$slots.title ? pe("v-if", !0) : (k(), z("span", { key: 0, id: e.titleId, role: "heading", class: O(e.ns.e("title")) }, Be(e.title), 11, A9))]), e.showClose ? (k(), z("button", { key: 2, "aria-label": e.t("el.drawer.close"), class: O(e.ns.e("close-btn")), type: "button", onClick: t[0] || (t[0] = (...d) => e.handleClose && e.handleClose(...d)) }, [ee(a, { class: O(e.ns.e("close")) }, { default: ie(() => [ee(l)]), _: 1 }, 8, ["class"])], 10, M9)) : pe("v-if", !0)], 2)) : pe("v-if", !0), e.rendered ? (k(), z("div", { key: 1, id: e.bodyId, class: O(e.ns.e("body")) }, [ke(e.$slots, "default")], 10, N9)) : pe("v-if", !0), e.$slots.footer ? (k(), z("div", { key: 2, class: O(e.ns.e("footer")) }, [ke(e.$slots, "footer")], 2)) : pe("v-if", !0)], 16, x9)]), _: 3 }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])]), _: 3 }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [[Pt, e.visible]])]), _: 3 }, 8, ["name", "onAfterEnter", "onAfterLeave", "onBeforeLeave"])], 8, ["disabled"]); }
var R9 = Fe(I9, [["render", P9], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/drawer/src/drawer.vue"]]);
const L9 = vt(R9), D9 = ae({ inheritAttrs: !1 });
function B9(e, t, n, o, r, s) { return ke(e.$slots, "default"); }
var F9 = Fe(D9, [["render", B9], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);
const V9 = ae({ name: "ElCollectionItem", inheritAttrs: !1 });
function z9(e, t, n, o, r, s) { return ke(e.$slots, "default"); }
var H9 = Fe(V9, [["render", z9], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);
const n2 = "data-el-collection-item", o2 = e => { const t = `El${e}Collection`, n = `${t}Item`, o = Symbol(t), r = Symbol(n), s = { ...F9, name: t, setup() { const a = M(null), u = new Map; St(o, { itemMap: u, getItems: () => { const d = i(a); if (!d)
            return []; const f = Array.from(d.querySelectorAll(`[${n2}]`)); return [...u.values()].sort((v, m) => f.indexOf(v.ref) - f.indexOf(m.ref)); }, collectionRef: a }); } }, l = { ...H9, name: n, setup(a, { attrs: u }) { const c = M(null), d = Ye(o, void 0); St(r, { collectionItemRef: c }), ft(() => { const f = i(c); f && d.itemMap.set(f, { ref: f, ...u }); }), on(() => { const f = i(c); d.itemMap.delete(f); }); } }; return { COLLECTION_INJECTION_KEY: o, COLLECTION_ITEM_INJECTION_KEY: r, ElCollection: s, ElCollectionItem: l }; }, K9 = Ve({ style: { type: ve([String, Array, Object]) }, currentTabId: { type: ve(String) }, defaultCurrentTabId: String, loop: Boolean, dir: { type: String, values: ["ltr", "rtl"], default: "ltr" }, orientation: { type: ve(String) }, onBlur: Function, onFocus: Function, onMousedown: Function }), { ElCollection: j9, ElCollectionItem: W9, COLLECTION_INJECTION_KEY: Vh, COLLECTION_ITEM_INJECTION_KEY: U9 } = o2("RovingFocusGroup"), zh = Symbol("elRovingFocusGroup"), r2 = Symbol("elRovingFocusGroupItem"), q9 = { ArrowLeft: "prev", ArrowUp: "prev", ArrowRight: "next", ArrowDown: "next", PageUp: "first", Home: "first", PageDown: "last", End: "last" }, Y9 = (e, t) => { if (t !== "rtl")
    return e; switch (e) {
    case tt.right: return tt.left;
    case tt.left: return tt.right;
    default: return e;
} }, G9 = (e, t, n) => { const o = Y9(e.key, n); if (!(t === "vertical" && [tt.left, tt.right].includes(o)) && !(t === "horizontal" && [tt.up, tt.down].includes(o)))
    return q9[o]; }, X9 = (e, t) => e.map((n, o) => e[(o + t) % e.length]), Hh = e => { const { activeElement: t } = document; for (const n of e)
    if (n === t || (n.focus(), t !== document.activeElement))
        return; }, N0 = "currentTabIdChange", P0 = "rovingFocusGroup.entryFocus", J9 = { bubbles: !1, cancelable: !0 }, Z9 = ae({ name: "ElRovingFocusGroupImpl", inheritAttrs: !1, props: K9, emits: [N0, "entryFocus"], setup(e, { emit: t }) { var n; const o = M((n = e.currentTabId || e.defaultCurrentTabId) != null ? n : null), r = M(!1), s = M(!1), l = M(null), { getItems: a } = Ye(Vh, void 0), u = S(() => [{ outline: "none" }, e.style]), c = h => { t(N0, h); }, d = () => { r.value = !0; }, f = fn(h => { var g; (g = e.onMousedown) == null || g.call(e, h); }, () => { s.value = !0; }), p = fn(h => { var g; (g = e.onFocus) == null || g.call(e, h); }, h => { const g = !i(s), { target: y, currentTarget: C } = h; if (y === C && g && !i(r)) {
        const b = new Event(P0, J9);
        if (C == null || C.dispatchEvent(b), !b.defaultPrevented) {
            const w = a().filter(L => L.focusable), T = w.find(L => L.active), E = w.find(L => L.id === i(o)), I = [T, E, ...w].filter(Boolean).map(L => L.ref);
            Hh(I);
        }
    } s.value = !1; }), v = fn(h => { var g; (g = e.onBlur) == null || g.call(e, h); }, () => { r.value = !1; }), m = (...h) => { t("entryFocus", ...h); }; St(zh, { currentTabbedId: Wl(o), loop: an(e, "loop"), tabIndex: S(() => i(r) ? -1 : 0), rovingFocusGroupRef: l, rovingFocusGroupRootStyle: u, orientation: an(e, "orientation"), dir: an(e, "dir"), onItemFocus: c, onItemShiftTab: d, onBlur: v, onFocus: p, onMousedown: f }), Oe(() => e.currentTabId, h => { o.value = h ?? null; }), nn(l, P0, m); } });
function Q9(e, t, n, o, r, s) { return ke(e.$slots, "default"); }
var ej = Fe(Z9, [["render", Q9], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group-impl.vue"]]);
const tj = ae({ name: "ElRovingFocusGroup", components: { ElFocusGroupCollection: j9, ElRovingFocusGroupImpl: ej } });
function nj(e, t, n, o, r, s) { const l = ct("el-roving-focus-group-impl"), a = ct("el-focus-group-collection"); return k(), ge(a, null, { default: ie(() => [ee(l, Lo(yc(e.$attrs)), { default: ie(() => [ke(e.$slots, "default")]), _: 3 }, 16)]), _: 3 }); }
var oj = Fe(tj, [["render", nj], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group.vue"]]);
const rj = ae({ components: { ElRovingFocusCollectionItem: W9 }, props: { focusable: { type: Boolean, default: !0 }, active: { type: Boolean, default: !1 } }, emits: ["mousedown", "focus", "keydown"], setup(e, { emit: t }) { const { currentTabbedId: n, loop: o, onItemFocus: r, onItemShiftTab: s } = Ye(zh, void 0), { getItems: l } = Ye(Vh, void 0), a = xo(), u = M(null), c = fn(v => { t("mousedown", v); }, v => { e.focusable ? r(i(a)) : v.preventDefault(); }), d = fn(v => { t("focus", v); }, () => { r(i(a)); }), f = fn(v => { t("keydown", v); }, v => { const { key: m, shiftKey: h, target: g, currentTarget: y } = v; if (m === tt.tab && h) {
        s();
        return;
    } if (g !== y)
        return; const C = G9(v); if (C) {
        v.preventDefault();
        let w = l().filter(T => T.focusable).map(T => T.ref);
        switch (C) {
            case "last": {
                w.reverse();
                break;
            }
            case "prev":
            case "next": {
                C === "prev" && w.reverse();
                const T = w.indexOf(y);
                w = o.value ? X9(w, T + 1) : w.slice(T + 1);
                break;
            }
        }
        Xe(() => { Hh(w); });
    } }), p = S(() => n.value === i(a)); return St(r2, { rovingFocusGroupItemRef: u, tabIndex: S(() => i(p) ? 0 : -1), handleMousedown: c, handleFocus: d, handleKeydown: f }), { id: a, handleKeydown: f, handleFocus: d, handleMousedown: c }; } });
function sj(e, t, n, o, r, s) { const l = ct("el-roving-focus-collection-item"); return k(), ge(l, { id: e.id, focusable: e.focusable, active: e.active }, { default: ie(() => [ke(e.$slots, "default")]), _: 3 }, 8, ["id", "focusable", "active"]); }
var lj = Fe(rj, [["render", sj], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-item.vue"]]);
const Su = Ve({ trigger: oi.trigger, effect: { ...On.effect, default: "light" }, type: { type: ve(String) }, placement: { type: ve(String), default: "bottom" }, popperOptions: { type: ve(Object), default: () => ({}) }, id: String, size: { type: String, default: "" }, splitButton: Boolean, hideOnClick: { type: Boolean, default: !0 }, loop: { type: Boolean, default: !0 }, showTimeout: { type: Number, default: 150 }, hideTimeout: { type: Number, default: 150 }, tabindex: { type: ve([Number, String]), default: 0 }, maxHeight: { type: ve([Number, String]), default: "" }, popperClass: { type: String, default: "" }, disabled: { type: Boolean, default: !1 }, role: { type: String, default: "menu" }, buttonProps: { type: ve(Object) }, teleported: On.teleported }), s2 = Ve({ command: { type: [Object, String, Number], default: () => ({}) }, disabled: Boolean, divided: Boolean, textValue: String, icon: { type: Zt } }), aj = Ve({ onKeydown: { type: ve(Function) } }), ij = [tt.down, tt.pageDown, tt.home], l2 = [tt.up, tt.pageUp, tt.end], uj = [...ij, ...l2], { ElCollection: cj, ElCollectionItem: dj, COLLECTION_INJECTION_KEY: fj, COLLECTION_ITEM_INJECTION_KEY: pj } = o2("Dropdown"), Wc = Symbol("elDropdown"), { ButtonGroup: hj } = xn, vj = ae({ name: "ElDropdown", components: { ElButton: xn, ElButtonGroup: hj, ElScrollbar: Or, ElDropdownCollection: cj, ElTooltip: Jn, ElRovingFocusGroup: oj, ElOnlyChild: Aw, ElIcon: Je, ArrowDown: ss }, props: Su, emits: ["visible-change", "click", "command"], setup(e, { emit: t }) { const n = ht(), o = Ie("dropdown"), { t: r } = Nt(), s = M(), l = M(), a = M(null), u = M(null), c = M(null), d = M(null), f = M(!1), p = [tt.enter, tt.space, tt.down], v = S(() => ({ maxHeight: gn(e.maxHeight) })), m = S(() => [o.m(w.value)]), h = xo().value, g = S(() => e.id || h); Oe([s, an(e, "trigger")], ([U, D], [j]) => { var A, G, se; const Z = qe(D) ? D : [D]; (A = j == null ? void 0 : j.$el) != null && A.removeEventListener && j.$el.removeEventListener("pointerenter", E), (G = U == null ? void 0 : U.$el) != null && G.removeEventListener && U.$el.removeEventListener("pointerenter", E), (se = U == null ? void 0 : U.$el) != null && se.addEventListener && Z.includes("hover") && U.$el.addEventListener("pointerenter", E); }, { immediate: !0 }), on(() => { var U, D; (D = (U = s.value) == null ? void 0 : U.$el) != null && D.removeEventListener && s.value.$el.removeEventListener("pointerenter", E); }); function y() { C(); } function C() { var U; (U = a.value) == null || U.onClose(); } function b() { var U; (U = a.value) == null || U.onOpen(); } const w = kn(); function T(...U) { t("command", ...U); } function E() { var U, D; (D = (U = s.value) == null ? void 0 : U.$el) == null || D.focus(); } function x() { } function I() { const U = i(u); U == null || U.focus(), d.value = null; } function L(U) { d.value = U; } function B(U) { f.value || (U.preventDefault(), U.stopImmediatePropagation()); } function F() { t("visible-change", !0); } function V(U) { (U == null ? void 0 : U.type) === "keydown" && u.value.focus(); } function R() { t("visible-change", !1); } return St(Wc, { contentRef: u, role: S(() => e.role), triggerId: g, isUsingKeyboard: f, onItemEnter: x, onItemLeave: I }), St("elDropdown", { instance: n, dropdownSize: w, handleClick: y, commandHandler: T, trigger: an(e, "trigger"), hideOnClick: an(e, "hideOnClick") }), { t: r, ns: o, scrollbar: c, wrapStyle: v, dropdownTriggerKls: m, dropdownSize: w, triggerId: g, triggerKeys: p, currentTabId: d, handleCurrentTabIdChange: L, handlerMainButtonClick: U => { t("click", U); }, handleEntryFocus: B, handleClose: C, handleOpen: b, handleBeforeShowTooltip: F, handleShowTooltip: V, handleBeforeHideTooltip: R, onFocusAfterTrapped: U => { var D, j; U.preventDefault(), (j = (D = u.value) == null ? void 0 : D.focus) == null || j.call(D, { preventScroll: !0 }); }, popperRef: a, contentRef: u, triggeringElementRef: s, referenceElementRef: l }; } });
function mj(e, t, n, o, r, s) { var l; const a = ct("el-dropdown-collection"), u = ct("el-roving-focus-group"), c = ct("el-scrollbar"), d = ct("el-only-child"), f = ct("el-tooltip"), p = ct("el-button"), v = ct("arrow-down"), m = ct("el-icon"), h = ct("el-button-group"); return k(), z("div", { class: O([e.ns.b(), e.ns.is("disabled", e.disabled)]) }, [ee(f, { ref: "popperRef", role: e.role, effect: e.effect, "fallback-placements": ["bottom", "top"], "popper-options": e.popperOptions, "gpu-acceleration": !1, "hide-after": e.trigger === "hover" ? e.hideTimeout : 0, "manual-mode": !0, placement: e.placement, "popper-class": [e.ns.e("popper"), e.popperClass], "reference-element": (l = e.referenceElementRef) == null ? void 0 : l.$el, trigger: e.trigger, "trigger-keys": e.triggerKeys, "trigger-target-el": e.contentRef, "show-after": e.trigger === "hover" ? e.showTimeout : 0, "stop-popper-mouse-event": !1, "virtual-ref": e.triggeringElementRef, "virtual-triggering": e.splitButton, disabled: e.disabled, transition: `${e.ns.namespace.value}-zoom-in-top`, teleported: e.teleported, pure: "", persistent: "", onBeforeShow: e.handleBeforeShowTooltip, onShow: e.handleShowTooltip, onBeforeHide: e.handleBeforeHideTooltip }, Cr({ content: ie(() => [ee(c, { ref: "scrollbar", "wrap-style": e.wrapStyle, tag: "div", "view-class": e.ns.e("list") }, { default: ie(() => [ee(u, { loop: e.loop, "current-tab-id": e.currentTabId, orientation: "horizontal", onCurrentTabIdChange: e.handleCurrentTabIdChange, onEntryFocus: e.handleEntryFocus }, { default: ie(() => [ee(a, null, { default: ie(() => [ke(e.$slots, "dropdown")]), _: 3 })]), _: 3 }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])]), _: 3 }, 8, ["wrap-style", "view-class"])]), _: 2 }, [e.splitButton ? void 0 : { name: "default", fn: ie(() => [ee(d, { id: e.triggerId, ref: "triggeringElementRef", role: "button", tabindex: e.tabindex }, { default: ie(() => [ke(e.$slots, "default")]), _: 3 }, 8, ["id", "tabindex"])]) }]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "onBeforeShow", "onShow", "onBeforeHide"]), e.splitButton ? (k(), ge(h, { key: 0 }, { default: ie(() => [ee(p, Ct({ ref: "referenceElementRef" }, e.buttonProps, { size: e.dropdownSize, type: e.type, disabled: e.disabled, tabindex: e.tabindex, onClick: e.handlerMainButtonClick }), { default: ie(() => [ke(e.$slots, "default")]), _: 3 }, 16, ["size", "type", "disabled", "tabindex", "onClick"]), ee(p, Ct({ id: e.triggerId, ref: "triggeringElementRef" }, e.buttonProps, { role: "button", size: e.dropdownSize, type: e.type, class: e.ns.e("caret-button"), disabled: e.disabled, tabindex: e.tabindex, "aria-label": e.t("el.dropdown.toggleDropdown") }), { default: ie(() => [ee(m, { class: O(e.ns.e("icon")) }, { default: ie(() => [ee(v)]), _: 1 }, 8, ["class"])]), _: 1 }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])]), _: 3 })) : pe("v-if", !0)], 2); }
var gj = Fe(vj, [["render", mj], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown.vue"]]);
const yj = ae({ name: "DropdownItemImpl", components: { ElIcon: Je }, props: s2, emits: ["pointermove", "pointerleave", "click", "clickimpl"], setup(e, { emit: t }) { const n = Ie("dropdown"), { role: o } = Ye(Wc, void 0), { collectionItemRef: r } = Ye(pj, void 0), { collectionItemRef: s } = Ye(U9, void 0), { rovingFocusGroupItemRef: l, tabIndex: a, handleFocus: u, handleKeydown: c, handleMousedown: d } = Ye(r2, void 0), f = Ac(r, s, l), p = S(() => o.value === "menu" ? "menuitem" : o.value === "navigation" ? "link" : "button"), v = fn(m => { const { code: h } = m; if (h === tt.enter || h === tt.space)
        return m.preventDefault(), m.stopImmediatePropagation(), t("clickimpl", m), !0; }, c); return { ns: n, itemRef: f, dataset: { [n2]: "" }, role: p, tabIndex: a, handleFocus: u, handleKeydown: v, handleMousedown: d }; } }), bj = ["aria-disabled", "tabindex", "role"];
function wj(e, t, n, o, r, s) { const l = ct("el-icon"); return k(), z(Qe, null, [e.divided ? (k(), z("li", Ct({ key: 0, role: "separator", class: e.ns.bem("menu", "item", "divided") }, e.$attrs), null, 16)) : pe("v-if", !0), Q("li", Ct({ ref: e.itemRef }, { ...e.dataset, ...e.$attrs }, { "aria-disabled": e.disabled, class: [e.ns.be("menu", "item"), e.ns.is("disabled", e.disabled)], tabindex: e.tabIndex, role: e.role, onClick: t[0] || (t[0] = a => e.$emit("clickimpl", a)), onFocus: t[1] || (t[1] = (...a) => e.handleFocus && e.handleFocus(...a)), onKeydown: t[2] || (t[2] = st((...a) => e.handleKeydown && e.handleKeydown(...a), ["self"])), onMousedown: t[3] || (t[3] = (...a) => e.handleMousedown && e.handleMousedown(...a)), onPointermove: t[4] || (t[4] = a => e.$emit("pointermove", a)), onPointerleave: t[5] || (t[5] = a => e.$emit("pointerleave", a)) }), [e.icon ? (k(), ge(l, { key: 0 }, { default: ie(() => [(k(), ge(kt(e.icon)))]), _: 1 })) : pe("v-if", !0), ke(e.$slots, "default")], 16, bj)], 64); }
var Cj = Fe(yj, [["render", wj], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item-impl.vue"]]);
const a2 = () => { const e = Ye("elDropdown", {}), t = S(() => e == null ? void 0 : e.dropdownSize); return { elDropdown: e, _elDropdownSize: t }; }, Sj = ae({ name: "ElDropdownItem", components: { ElDropdownCollectionItem: dj, ElRovingFocusItem: lj, ElDropdownItemImpl: Cj }, inheritAttrs: !1, props: s2, emits: ["pointermove", "pointerleave", "click"], setup(e, { emit: t, attrs: n }) { const { elDropdown: o } = a2(), r = ht(), s = M(null), l = S(() => { var v, m; return (m = (v = i(s)) == null ? void 0 : v.textContent) != null ? m : ""; }), { onItemEnter: a, onItemLeave: u } = Ye(Wc, void 0), c = fn(v => (t("pointermove", v), v.defaultPrevented), Mm(v => { if (e.disabled) {
        u(v);
        return;
    } const m = v.currentTarget; m === document.activeElement || m.contains(document.activeElement) || (a(v), v.defaultPrevented || m == null || m.focus()); })), d = fn(v => (t("pointerleave", v), v.defaultPrevented), Mm(v => { u(v); })), f = fn(v => { if (!e.disabled)
        return t("click", v), v.type !== "keydown" && v.defaultPrevented; }, v => { var m, h, g; if (e.disabled) {
        v.stopImmediatePropagation();
        return;
    } (m = o == null ? void 0 : o.hideOnClick) != null && m.value && ((h = o.handleClick) == null || h.call(o)), (g = o.commandHandler) == null || g.call(o, e.command, r, v); }), p = S(() => ({ ...e, ...n })); return { handleClick: f, handlePointerMove: c, handlePointerLeave: d, textContent: l, propsAndAttrs: p }; } });
function _j(e, t, n, o, r, s) { var l; const a = ct("el-dropdown-item-impl"), u = ct("el-roving-focus-item"), c = ct("el-dropdown-collection-item"); return k(), ge(c, { disabled: e.disabled, "text-value": (l = e.textValue) != null ? l : e.textContent }, { default: ie(() => [ee(u, { focusable: !e.disabled }, { default: ie(() => [ee(a, Ct(e.propsAndAttrs, { onPointerleave: e.handlePointerLeave, onPointermove: e.handlePointerMove, onClickimpl: e.handleClick }), { default: ie(() => [ke(e.$slots, "default")]), _: 3 }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])]), _: 3 }, 8, ["focusable"])]), _: 3 }, 8, ["disabled", "text-value"]); }
var i2 = Fe(Sj, [["render", _j], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item.vue"]]);
const kj = ae({ name: "ElDropdownMenu", props: aj, setup(e) { const t = Ie("dropdown"), { _elDropdownSize: n } = a2(), o = n.value, { focusTrapRef: r, onKeydown: s } = Ye(Ih, void 0), { contentRef: l, role: a, triggerId: u } = Ye(Wc, void 0), { collectionRef: c, getItems: d } = Ye(fj, void 0), { rovingFocusGroupRef: f, rovingFocusGroupRootStyle: p, tabIndex: v, onBlur: m, onFocus: h, onMousedown: g } = Ye(zh, void 0), { collectionRef: y } = Ye(Vh, void 0), C = S(() => [t.b("menu"), t.bm("menu", o == null ? void 0 : o.value)]), b = Ac(l, c, r, f, y), w = fn(E => { var x; (x = e.onKeydown) == null || x.call(e, E); }, E => { const { currentTarget: x, code: I, target: L } = E; if (x.contains(L), tt.tab === I && E.stopImmediatePropagation(), E.preventDefault(), L !== i(l) || !uj.includes(I))
        return; const F = d().filter(V => !V.disabled).map(V => V.ref); l2.includes(I) && F.reverse(), Hh(F); }); return { size: o, rovingFocusGroupRootStyle: p, tabIndex: v, dropdownKls: C, role: a, triggerId: u, dropdownListWrapperRef: b, handleKeydown: E => { w(E), s(E); }, onBlur: m, onFocus: h, onMousedown: g }; } }), Ej = ["role", "aria-labelledby"];
function $j(e, t, n, o, r, s) { return k(), z("ul", { ref: e.dropdownListWrapperRef, class: O(e.dropdownKls), style: et(e.rovingFocusGroupRootStyle), tabindex: -1, role: e.role, "aria-labelledby": e.triggerId, onBlur: t[0] || (t[0] = (...l) => e.onBlur && e.onBlur(...l)), onFocus: t[1] || (t[1] = (...l) => e.onFocus && e.onFocus(...l)), onKeydown: t[2] || (t[2] = st((...l) => e.handleKeydown && e.handleKeydown(...l), ["self"])), onMousedown: t[3] || (t[3] = st((...l) => e.onMousedown && e.onMousedown(...l), ["self"])) }, [ke(e.$slots, "default")], 46, Ej); }
var u2 = Fe(kj, [["render", $j], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-menu.vue"]]);
const Tj = vt(gj, { DropdownItem: i2, DropdownMenu: u2 }), Oj = pn(i2), Ij = pn(u2), xj = { viewBox: "0 0 79 86", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink" }, Aj = ["id"], Mj = ["stop-color"], Nj = ["stop-color"], Pj = ["id"], Rj = ["stop-color"], Lj = ["stop-color"], Dj = ["id"], Bj = { id: "Illustrations", stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, Fj = { id: "B-type", transform: "translate(-1268.000000, -535.000000)" }, Vj = { id: "Group-2", transform: "translate(1268.000000, 535.000000)" }, zj = ["fill"], Hj = ["fill"], Kj = { id: "Group-Copy", transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)" }, jj = ["fill"], Wj = ["fill"], Uj = ["fill"], qj = ["fill"], Yj = ["fill"], Gj = { id: "Rectangle-Copy-17", transform: "translate(53.000000, 45.000000)" }, Xj = ["fill", "xlink:href"], Jj = ["fill", "mask"], Zj = ["fill"], Qj = ae({ name: "ImgEmpty" }), e7 = ae({ ...Qj, setup(e) { const t = Ie("empty"), n = xo(); return (o, r) => (k(), z("svg", xj, [Q("defs", null, [Q("linearGradient", { id: `linearGradient-1-${i(n)}`, x1: "38.8503086%", y1: "0%", x2: "61.1496914%", y2: "100%" }, [Q("stop", { "stop-color": `var(${i(t).cssVarBlockName("fill-color-1")})`, offset: "0%" }, null, 8, Mj), Q("stop", { "stop-color": `var(${i(t).cssVarBlockName("fill-color-4")})`, offset: "100%" }, null, 8, Nj)], 8, Aj), Q("linearGradient", { id: `linearGradient-2-${i(n)}`, x1: "0%", y1: "9.5%", x2: "100%", y2: "90.5%" }, [Q("stop", { "stop-color": `var(${i(t).cssVarBlockName("fill-color-1")})`, offset: "0%" }, null, 8, Rj), Q("stop", { "stop-color": `var(${i(t).cssVarBlockName("fill-color-6")})`, offset: "100%" }, null, 8, Lj)], 8, Pj), Q("rect", { id: `path-3-${i(n)}`, x: "0", y: "0", width: "17", height: "36" }, null, 8, Dj)]), Q("g", Bj, [Q("g", Fj, [Q("g", Vj, [Q("path", { id: "Oval-Copy-2", d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z", fill: `var(${i(t).cssVarBlockName("fill-color-3")})` }, null, 8, zj), Q("polygon", { id: "Rectangle-Copy-14", fill: `var(${i(t).cssVarBlockName("fill-color-7")})`, transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ", points: "13 58 53 58 42 45 2 45" }, null, 8, Hj), Q("g", Kj, [Q("polygon", { id: "Rectangle-Copy-10", fill: `var(${i(t).cssVarBlockName("fill-color-7")})`, transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ", points: "2.84078316e-14 3 18 3 23 7 5 7" }, null, 8, jj), Q("polygon", { id: "Rectangle-Copy-11", fill: `var(${i(t).cssVarBlockName("fill-color-5")})`, points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43" }, null, 8, Wj), Q("rect", { id: "Rectangle-Copy-12", fill: `url(#linearGradient-1-${i(n)})`, transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ", x: "38", y: "7", width: "17", height: "36" }, null, 8, Uj), Q("polygon", { id: "Rectangle-Copy-13", fill: `var(${i(t).cssVarBlockName("fill-color-2")})`, transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ", points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12" }, null, 8, qj)]), Q("rect", { id: "Rectangle-Copy-15", fill: `url(#linearGradient-2-${i(n)})`, x: "13", y: "45", width: "40", height: "36" }, null, 8, Yj), Q("g", Gj, [Q("use", { id: "Mask", fill: `var(${i(t).cssVarBlockName("fill-color-8")})`, transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ", "xlink:href": `#path-3-${i(n)}` }, null, 8, Xj), Q("polygon", { id: "Rectangle-Copy", fill: `var(${i(t).cssVarBlockName("fill-color-9")})`, mask: `url(#mask-4-${i(n)})`, transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ", points: "7 0 24 0 20 18 7 16.5" }, null, 8, Jj)]), Q("polygon", { id: "Rectangle-Copy-18", fill: `var(${i(t).cssVarBlockName("fill-color-2")})`, transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ", points: "62 45 79 45 70 58 53 58" }, null, 8, Zj)])])])])); } });
var t7 = Fe(e7, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/empty/src/img-empty.vue"]]);
const n7 = Ve({ image: { type: String, default: "" }, imageSize: Number, description: { type: String, default: "" } }), o7 = ["src"], r7 = { key: 1 }, s7 = ae({ name: "ElEmpty" }), l7 = ae({ ...s7, props: n7, setup(e) { const t = e, { t: n } = Nt(), o = Ie("empty"), r = S(() => t.description || n("el.table.emptyText")), s = S(() => ({ width: gn(t.imageSize) })); return (l, a) => (k(), z("div", { class: O(i(o).b()) }, [Q("div", { class: O(i(o).e("image")), style: et(i(s)) }, [l.image ? (k(), z("img", { key: 0, src: l.image, ondragstart: "return false" }, null, 8, o7)) : ke(l.$slots, "image", { key: 1 }, () => [ee(t7)])], 6), Q("div", { class: O(i(o).e("description")) }, [l.$slots.description ? ke(l.$slots, "description", { key: 0 }) : (k(), z("p", r7, Be(i(r)), 1))], 2), l.$slots.default ? (k(), z("div", { key: 0, class: O(i(o).e("bottom")) }, [ke(l.$slots, "default")], 2)) : pe("v-if", !0)], 2)); } });
var a7 = Fe(l7, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/empty/src/empty.vue"]]);
const c2 = vt(a7), i7 = Ve({ urlList: { type: ve(Array), default: () => ln([]) }, zIndex: { type: Number }, initialIndex: { type: Number, default: 0 }, infinite: { type: Boolean, default: !0 }, hideOnClickModal: Boolean, teleported: Boolean, closeOnPressEscape: { type: Boolean, default: !0 }, zoomRate: { type: Number, default: 1.2 } }), u7 = { close: () => !0, switch: e => lt(e) }, c7 = ["src"], d7 = ae({ name: "ElImageViewer" }), f7 = ae({ ...d7, props: i7, emits: u7, setup(e, { expose: t, emit: n }) { const o = e, r = { CONTAIN: { name: "contain", icon: Ns(ON) }, ORIGINAL: { name: "original", icon: Ns(KP) } }, { t: s } = Nt(), l = Ie("image-viewer"), { nextZIndex: a } = Gl(), u = M(), c = M([]), d = g_(), f = M(!0), p = M(o.initialIndex), v = Xt(r.CONTAIN), m = M({ scale: 1, deg: 0, offsetX: 0, offsetY: 0, enableTransition: !1 }), h = S(() => { const { urlList: A } = o; return A.length <= 1; }), g = S(() => p.value === 0), y = S(() => p.value === o.urlList.length - 1), C = S(() => o.urlList[p.value]), b = S(() => [l.e("btn"), l.e("prev"), l.is("disabled", !o.infinite && g.value)]), w = S(() => [l.e("btn"), l.e("next"), l.is("disabled", !o.infinite && y.value)]), T = S(() => { const { scale: A, deg: G, offsetX: se, offsetY: Z, enableTransition: ce } = m.value; let ye = se / A, Re = Z / A; switch (G % 360) {
        case 90:
        case -270:
            [ye, Re] = [Re, -ye];
            break;
        case 180:
        case -180:
            [ye, Re] = [-ye, -Re];
            break;
        case 270:
        case -90:
            [ye, Re] = [-Re, ye];
            break;
    } const me = { transform: `scale(${A}) rotate(${G}deg) translate(${ye}px, ${Re}px)`, transition: ce ? "transform .3s" : "" }; return v.value.name === r.CONTAIN.name && (me.maxWidth = me.maxHeight = "100%"), me; }), E = S(() => lt(o.zIndex) ? o.zIndex : a()); function x() { L(), n("close"); } function I() { const A = Rs(se => { switch (se.code) {
        case tt.esc:
            o.closeOnPressEscape && x();
            break;
        case tt.space:
            K();
            break;
        case tt.left:
            U();
            break;
        case tt.up:
            j("zoomIn");
            break;
        case tt.right:
            D();
            break;
        case tt.down:
            j("zoomOut");
            break;
    } }), G = Rs(se => { const Z = se.deltaY || se.deltaX; j(Z < 0 ? "zoomIn" : "zoomOut", { zoomRate: o.zoomRate, enableTransition: !1 }); }); d.run(() => { nn(document, "keydown", A), nn(document, "wheel", G); }); } function L() { d.stop(); } function B() { f.value = !1; } function F(A) { f.value = !1, A.target.alt = s("el.image.error"); } function V(A) { if (f.value || A.button !== 0 || !u.value)
        return; m.value.enableTransition = !1; const { offsetX: G, offsetY: se } = m.value, Z = A.pageX, ce = A.pageY, ye = Rs(me => { m.value = { ...m.value, offsetX: G + me.pageX - Z, offsetY: se + me.pageY - ce }; }), Re = nn(document, "mousemove", ye); nn(document, "mouseup", () => { Re(); }), A.preventDefault(); } function R() { m.value = { scale: 1, deg: 0, offsetX: 0, offsetY: 0, enableTransition: !1 }; } function K() { if (f.value)
        return; const A = Xa(r), G = Object.values(r), se = v.value.name, ce = (G.findIndex(ye => ye.name === se) + 1) % A.length; v.value = r[A[ce]], R(); } function te(A) { const G = o.urlList.length; p.value = (A + G) % G; } function U() { g.value && !o.infinite || te(p.value - 1); } function D() { y.value && !o.infinite || te(p.value + 1); } function j(A, G = {}) { if (f.value)
        return; const { zoomRate: se, rotateDeg: Z, enableTransition: ce } = { zoomRate: o.zoomRate, rotateDeg: 90, enableTransition: !0, ...G }; switch (A) {
        case "zoomOut":
            m.value.scale > .2 && (m.value.scale = Number.parseFloat((m.value.scale / se).toFixed(3)));
            break;
        case "zoomIn":
            m.value.scale < 7 && (m.value.scale = Number.parseFloat((m.value.scale * se).toFixed(3)));
            break;
        case "clockwise":
            m.value.deg += Z;
            break;
        case "anticlockwise":
            m.value.deg -= Z;
            break;
    } m.value.enableTransition = ce; } return Oe(C, () => { Xe(() => { const A = c.value[0]; A != null && A.complete || (f.value = !0); }); }), Oe(p, A => { R(), n("switch", A); }), ft(() => { var A, G; I(), (G = (A = u.value) == null ? void 0 : A.focus) == null || G.call(A); }), t({ setActiveItem: te }), (A, G) => (k(), ge(mi, { to: "body", disabled: !A.teleported }, [ee(yn, { name: "viewer-fade", appear: "" }, { default: ie(() => [Q("div", { ref_key: "wrapper", ref: u, tabindex: -1, class: O(i(l).e("wrapper")), style: et({ zIndex: i(E) }) }, [Q("div", { class: O(i(l).e("mask")), onClick: G[0] || (G[0] = st(se => A.hideOnClickModal && x(), ["self"])) }, null, 2), pe(" CLOSE "), Q("span", { class: O([i(l).e("btn"), i(l).e("close")]), onClick: x }, [ee(i(Je), null, { default: ie(() => [ee(i(Ho))]), _: 1 })], 2), pe(" ARROW "), i(h) ? pe("v-if", !0) : (k(), z(Qe, { key: 0 }, [Q("span", { class: O(i(b)), onClick: U }, [ee(i(Je), null, { default: ie(() => [ee(i(Zr))]), _: 1 })], 2), Q("span", { class: O(i(w)), onClick: D }, [ee(i(Je), null, { default: ie(() => [ee(i(Un))]), _: 1 })], 2)], 64)), pe(" ACTIONS "), Q("div", { class: O([i(l).e("btn"), i(l).e("actions")]) }, [Q("div", { class: O(i(l).e("actions__inner")) }, [ee(i(Je), { onClick: G[1] || (G[1] = se => j("zoomOut")) }, { default: ie(() => [ee(i(WR))]), _: 1 }), ee(i(Je), { onClick: G[2] || (G[2] = se => j("zoomIn")) }, { default: ie(() => [ee(i(R1))]), _: 1 }), Q("i", { class: O(i(l).e("actions__divider")) }, null, 2), ee(i(Je), { onClick: K }, { default: ie(() => [(k(), ge(kt(i(v).icon)))]), _: 1 }), Q("i", { class: O(i(l).e("actions__divider")) }, null, 2), ee(i(Je), { onClick: G[3] || (G[3] = se => j("anticlockwise")) }, { default: ie(() => [ee(i(AP))]), _: 1 }), ee(i(Je), { onClick: G[4] || (G[4] = se => j("clockwise")) }, { default: ie(() => [ee(i(DP))]), _: 1 })], 2)], 2), pe(" CANVAS "), Q("div", { class: O(i(l).e("canvas")) }, [(k(!0), z(Qe, null, Et(A.urlList, (se, Z) => dt((k(), z("img", { ref_for: !0, ref: ce => c.value[Z] = ce, key: se, src: se, style: et(i(T)), class: O(i(l).e("img")), onLoad: B, onError: F, onMousedown: V }, null, 46, c7)), [[Pt, Z === p.value]])), 128))], 2), ke(A.$slots, "default")], 6)]), _: 3 })], 8, ["disabled"])); } });
var p7 = Fe(f7, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image-viewer/src/image-viewer.vue"]]);
const d2 = vt(p7), h7 = Ve({ hideOnClickModal: Boolean, src: { type: String, default: "" }, fit: { type: String, values: ["", "contain", "cover", "fill", "none", "scale-down"], default: "" }, loading: { type: String, values: ["eager", "lazy"] }, lazy: Boolean, scrollContainer: { type: ve([String, Object]) }, previewSrcList: { type: ve(Array), default: () => ln([]) }, previewTeleported: Boolean, zIndex: { type: Number }, initialIndex: { type: Number, default: 0 }, infinite: { type: Boolean, default: !0 }, closeOnPressEscape: { type: Boolean, default: !0 }, zoomRate: { type: Number, default: 1.2 } }), v7 = { load: e => e instanceof Event, error: e => e instanceof Event, switch: e => lt(e), close: () => !0, show: () => !0 }, m7 = ["src", "loading"], g7 = { key: 0 }, y7 = ae({ name: "ElImage", inheritAttrs: !1 }), b7 = ae({ ...y7, props: h7, emits: v7, setup(e, { emit: t }) { const n = e; let o = ""; const { t: r } = Nt(), s = Ie("image"), l = js(), a = dh(), u = M(), c = M(!1), d = M(!0), f = M(!1), p = M(), v = M(), m = At && "loading" in HTMLImageElement.prototype; let h, g; const y = S(() => [s.e("inner"), w.value && s.e("preview"), d.value && s.is("loading")]), C = S(() => l.style), b = S(() => { const { fit: j } = n; return At && j ? { objectFit: j } : {}; }), w = S(() => { const { previewSrcList: j } = n; return Array.isArray(j) && j.length > 0; }), T = S(() => { const { previewSrcList: j, initialIndex: A } = n; let G = A; return A > j.length - 1 && (G = 0), G; }), E = S(() => n.loading === "eager" ? !1 : !m && n.loading === "lazy" || n.lazy), x = () => { At && (d.value = !0, c.value = !1, u.value = n.src); }; function I(j) { d.value = !1, c.value = !1, t("load", j); } function L(j) { d.value = !1, c.value = !0, t("error", j); } function B() { vT(p.value, v.value) && (x(), R()); } const F = jb(B, 200, !0); async function V() { var j; if (!At)
        return; await Xe(); const { scrollContainer: A } = n; To(A) ? v.value = A : it(A) && A !== "" ? v.value = (j = document.querySelector(A)) != null ? j : void 0 : p.value && (v.value = lh(p.value)), v.value && (h = nn(v, "scroll", F), setTimeout(() => B(), 100)); } function R() { !At || !v.value || !F || (h == null || h(), v.value = void 0); } function K(j) { if (j.ctrlKey) {
        if (j.deltaY < 0)
            return j.preventDefault(), !1;
        if (j.deltaY > 0)
            return j.preventDefault(), !1;
    } } function te() { w.value && (g = nn("wheel", K, { passive: !1 }), o = document.body.style.overflow, document.body.style.overflow = "hidden", f.value = !0, t("show")); } function U() { g == null || g(), document.body.style.overflow = o, f.value = !1, t("close"); } function D(j) { t("switch", j); } return Oe(() => n.src, () => { E.value ? (d.value = !0, c.value = !1, R(), V()) : x(); }), ft(() => { E.value ? V() : x(); }), (j, A) => (k(), z("div", { ref_key: "container", ref: p, class: O([i(s).b(), j.$attrs.class]), style: et(i(C)) }, [c.value ? ke(j.$slots, "error", { key: 0 }, () => [Q("div", { class: O(i(s).e("error")) }, Be(i(r)("el.image.error")), 3)]) : (k(), z(Qe, { key: 1 }, [u.value !== void 0 ? (k(), z("img", Ct({ key: 0 }, i(a), { src: u.value, loading: j.loading, style: i(b), class: i(y), onClick: te, onLoad: I, onError: L }), null, 16, m7)) : pe("v-if", !0), d.value ? (k(), z("div", { key: 1, class: O(i(s).e("wrapper")) }, [ke(j.$slots, "placeholder", {}, () => [Q("div", { class: O(i(s).e("placeholder")) }, null, 2)])], 2)) : pe("v-if", !0)], 64)), i(w) ? (k(), z(Qe, { key: 2 }, [f.value ? (k(), ge(i(d2), { key: 0, "z-index": j.zIndex, "initial-index": i(T), infinite: j.infinite, "zoom-rate": j.zoomRate, "url-list": j.previewSrcList, "hide-on-click-modal": j.hideOnClickModal, teleported: j.previewTeleported, "close-on-press-escape": j.closeOnPressEscape, onClose: U, onSwitch: D }, { default: ie(() => [j.$slots.viewer ? (k(), z("div", g7, [ke(j.$slots, "viewer")])) : pe("v-if", !0)]), _: 3 }, 8, ["z-index", "initial-index", "infinite", "zoom-rate", "url-list", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : pe("v-if", !0)], 64)) : pe("v-if", !0)], 6)); } });
var w7 = Fe(b7, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image/src/image.vue"]]);
const C7 = vt(w7), S7 = Ve({ id: { type: String, default: void 0 }, step: { type: Number, default: 1 }, stepStrictly: Boolean, max: { type: Number, default: Number.POSITIVE_INFINITY }, min: { type: Number, default: Number.NEGATIVE_INFINITY }, modelValue: Number, readonly: Boolean, disabled: Boolean, size: Bn, controls: { type: Boolean, default: !0 }, controlsPosition: { type: String, default: "", values: ["", "right"] }, valueOnClear: { type: [String, Number, null], validator: e => e === null || lt(e) || ["min", "max"].includes(e), default: null }, name: String, label: String, placeholder: String, precision: { type: Number, validator: e => e >= 0 && e === Number.parseInt(`${e}`, 10) }, validateEvent: { type: Boolean, default: !0 } }), _7 = { [en]: (e, t) => t !== e, blur: e => e instanceof FocusEvent, focus: e => e instanceof FocusEvent, [qn]: e => lt(e) || bn(e), [gt]: e => lt(e) || bn(e) }, k7 = ["aria-label", "onKeydown"], E7 = ["aria-label", "onKeydown"], $7 = ae({ name: "ElInputNumber" }), T7 = ae({ ...$7, props: S7, emits: _7, setup(e, { expose: t, emit: n }) { const o = e, { t: r } = Nt(), s = Ie("input-number"), l = M(), a = Lt({ currentValue: o.modelValue, userInput: null }), { formItem: u } = Zn(), c = S(() => lt(o.modelValue) && o.modelValue <= o.min), d = S(() => lt(o.modelValue) && o.modelValue >= o.max), f = S(() => { const R = y(o.step); return En(o.precision) ? Math.max(y(o.modelValue), R) : (R > o.precision, o.precision); }), p = S(() => o.controls && o.controlsPosition === "right"), v = kn(), m = uo(), h = S(() => { if (a.userInput !== null)
        return a.userInput; let R = a.currentValue; if (bn(R))
        return ""; if (lt(R)) {
        if (Number.isNaN(R))
            return "";
        En(o.precision) || (R = R.toFixed(o.precision));
    } return R; }), g = (R, K) => { if (En(K) && (K = f.value), K === 0)
        return Math.round(R); let te = String(R); const U = te.indexOf("."); if (U === -1 || !te.replace(".", "").split("")[U + K])
        return R; const A = te.length; return te.charAt(A - 1) === "5" && (te = `${te.slice(0, Math.max(0, A - 1))}6`), Number.parseFloat(Number(te).toFixed(K)); }, y = R => { if (bn(R))
        return 0; const K = R.toString(), te = K.indexOf("."); let U = 0; return te !== -1 && (U = K.length - te - 1), U; }, C = (R, K = 1) => lt(R) ? g(R + o.step * K) : a.currentValue, b = () => { if (o.readonly || m.value || d.value)
        return; const R = Number(h.value) || 0, K = C(R); E(K), n(qn, a.currentValue); }, w = () => { if (o.readonly || m.value || c.value)
        return; const R = Number(h.value) || 0, K = C(R, -1); E(K), n(qn, a.currentValue); }, T = (R, K) => { const { max: te, min: U, step: D, precision: j, stepStrictly: A, valueOnClear: G } = o; te < U && _n("InputNumber", "min should not be greater than max."); let se = Number(R); if (bn(R) || Number.isNaN(se))
        return null; if (R === "") {
        if (G === null)
            return null;
        se = it(G) ? { min: U, max: te }[G] : G;
    } return A && (se = g(Math.round(se / D) * D, j)), En(j) || (se = g(se, j)), (se > te || se < U) && (se = se > te ? te : U, K && n(gt, se)), se; }, E = (R, K = !0) => { var te; const U = a.currentValue, D = T(R); if (!K) {
        n(gt, D);
        return;
    } U !== D && (a.userInput = null, n(gt, D), n(en, D, U), o.validateEvent && ((te = u == null ? void 0 : u.validate) == null || te.call(u, "change").catch(j => void 0)), a.currentValue = D); }, x = R => { a.userInput = R; const K = R === "" ? null : Number(R); n(qn, K), E(K, !1); }, I = R => { const K = R !== "" ? Number(R) : ""; (lt(K) && !Number.isNaN(K) || R === "") && E(K), a.userInput = null; }, L = () => { var R, K; (K = (R = l.value) == null ? void 0 : R.focus) == null || K.call(R); }, B = () => { var R, K; (K = (R = l.value) == null ? void 0 : R.blur) == null || K.call(R); }, F = R => { n("focus", R); }, V = R => { var K; n("blur", R), o.validateEvent && ((K = u == null ? void 0 : u.validate) == null || K.call(u, "blur").catch(te => void 0)); }; return Oe(() => o.modelValue, R => { const K = T(a.userInput), te = T(R, !0); !lt(K) && (!K || K !== te) && (a.currentValue = te, a.userInput = null); }, { immediate: !0 }), ft(() => { var R; const { min: K, max: te, modelValue: U } = o, D = (R = l.value) == null ? void 0 : R.input; if (D.setAttribute("role", "spinbutton"), Number.isFinite(te) ? D.setAttribute("aria-valuemax", String(te)) : D.removeAttribute("aria-valuemax"), Number.isFinite(K) ? D.setAttribute("aria-valuemin", String(K)) : D.removeAttribute("aria-valuemin"), D.setAttribute("aria-valuenow", String(a.currentValue)), D.setAttribute("aria-disabled", String(m.value)), !lt(U) && U != null) {
        let j = Number(U);
        Number.isNaN(j) && (j = null), n(gt, j);
    } }), Er(() => { var R; const K = (R = l.value) == null ? void 0 : R.input; K == null || K.setAttribute("aria-valuenow", `${a.currentValue}`); }), t({ focus: L, blur: B }), (R, K) => (k(), z("div", { class: O([i(s).b(), i(s).m(i(v)), i(s).is("disabled", i(m)), i(s).is("without-controls", !R.controls), i(s).is("controls-right", i(p))]), onDragstart: K[1] || (K[1] = st(() => { }, ["prevent"])) }, [R.controls ? dt((k(), z("span", { key: 0, role: "button", "aria-label": i(r)("el.inputNumber.decrease"), class: O([i(s).e("decrease"), i(s).is("disabled", i(c))]), onKeydown: Mt(w, ["enter"]) }, [ee(i(Je), null, { default: ie(() => [i(p) ? (k(), ge(i(ss), { key: 0 })) : (k(), ge(i(JN), { key: 1 }))]), _: 1 })], 42, k7)), [[i(Yu), w]]) : pe("v-if", !0), R.controls ? dt((k(), z("span", { key: 1, role: "button", "aria-label": i(r)("el.inputNumber.increase"), class: O([i(s).e("increase"), i(s).is("disabled", i(d))]), onKeydown: Mt(b, ["enter"]) }, [ee(i(Je), null, { default: ie(() => [i(p) ? (k(), ge(i(Ic), { key: 0 })) : (k(), ge(i(N1), { key: 1 }))]), _: 1 })], 42, E7)), [[i(Yu), b]]) : pe("v-if", !0), ee(i(Ln), { id: R.id, ref_key: "input", ref: l, type: "number", step: R.step, "model-value": i(h), placeholder: R.placeholder, readonly: R.readonly, disabled: i(m), size: i(v), max: R.max, min: R.min, name: R.name, label: R.label, "validate-event": !1, onWheel: K[0] || (K[0] = st(() => { }, ["prevent"])), onKeydown: [Mt(st(b, ["prevent"]), ["up"]), Mt(st(w, ["prevent"]), ["down"])], onBlur: V, onFocus: F, onInput: x, onChange: I }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])], 34)); } });
var O7 = Fe(T7, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]);
const f2 = vt(O7), I7 = Ve({ type: { type: String, values: ["primary", "success", "warning", "info", "danger", "default"], default: "default" }, underline: { type: Boolean, default: !0 }, disabled: { type: Boolean, default: !1 }, href: { type: String, default: "" }, icon: { type: Zt } }), x7 = { click: e => e instanceof MouseEvent }, A7 = ["href"], M7 = ae({ name: "ElLink" }), N7 = ae({ ...M7, props: I7, emits: x7, setup(e, { emit: t }) { const n = e, o = Ie("link"), r = S(() => [o.b(), o.m(n.type), o.is("disabled", n.disabled), o.is("underline", n.underline && !n.disabled)]); function s(l) { n.disabled || t("click", l); } return (l, a) => (k(), z("a", { class: O(i(r)), href: l.disabled || !l.href ? void 0 : l.href, onClick: s }, [l.icon ? (k(), ge(i(Je), { key: 0 }, { default: ie(() => [(k(), ge(kt(l.icon)))]), _: 1 })) : pe("v-if", !0), l.$slots.default ? (k(), z("span", { key: 1, class: O(i(o).e("inner")) }, [ke(l.$slots, "default")], 2)) : pe("v-if", !0), l.$slots.icon ? ke(l.$slots, "icon", { key: 2 }) : pe("v-if", !0)], 10, A7)); } });
var P7 = Fe(N7, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/link/src/link.vue"]]);
const R7 = vt(P7);
let L7 = class {
    constructor(t, n) { this.parent = t, this.domNode = n, this.subIndex = 0, this.subIndex = 0, this.init(); }
    init() { this.subMenuItems = this.domNode.querySelectorAll("li"), this.addListeners(); }
    gotoSubIndex(t) { t === this.subMenuItems.length ? t = 0 : t < 0 && (t = this.subMenuItems.length - 1), this.subMenuItems[t].focus(), this.subIndex = t; }
    addListeners() { const t = this.parent.domNode; Array.prototype.forEach.call(this.subMenuItems, n => { n.addEventListener("keydown", o => { let r = !1; switch (o.code) {
        case tt.down: {
            this.gotoSubIndex(this.subIndex + 1), r = !0;
            break;
        }
        case tt.up: {
            this.gotoSubIndex(this.subIndex - 1), r = !0;
            break;
        }
        case tt.tab: {
            iu(t, "mouseleave");
            break;
        }
        case tt.enter:
        case tt.space: {
            r = !0, o.currentTarget.click();
            break;
        }
    } return r && (o.preventDefault(), o.stopPropagation()), !1; }); }); }
}, D7 = class {
    constructor(t, n) { this.domNode = t, this.submenu = null, this.submenu = null, this.init(n); }
    init(t) { this.domNode.setAttribute("tabindex", "0"); const n = this.domNode.querySelector(`.${t}-menu`); n && (this.submenu = new L7(this, n)), this.addListeners(); }
    addListeners() { this.domNode.addEventListener("keydown", t => { let n = !1; switch (t.code) {
        case tt.down: {
            iu(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(0), n = !0;
            break;
        }
        case tt.up: {
            iu(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1), n = !0;
            break;
        }
        case tt.tab: {
            iu(t.currentTarget, "mouseleave");
            break;
        }
        case tt.enter:
        case tt.space: {
            n = !0, t.currentTarget.click();
            break;
        }
    } n && t.preventDefault(); }); }
}, B7 = class {
    constructor(t, n) { this.domNode = t, this.init(n); }
    init(t) { const n = this.domNode.childNodes; Array.from(n).forEach(o => { o.nodeType === 1 && new D7(o, t); }); }
};
const F7 = ae({ name: "ElMenuCollapseTransition", setup() { const e = Ie("menu"); return { listeners: { onBeforeEnter: n => n.style.opacity = "0.2", onEnter(n, o) { Jo(n, `${e.namespace.value}-opacity-transition`), n.style.opacity = "1", o(); }, onAfterEnter(n) { so(n, `${e.namespace.value}-opacity-transition`), n.style.opacity = ""; }, onBeforeLeave(n) { n.dataset || (n.dataset = {}), Vo(n, e.m("collapse")) ? (so(n, e.m("collapse")), n.dataset.oldOverflow = n.style.overflow, n.dataset.scrollWidth = n.clientWidth.toString(), Jo(n, e.m("collapse"))) : (Jo(n, e.m("collapse")), n.dataset.oldOverflow = n.style.overflow, n.dataset.scrollWidth = n.clientWidth.toString(), so(n, e.m("collapse"))), n.style.width = `${n.scrollWidth}px`, n.style.overflow = "hidden"; }, onLeave(n) { Jo(n, "horizontal-collapse-transition"), n.style.width = `${n.dataset.scrollWidth}px`; } } }; } });
function V7(e, t, n, o, r, s) { return k(), ge(yn, Ct({ mode: "out-in" }, e.listeners), { default: ie(() => [ke(e.$slots, "default")]), _: 3 }, 16); }
var z7 = Fe(F7, [["render", V7], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-collapse-transition.vue"]]);
function p2(e, t) { const n = S(() => { let r = e.parent; const s = [t.value]; for (; r.type.name !== "ElMenu";)
    r.props.index && s.unshift(r.props.index), r = r.parent; return s; }); return { parentMenu: S(() => { let r = e.parent; for (; r && !["ElMenu", "ElSubMenu"].includes(r.type.name);)
        r = r.parent; return r; }), indexPath: n }; }
function H7(e) { return S(() => { const n = e.backgroundColor; return n ? new jw(n).shade(20).toString() : ""; }); }
const h2 = (e, t) => { const n = Ie("menu"); return S(() => n.cssVarBlock({ "text-color": e.textColor || "", "hover-text-color": e.textColor || "", "bg-color": e.backgroundColor || "", "hover-bg-color": H7(e).value || "", "active-color": e.activeTextColor || "", level: `${t}` })); }, K7 = Ve({ index: { type: String, required: !0 }, showTimeout: { type: Number, default: 300 }, hideTimeout: { type: Number, default: 300 }, popperClass: String, disabled: Boolean, popperAppendToBody: { type: Boolean, default: void 0 }, teleported: { type: Boolean, default: void 0 }, popperOffset: { type: Number, default: 6 }, expandCloseIcon: { type: Zt }, expandOpenIcon: { type: Zt }, collapseCloseIcon: { type: Zt }, collapseOpenIcon: { type: Zt } }), eu = "ElSubMenu";
var Kh = ae({ name: eu, props: K7, setup(e, { slots: t, expose: n }) { tr({ from: "popper-append-to-body", replacement: "teleported", scope: eu, version: "2.3.0", ref: "https://element-plus.org/en-US/component/menu.html#submenu-attributes" }, S(() => e.popperAppendToBody !== void 0)); const o = ht(), { indexPath: r, parentMenu: s } = p2(o, S(() => e.index)), l = Ie("menu"), a = Ie("sub-menu"), u = Ye("rootMenu"); u || _n(eu, "can not inject root menu"); const c = Ye(`subMenu:${s.value.uid}`); c || _n(eu, "can not inject sub menu"); const d = M({}), f = M({}); let p; const v = M(!1), m = M(), h = M(null), g = S(() => F.value === "horizontal" && C.value ? "bottom-start" : "right-start"), y = S(() => F.value === "horizontal" && C.value || F.value === "vertical" && !u.props.collapse ? e.expandCloseIcon && e.expandOpenIcon ? E.value ? e.expandOpenIcon : e.expandCloseIcon : ss : e.collapseCloseIcon && e.collapseOpenIcon ? E.value ? e.collapseOpenIcon : e.collapseCloseIcon : Un), C = S(() => c.level === 0), b = S(() => { var G; const se = (G = e.teleported) != null ? G : e.popperAppendToBody; return se === void 0 ? C.value : se; }), w = S(() => u.props.collapse ? `${l.namespace.value}-zoom-in-left` : `${l.namespace.value}-zoom-in-top`), T = S(() => F.value === "horizontal" && C.value ? ["bottom-start", "bottom-end", "top-start", "top-end", "right-start", "left-start"] : ["right-start", "left-start", "bottom-start", "bottom-end", "top-start", "top-end"]), E = S(() => u.openedMenus.includes(e.index)), x = S(() => { let G = !1; return Object.values(d.value).forEach(se => { se.active && (G = !0); }), Object.values(f.value).forEach(se => { se.active && (G = !0); }), G; }), I = S(() => u.props.backgroundColor || ""), L = S(() => u.props.activeTextColor || ""), B = S(() => u.props.textColor || ""), F = S(() => u.props.mode), V = Lt({ index: e.index, indexPath: r, active: x }), R = h2(u.props, c.level + 1), K = S(() => F.value !== "horizontal" ? { color: B.value } : { borderBottomColor: x.value ? u.props.activeTextColor ? L.value : "" : "transparent", color: x.value ? L.value : B.value }), te = () => { var G, se, Z; return (Z = (se = (G = h.value) == null ? void 0 : G.popperRef) == null ? void 0 : se.popperInstanceRef) == null ? void 0 : Z.destroy(); }, U = G => { G || te(); }, D = () => { u.props.menuTrigger === "hover" && u.props.mode === "horizontal" || u.props.collapse && u.props.mode === "vertical" || e.disabled || u.handleSubMenuClick({ index: e.index, indexPath: r.value, active: x.value }); }, j = (G, se = e.showTimeout) => { var Z; G.type !== "focus" && (u.props.menuTrigger === "click" && u.props.mode === "horizontal" || !u.props.collapse && u.props.mode === "vertical" || e.disabled || (c.mouseInChild.value = !0, p == null || p(), { stop: p } = Vs(() => { u.openMenu(e.index, r.value); }, se), b.value && ((Z = s.value.vnode.el) == null || Z.dispatchEvent(new MouseEvent("mouseenter"))))); }, A = (G = !1) => { var se, Z; u.props.menuTrigger === "click" && u.props.mode === "horizontal" || !u.props.collapse && u.props.mode === "vertical" || (p == null || p(), c.mouseInChild.value = !1, { stop: p } = Vs(() => !v.value && u.closeMenu(e.index, r.value), e.hideTimeout), b.value && G && ((se = o.parent) == null ? void 0 : se.type.name) === "ElSubMenu" && ((Z = c.handleMouseleave) == null || Z.call(c, !0))); }; Oe(() => u.props.collapse, G => U(!!G)); {
        const G = Z => { f.value[Z.index] = Z; }, se = Z => { delete f.value[Z.index]; };
        St(`subMenu:${o.uid}`, { addSubMenu: G, removeSubMenu: se, handleMouseleave: A, mouseInChild: v, level: c.level + 1 });
    } return n({ opened: E }), ft(() => { u.addSubMenu(V), c.addSubMenu(V); }), on(() => { c.removeSubMenu(V), u.removeSubMenu(V); }), () => { var G; const se = [(G = t.title) == null ? void 0 : G.call(t), nt(Je, { class: a.e("icon-arrow"), style: { transform: E.value ? e.expandCloseIcon && e.expandOpenIcon || e.collapseCloseIcon && e.collapseOpenIcon && u.props.collapse ? "none" : "rotateZ(180deg)" : "none" } }, { default: () => it(y.value) ? nt(o.appContext.components[y.value]) : nt(y.value) })], Z = u.isMenuPopup ? nt(Jn, { ref: h, visible: E.value, effect: "light", pure: !0, offset: e.popperOffset, showArrow: !1, persistent: !0, popperClass: e.popperClass, placement: g.value, teleported: b.value, fallbackPlacements: T.value, transition: w.value, gpuAcceleration: !1 }, { content: () => { var ce; return nt("div", { class: [l.m(F.value), l.m("popup-container"), e.popperClass], onMouseenter: ye => j(ye, 100), onMouseleave: () => A(!0), onFocus: ye => j(ye, 100) }, [nt("ul", { class: [l.b(), l.m("popup"), l.m(`popup-${g.value}`)], style: R.value }, [(ce = t.default) == null ? void 0 : ce.call(t)])]); }, default: () => nt("div", { class: a.e("title"), style: [K.value, { backgroundColor: I.value }], onClick: D }, se) }) : nt(Qe, {}, [nt("div", { class: a.e("title"), style: [K.value, { backgroundColor: I.value }], ref: m, onClick: D }, se), nt(jc, {}, { default: () => { var ce; return dt(nt("ul", { role: "menu", class: [l.b(), l.m("inline")], style: R.value }, [(ce = t.default) == null ? void 0 : ce.call(t)]), [[Pt, E.value]]); } })]); return nt("li", { class: [a.b(), a.is("active", x.value), a.is("opened", E.value), a.is("disabled", e.disabled)], role: "menuitem", ariaHaspopup: !0, ariaExpanded: E.value, onMouseenter: j, onMouseleave: () => A(!0), onFocus: j }, [Z]); }; } });
const j7 = Ve({ mode: { type: String, values: ["horizontal", "vertical"], default: "vertical" }, defaultActive: { type: String, default: "" }, defaultOpeneds: { type: ve(Array), default: () => ln([]) }, uniqueOpened: Boolean, router: Boolean, menuTrigger: { type: String, values: ["hover", "click"], default: "hover" }, collapse: Boolean, backgroundColor: String, textColor: String, activeTextColor: String, collapseTransition: { type: Boolean, default: !0 }, ellipsis: { type: Boolean, default: !0 }, popperEffect: { type: String, values: ["dark", "light"], default: "dark" } }), Pd = e => Array.isArray(e) && e.every(t => it(t)), W7 = { close: (e, t) => it(e) && Pd(t), open: (e, t) => it(e) && Pd(t), select: (e, t, n, o) => it(e) && Pd(t) && yt(n) && (o === void 0 || o instanceof Promise) };
var U7 = ae({ name: "ElMenu", props: j7, emits: W7, setup(e, { emit: t, slots: n, expose: o }) { const r = ht(), s = r.appContext.config.globalProperties.$router, l = M(), a = Ie("menu"), u = Ie("sub-menu"), c = M(-1), d = M(e.defaultOpeneds && !e.collapse ? e.defaultOpeneds.slice(0) : []), f = M(e.defaultActive), p = M({}), v = M({}), m = S(() => e.mode === "horizontal" || e.mode === "vertical" && e.collapse), h = () => { const F = f.value && p.value[f.value]; if (!F || e.mode === "horizontal" || e.collapse)
        return; F.indexPath.forEach(R => { const K = v.value[R]; K && g(R, K.indexPath); }); }, g = (F, V) => { d.value.includes(F) || (e.uniqueOpened && (d.value = d.value.filter(R => V.includes(R))), d.value.push(F), t("open", F, V)); }, y = F => { const V = d.value.indexOf(F); V !== -1 && d.value.splice(V, 1); }, C = (F, V) => { y(F), t("close", F, V); }, b = ({ index: F, indexPath: V }) => { d.value.includes(F) ? C(F, V) : g(F, V); }, w = F => { (e.mode === "horizontal" || e.collapse) && (d.value = []); const { index: V, indexPath: R } = F; if (!(bn(V) || bn(R)))
        if (e.router && s) {
            const K = F.route || V, te = s.push(K).then(U => (U || (f.value = V), U));
            t("select", V, R, { index: V, indexPath: R, route: K }, te);
        }
        else
            f.value = V, t("select", V, R, { index: V, indexPath: R }); }, T = F => { const V = p.value, R = V[F] || f.value && V[f.value] || V[e.defaultActive]; R ? f.value = R.index : f.value = F; }, E = () => { var F, V; if (!l.value)
        return -1; const R = Array.from((V = (F = l.value) == null ? void 0 : F.childNodes) != null ? V : []).filter(G => G.nodeName !== "#comment" && (G.nodeName !== "#text" || G.nodeValue)), K = 64, te = Number.parseInt(getComputedStyle(l.value).paddingLeft, 10), U = Number.parseInt(getComputedStyle(l.value).paddingRight, 10), D = l.value.clientWidth - te - U; let j = 0, A = 0; return R.forEach((G, se) => { j += G.offsetWidth || 0, j <= D - K && (A = se + 1); }), A === R.length ? -1 : A; }, x = (F, V = 33.34) => { let R; return () => { R && clearTimeout(R), R = setTimeout(() => { F(); }, V); }; }; let I = !0; const L = () => { const F = () => { c.value = -1, Xe(() => { c.value = E(); }); }; I ? F() : x(F)(), I = !1; }; Oe(() => e.defaultActive, F => { p.value[F] || (f.value = ""), T(F); }), Oe(() => e.collapse, F => { F && (d.value = []); }), Oe(p.value, h); let B; mo(() => { e.mode === "horizontal" && e.ellipsis ? B = Vn(l, L).stop : B == null || B(); }); {
        const F = te => { v.value[te.index] = te; }, V = te => { delete v.value[te.index]; };
        St("rootMenu", Lt({ props: e, openedMenus: d, items: p, subMenus: v, activeIndex: f, isMenuPopup: m, addMenuItem: te => { p.value[te.index] = te; }, removeMenuItem: te => { delete p.value[te.index]; }, addSubMenu: F, removeSubMenu: V, openMenu: g, closeMenu: C, handleMenuItemClick: w, handleSubMenuClick: b })), St(`subMenu:${r.uid}`, { addSubMenu: F, removeSubMenu: V, mouseInChild: M(!1), level: 0 });
    } return ft(() => { e.mode === "horizontal" && new B7(r.vnode.el, a.namespace.value); }), o({ open: V => { const { indexPath: R } = v.value[V]; R.forEach(K => g(K, R)); }, close: y, handleResize: L }), () => { var F, V; let R = (V = (F = n.default) == null ? void 0 : F.call(n)) != null ? V : []; const K = []; if (e.mode === "horizontal" && l.value) {
        const D = ml(R), j = c.value === -1 ? D : D.slice(0, c.value), A = c.value === -1 ? [] : D.slice(c.value);
        A != null && A.length && e.ellipsis && (R = j, K.push(nt(Kh, { index: "sub-menu-more", class: u.e("hide-arrow") }, { title: () => nt(Je, { class: u.e("icon-more") }, { default: () => nt(iP) }), default: () => A })));
    } const te = h2(e, 0), U = nt("ul", { key: String(e.collapse), role: "menubar", ref: l, style: te.value, class: { [a.b()]: !0, [a.m(e.mode)]: !0, [a.m("collapse")]: e.collapse } }, [...R, ...K]); return e.collapseTransition && e.mode === "vertical" ? nt(z7, () => U) : U; }; } });
const q7 = Ve({ index: { type: ve([String, null]), default: null }, route: { type: ve([String, Object]) }, disabled: Boolean }), Y7 = { click: e => it(e.index) && Array.isArray(e.indexPath) }, Rd = "ElMenuItem", G7 = ae({ name: Rd, components: { ElTooltip: Jn }, props: q7, emits: Y7, setup(e, { emit: t }) { const n = ht(), o = Ye("rootMenu"), r = Ie("menu"), s = Ie("menu-item"); o || _n(Rd, "can not inject root menu"); const { parentMenu: l, indexPath: a } = p2(n, an(e, "index")), u = Ye(`subMenu:${l.value.uid}`); u || _n(Rd, "can not inject sub menu"); const c = S(() => e.index === o.activeIndex), d = Lt({ index: e.index, indexPath: a, active: c }), f = () => { e.disabled || (o.handleMenuItemClick({ index: e.index, indexPath: a.value, route: e.route }), t("click", d)); }; return ft(() => { u.addSubMenu(d), o.addMenuItem(d); }), on(() => { u.removeSubMenu(d), o.removeMenuItem(d); }), { parentMenu: l, rootMenu: o, active: c, nsMenu: r, nsMenuItem: s, handleClick: f }; } });
function X7(e, t, n, o, r, s) { const l = ct("el-tooltip"); return k(), z("li", { class: O([e.nsMenuItem.b(), e.nsMenuItem.is("active", e.active), e.nsMenuItem.is("disabled", e.disabled)]), role: "menuitem", tabindex: "-1", onClick: t[0] || (t[0] = (...a) => e.handleClick && e.handleClick(...a)) }, [e.parentMenu.type.name === "ElMenu" && e.rootMenu.props.collapse && e.$slots.title ? (k(), ge(l, { key: 0, effect: e.rootMenu.props.popperEffect, placement: "right", "fallback-placements": ["left"], persistent: "" }, { content: ie(() => [ke(e.$slots, "title")]), default: ie(() => [Q("div", { class: O(e.nsMenu.be("tooltip", "trigger")) }, [ke(e.$slots, "default")], 2)]), _: 3 }, 8, ["effect"])) : (k(), z(Qe, { key: 1 }, [ke(e.$slots, "default"), ke(e.$slots, "title")], 64))], 2); }
var v2 = Fe(G7, [["render", X7], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item.vue"]]);
const J7 = { title: String }, Z7 = "ElMenuItemGroup", Q7 = ae({ name: Z7, props: J7, setup() { return { ns: Ie("menu-item-group") }; } });
function eW(e, t, n, o, r, s) { return k(), z("li", { class: O(e.ns.b()) }, [Q("div", { class: O(e.ns.e("title")) }, [e.$slots.title ? ke(e.$slots, "title", { key: 1 }) : (k(), z(Qe, { key: 0 }, [Ot(Be(e.title), 1)], 64))], 2), Q("ul", null, [ke(e.$slots, "default")])], 2); }
var m2 = Fe(Q7, [["render", eW], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item-group.vue"]]);
const tW = vt(U7, { MenuItem: v2, MenuItemGroup: m2, SubMenu: Kh }), nW = pn(v2), oW = pn(m2), rW = pn(Kh), sW = Ve({ icon: { type: Zt, default: () => JM }, title: String, content: { type: String, default: "" } }), lW = { back: () => !0 }, aW = ["aria-label"], iW = ae({ name: "ElPageHeader" }), uW = ae({ ...iW, props: sW, emits: lW, setup(e, { emit: t }) { const n = An(), { t: o } = Nt(), r = Ie("page-header"), s = S(() => [r.b(), { [r.m("has-breadcrumb")]: !!n.breadcrumb, [r.m("has-extra")]: !!n.extra, [r.is("contentful")]: !!n.default }]); function l() { t("back"); } return (a, u) => (k(), z("div", { class: O(i(s)) }, [a.$slots.breadcrumb ? (k(), z("div", { key: 0, class: O(i(r).e("breadcrumb")) }, [ke(a.$slots, "breadcrumb")], 2)) : pe("v-if", !0), Q("div", { class: O(i(r).e("header")) }, [Q("div", { class: O(i(r).e("left")) }, [Q("div", { class: O(i(r).e("back")), role: "button", tabindex: "0", onClick: l }, [a.icon || a.$slots.icon ? (k(), z("div", { key: 0, "aria-label": a.title || i(o)("el.pageHeader.title"), class: O(i(r).e("icon")) }, [ke(a.$slots, "icon", {}, () => [a.icon ? (k(), ge(i(Je), { key: 0 }, { default: ie(() => [(k(), ge(kt(a.icon)))]), _: 1 })) : pe("v-if", !0)])], 10, aW)) : pe("v-if", !0), Q("div", { class: O(i(r).e("title")) }, [ke(a.$slots, "title", {}, () => [Ot(Be(a.title || i(o)("el.pageHeader.title")), 1)])], 2)], 2), ee(i(t2), { direction: "vertical" }), Q("div", { class: O(i(r).e("content")) }, [ke(a.$slots, "content", {}, () => [Ot(Be(a.content), 1)])], 2)], 2), a.$slots.extra ? (k(), z("div", { key: 0, class: O(i(r).e("extra")) }, [ke(a.$slots, "extra")], 2)) : pe("v-if", !0)], 2), a.$slots.default ? (k(), z("div", { key: 1, class: O(i(r).e("main")) }, [ke(a.$slots, "default")], 2)) : pe("v-if", !0)], 2)); } });
var cW = Fe(uW, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/page-header/src/page-header.vue"]]);
const dW = vt(cW), g2 = Symbol("elPaginationKey"), fW = Ve({ disabled: Boolean, currentPage: { type: Number, default: 1 }, prevText: { type: String }, prevIcon: { type: Zt } }), pW = { click: e => e instanceof MouseEvent }, hW = ["disabled", "aria-label", "aria-disabled"], vW = { key: 0 }, mW = ae({ name: "ElPaginationPrev" }), gW = ae({ ...mW, props: fW, emits: pW, setup(e) { const t = e, { t: n } = Nt(), o = S(() => t.disabled || t.currentPage <= 1); return (r, s) => (k(), z("button", { type: "button", class: "btn-prev", disabled: i(o), "aria-label": r.prevText || i(n)("el.pagination.prev"), "aria-disabled": i(o), onClick: s[0] || (s[0] = l => r.$emit("click", l)) }, [r.prevText ? (k(), z("span", vW, Be(r.prevText), 1)) : (k(), ge(i(Je), { key: 1 }, { default: ie(() => [(k(), ge(kt(r.prevIcon)))]), _: 1 }))], 8, hW)); } });
var yW = Fe(gW, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/prev.vue"]]);
const bW = Ve({ disabled: Boolean, currentPage: { type: Number, default: 1 }, pageCount: { type: Number, default: 50 }, nextText: { type: String }, nextIcon: { type: Zt } }), wW = ["disabled", "aria-label", "aria-disabled"], CW = { key: 0 }, SW = ae({ name: "ElPaginationNext" }), _W = ae({ ...SW, props: bW, emits: ["click"], setup(e) { const t = e, { t: n } = Nt(), o = S(() => t.disabled || t.currentPage === t.pageCount || t.pageCount === 0); return (r, s) => (k(), z("button", { type: "button", class: "btn-next", disabled: i(o), "aria-label": r.nextText || i(n)("el.pagination.next"), "aria-disabled": i(o), onClick: s[0] || (s[0] = l => r.$emit("click", l)) }, [r.nextText ? (k(), z("span", CW, Be(r.nextText), 1)) : (k(), ge(i(Je), { key: 1 }, { default: ie(() => [(k(), ge(kt(r.nextIcon)))]), _: 1 }))], 8, wW)); } });
var kW = Fe(_W, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/next.vue"]]);
const y2 = Symbol("ElSelectGroup"), Ti = Symbol("ElSelect");
function EW(e, t) { const n = Ye(Ti), o = Ye(y2, { disabled: !1 }), r = S(() => Object.prototype.toString.call(e.value).toLowerCase() === "[object object]"), s = S(() => n.props.multiple ? f(n.props.modelValue, e.value) : p(e.value, n.props.modelValue)), l = S(() => { if (n.props.multiple) {
    const h = n.props.modelValue || [];
    return !s.value && h.length >= n.props.multipleLimit && n.props.multipleLimit > 0;
}
else
    return !1; }), a = S(() => e.label || (r.value ? "" : e.value)), u = S(() => e.value || e.label || ""), c = S(() => e.disabled || t.groupDisabled || l.value), d = ht(), f = (h = [], g) => { if (r.value) {
    const y = n.props.valueKey;
    return h && h.some(C => Bt(sn(C, y)) === sn(g, y));
}
else
    return h && h.includes(g); }, p = (h, g) => { if (r.value) {
    const { valueKey: y } = n.props;
    return sn(h, y) === sn(g, y);
}
else
    return h === g; }, v = () => { !e.disabled && !o.disabled && (n.hoverIndex = n.optionsArray.indexOf(d.proxy)); }; Oe(() => a.value, () => { !e.created && !n.props.remote && n.setSelected(); }), Oe(() => e.value, (h, g) => { const { remote: y, valueKey: C } = n.props; if (Object.is(h, g) || (n.onOptionDestroy(g, d.proxy), n.onOptionCreate(d.proxy)), !e.created && !y) {
    if (C && typeof h == "object" && typeof g == "object" && h[C] === g[C])
        return;
    n.setSelected();
} }), Oe(() => o.disabled, () => { t.groupDisabled = o.disabled; }, { immediate: !0 }); const { queryChange: m } = Bt(n); return Oe(m, h => { const { query: g } = i(h), y = new RegExp(T1(g), "i"); t.visible = y.test(a.value) || e.created, t.visible || n.filteredOptionsCount--; }, { immediate: !0 }), { select: n, currentLabel: a, currentValue: u, itemSelected: s, isDisabled: c, hoverItem: v }; }
const $W = ae({ name: "ElOption", componentName: "ElOption", props: { value: { required: !0, type: [String, Number, Boolean, Object] }, label: [String, Number], created: Boolean, disabled: { type: Boolean, default: !1 } }, setup(e) { const t = Ie("select"), n = S(() => [t.be("dropdown", "item"), t.is("disabled", i(l)), { selected: i(s), hover: i(d) }]), o = Lt({ index: -1, groupDisabled: !1, visible: !0, hitState: !1, hover: !1 }), { currentLabel: r, itemSelected: s, isDisabled: l, select: a, hoverItem: u } = EW(e, o), { visible: c, hover: d } = Sn(o), f = ht().proxy; a.onOptionCreate(f), on(() => { const v = f.value, { selected: m } = a, g = (a.props.multiple ? m : [m]).some(y => y.value === f.value); Xe(() => { a.cachedOptions.get(v) === f && !g && a.cachedOptions.delete(v); }), a.onOptionDestroy(v, f); }); function p() { e.disabled !== !0 && o.groupDisabled !== !0 && a.handleOptionSelect(f); } return { ns: t, containerKls: n, currentLabel: r, itemSelected: s, isDisabled: l, select: a, hoverItem: u, visible: c, hover: d, selectOptionClick: p, states: o }; } });
function TW(e, t, n, o, r, s) { return dt((k(), z("li", { class: O(e.containerKls), onMouseenter: t[0] || (t[0] = (...l) => e.hoverItem && e.hoverItem(...l)), onClick: t[1] || (t[1] = st((...l) => e.selectOptionClick && e.selectOptionClick(...l), ["stop"])) }, [ke(e.$slots, "default", {}, () => [Q("span", null, Be(e.currentLabel), 1)])], 34)), [[Pt, e.visible]]); }
var jh = Fe($W, [["render", TW], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);
const OW = ae({ name: "ElSelectDropdown", componentName: "ElSelectDropdown", setup() { const e = Ye(Ti), t = Ie("select"), n = S(() => e.props.popperClass), o = S(() => e.props.multiple), r = S(() => e.props.fitInputWidth), s = M(""); function l() { var a; s.value = `${(a = e.selectWrapper) == null ? void 0 : a.offsetWidth}px`; } return ft(() => { l(), Vn(e.selectWrapper, l); }), { ns: t, minWidth: s, popperClass: n, isMultiple: o, isFitInputWidth: r }; } });
function IW(e, t, n, o, r, s) { return k(), z("div", { class: O([e.ns.b("dropdown"), e.ns.is("multiple", e.isMultiple), e.popperClass]), style: et({ [e.isFitInputWidth ? "width" : "minWidth"]: e.minWidth }) }, [ke(e.$slots, "default")], 6); }
var xW = Fe(OW, [["render", IW], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);
function AW(e) { const { t } = Nt(); return Lt({ options: new Map, cachedOptions: new Map, createdLabel: null, createdSelected: !1, selected: e.multiple ? [] : {}, inputLength: 20, inputWidth: 0, optionsCount: 0, filteredOptionsCount: 0, visible: !1, selectedLabel: "", hoverIndex: -1, query: "", previousQuery: null, inputHovering: !1, cachedPlaceHolder: "", currentPlaceholder: t("el.select.placeholder"), menuVisibleOnFocus: !1, isOnComposition: !1, prefixWidth: 11, mouseEnter: !1 }); }
let Ld = !1;
const MW = (e, t, n) => { const { t: o } = Nt(), r = Ie("select"); tr({ from: "suffixTransition", replacement: "override style scheme", version: "2.3.0", scope: "props", ref: "https://element-plus.org/en-US/component/select.html#select-attributes" }, S(() => e.suffixTransition === !1)); const s = M(null), l = M(null), a = M(null), u = M(null), c = M(null), d = M(null), f = M(null), p = M(null), v = M(-1), m = Xt({ query: "" }), h = Xt(""), g = M([]); let y = 0; const { form: C, formItem: b } = Zn(), w = S(() => !e.filterable || e.multiple || !t.visible), T = S(() => e.disabled || (C == null ? void 0 : C.disabled)), E = S(() => { const _e = e.multiple ? Array.isArray(e.modelValue) && e.modelValue.length > 0 : e.modelValue !== void 0 && e.modelValue !== null && e.modelValue !== ""; return e.clearable && !T.value && t.inputHovering && _e; }), x = S(() => e.remote && e.filterable && !e.remoteShowSuffix ? "" : e.suffixIcon), I = S(() => r.is("reverse", x.value && t.visible && e.suffixTransition)), L = S(() => e.remote ? 300 : 0), B = S(() => e.loading ? e.loadingText || o("el.select.loading") : e.remote && t.query === "" && t.options.size === 0 ? !1 : e.filterable && t.query && t.options.size > 0 && t.filteredOptionsCount === 0 ? e.noMatchText || o("el.select.noMatch") : t.options.size === 0 ? e.noDataText || o("el.select.noData") : null), F = S(() => { const _e = Array.from(t.options.values()), ze = []; return g.value.forEach(We => { const ut = _e.findIndex(rn => rn.currentLabel === We); ut > -1 && ze.push(_e[ut]); }), ze.length ? ze : _e; }), V = S(() => Array.from(t.cachedOptions.values())), R = S(() => { const _e = F.value.filter(ze => !ze.created).some(ze => ze.currentLabel === t.query); return e.filterable && e.allowCreate && t.query !== "" && !_e; }), K = kn(), te = S(() => ["small"].includes(K.value) ? "small" : "default"), U = S({ get() { return t.visible && B.value !== !1; }, set(_e) { t.visible = _e; } }); Oe([() => T.value, () => K.value, () => C == null ? void 0 : C.size], () => { Xe(() => { D(); }); }), Oe(() => e.placeholder, _e => { t.cachedPlaceHolder = t.currentPlaceholder = _e, e.multiple && Array.isArray(e.modelValue) && e.modelValue.length > 0 && (t.currentPlaceholder = ""); }), Oe(() => e.modelValue, (_e, ze) => { e.multiple && (D(), _e && _e.length > 0 || l.value && t.query !== "" ? t.currentPlaceholder = "" : t.currentPlaceholder = t.cachedPlaceHolder, e.filterable && !e.reserveKeyword && (t.query = "", j(t.query))), se(), e.filterable && !e.multiple && (t.inputLength = 20), !ro(_e, ze) && e.validateEvent && (b == null || b.validate("change").catch(We => void 0)); }, { flush: "post", deep: !0 }), Oe(() => t.visible, _e => { var ze, We, ut, rn, Rt; _e ? ((We = (ze = u.value) == null ? void 0 : ze.updatePopper) == null || We.call(ze), e.filterable && (t.filteredOptionsCount = t.optionsCount, t.query = e.remote ? "" : t.selectedLabel, (rn = (ut = a.value) == null ? void 0 : ut.focus) == null || rn.call(ut), e.multiple ? (Rt = l.value) == null || Rt.focus() : t.selectedLabel && (t.currentPlaceholder = `${t.selectedLabel}`, t.selectedLabel = ""), j(t.query), !e.multiple && !e.remote && (m.value.query = "", oa(m), oa(h)))) : (e.filterable && (at(e.filterMethod) && e.filterMethod(""), at(e.remoteMethod) && e.remoteMethod("")), l.value && l.value.blur(), t.query = "", t.previousQuery = null, t.selectedLabel = "", t.inputLength = 20, t.menuVisibleOnFocus = !1, ce(), Xe(() => { l.value && l.value.value === "" && t.selected.length === 0 && (t.currentPlaceholder = t.cachedPlaceHolder); }), e.multiple || (t.selected && (e.filterable && e.allowCreate && t.createdSelected && t.createdLabel ? t.selectedLabel = t.createdLabel : t.selectedLabel = t.selected.currentLabel, e.filterable && (t.query = t.selectedLabel)), e.filterable && (t.currentPlaceholder = t.cachedPlaceHolder))), n.emit("visible-change", _e); }), Oe(() => t.options.entries(), () => { var _e, ze, We; if (!At)
    return; (ze = (_e = u.value) == null ? void 0 : _e.updatePopper) == null || ze.call(_e), e.multiple && D(); const ut = ((We = f.value) == null ? void 0 : We.querySelectorAll("input")) || []; Array.from(ut).includes(document.activeElement) || se(), e.defaultFirstOption && (e.filterable || e.remote) && t.filteredOptionsCount && G(); }, { flush: "post" }), Oe(() => t.hoverIndex, _e => { lt(_e) && _e > -1 ? v.value = F.value[_e] || {} : v.value = {}, F.value.forEach(ze => { ze.hover = v.value === ze; }); }); const D = () => { Xe(() => { var _e, ze; if (!s.value)
    return; const We = s.value.$el.querySelector("input"); y = y || (We.clientHeight > 0 ? We.clientHeight + 2 : 0); const ut = d.value, rn = XR(K.value || (C == null ? void 0 : C.size)), Rt = K.value || rn === y || y <= 0 ? rn : y; !(We.offsetParent === null) && (We.style.height = `${(t.selected.length === 0 ? Rt : Math.max(ut ? ut.clientHeight + (ut.clientHeight > Rt ? 6 : 0) : 0, Rt)) - 2}px`), t.visible && B.value !== !1 && ((ze = (_e = u.value) == null ? void 0 : _e.updatePopper) == null || ze.call(_e)); }); }, j = async (_e) => { if (!(t.previousQuery === _e || t.isOnComposition)) {
    if (t.previousQuery === null && (at(e.filterMethod) || at(e.remoteMethod))) {
        t.previousQuery = _e;
        return;
    }
    t.previousQuery = _e, Xe(() => { var ze, We; t.visible && ((We = (ze = u.value) == null ? void 0 : ze.updatePopper) == null || We.call(ze)); }), t.hoverIndex = -1, e.multiple && e.filterable && Xe(() => { const ze = l.value.value.length * 15 + 20; t.inputLength = e.collapseTags ? Math.min(50, ze) : ze, A(), D(); }), e.remote && at(e.remoteMethod) ? (t.hoverIndex = -1, e.remoteMethod(_e)) : at(e.filterMethod) ? (e.filterMethod(_e), oa(h)) : (t.filteredOptionsCount = t.optionsCount, m.value.query = _e, oa(m), oa(h)), e.defaultFirstOption && (e.filterable || e.remote) && t.filteredOptionsCount && (await Xe(), G());
} }, A = () => { t.currentPlaceholder !== "" && (t.currentPlaceholder = l.value.value ? "" : t.cachedPlaceHolder); }, G = () => { const _e = F.value.filter(ut => ut.visible && !ut.disabled && !ut.states.groupDisabled), ze = _e.find(ut => ut.created), We = _e[0]; t.hoverIndex = he(F.value, ze || We); }, se = () => { var _e; if (e.multiple)
    t.selectedLabel = "";
else {
    const We = Z(e.modelValue);
    (_e = We.props) != null && _e.created ? (t.createdLabel = We.props.value, t.createdSelected = !0) : t.createdSelected = !1, t.selectedLabel = We.currentLabel, t.selected = We, e.filterable && (t.query = t.selectedLabel);
    return;
} const ze = []; Array.isArray(e.modelValue) && e.modelValue.forEach(We => { ze.push(Z(We)); }), t.selected = ze, Xe(() => { D(); }); }, Z = _e => { let ze; const We = ou(_e).toLowerCase() === "object", ut = ou(_e).toLowerCase() === "null", rn = ou(_e).toLowerCase() === "undefined"; for (let ot = t.cachedOptions.size - 1; ot >= 0; ot--) {
    const wt = V.value[ot];
    if (We ? sn(wt.value, e.valueKey) === sn(_e, e.valueKey) : wt.value === _e) {
        ze = { value: _e, currentLabel: wt.currentLabel, isDisabled: wt.isDisabled };
        break;
    }
} if (ze)
    return ze; const Rt = We ? _e.label : !ut && !rn ? _e : "", Le = { value: _e, currentLabel: Rt }; return e.multiple && (Le.hitState = !1), Le; }, ce = () => { setTimeout(() => { const _e = e.valueKey; e.multiple ? t.selected.length > 0 ? t.hoverIndex = Math.min.apply(null, t.selected.map(ze => F.value.findIndex(We => sn(We, _e) === sn(ze, _e)))) : t.hoverIndex = -1 : t.hoverIndex = F.value.findIndex(ze => H(ze) === H(t.selected)); }, 300); }, ye = () => { var _e, ze; Re(), (ze = (_e = u.value) == null ? void 0 : _e.updatePopper) == null || ze.call(_e), e.multiple && D(); }, Re = () => { var _e; t.inputWidth = (_e = s.value) == null ? void 0 : _e.$el.offsetWidth; }, me = () => { e.filterable && t.query !== t.selectedLabel && (t.query = t.selectedLabel, j(t.query)); }, le = Xn(() => { me(); }, L.value), oe = Xn(_e => { j(_e.target.value); }, L.value), fe = _e => { ro(e.modelValue, _e) || n.emit(en, _e); }, Ce = _e => { if (_e.code !== tt.delete) {
    if (_e.target.value.length <= 0 && !$e()) {
        const ze = e.modelValue.slice();
        ze.pop(), n.emit(gt, ze), fe(ze);
    }
    _e.target.value.length === 1 && e.modelValue.length === 0 && (t.currentPlaceholder = t.cachedPlaceHolder);
} }, Ae = (_e, ze) => { const We = t.selected.indexOf(ze); if (We > -1 && !T.value) {
    const ut = e.modelValue.slice();
    ut.splice(We, 1), n.emit(gt, ut), fe(ut), n.emit("remove-tag", ze.value);
} _e.stopPropagation(); }, q = _e => { _e.stopPropagation(); const ze = e.multiple ? [] : ""; if (!it(ze))
    for (const We of t.selected)
        We.isDisabled && ze.push(We.value); n.emit(gt, ze), fe(ze), t.hoverIndex = -1, t.visible = !1, n.emit("clear"); }, re = _e => { var ze; if (e.multiple) {
    const We = (e.modelValue || []).slice(), ut = he(We, _e.value);
    ut > -1 ? We.splice(ut, 1) : (e.multipleLimit <= 0 || We.length < e.multipleLimit) && We.push(_e.value), n.emit(gt, We), fe(We), _e.created && (t.query = "", j(""), t.inputLength = 20), e.filterable && ((ze = l.value) == null || ze.focus());
}
else
    n.emit(gt, _e.value), fe(_e.value), t.visible = !1; Ee(), !t.visible && Xe(() => { Ne(_e); }); }, he = (_e = [], ze) => { if (!yt(ze))
    return _e.indexOf(ze); const We = e.valueKey; let ut = -1; return _e.some((rn, Rt) => Bt(sn(rn, We)) === sn(ze, We) ? (ut = Rt, !0) : !1), ut; }, Ee = () => { const _e = l.value || s.value; _e && (_e == null || _e.focus()); }, Ne = _e => { var ze, We, ut, rn, Rt; const Le = Array.isArray(_e) ? _e[0] : _e; let ot = null; if (Le != null && Le.value) {
    const wt = F.value.filter(zt => zt.value === Le.value);
    wt.length > 0 && (ot = wt[0].$el);
} if (u.value && ot) {
    const wt = (rn = (ut = (We = (ze = u.value) == null ? void 0 : ze.popperRef) == null ? void 0 : We.contentRef) == null ? void 0 : ut.querySelector) == null ? void 0 : rn.call(ut, `.${r.be("dropdown", "wrap")}`);
    wt && x1(wt, ot);
} (Rt = p.value) == null || Rt.handleScroll(); }, Se = _e => { t.optionsCount++, t.filteredOptionsCount++, t.options.set(_e.value, _e), t.cachedOptions.set(_e.value, _e); }, De = (_e, ze) => { t.options.get(_e) === ze && (t.optionsCount--, t.filteredOptionsCount--, t.options.delete(_e)); }, Me = _e => { _e.code !== tt.backspace && $e(!1), t.inputLength = l.value.value.length * 15 + 20, D(); }, $e = _e => { if (!Array.isArray(t.selected))
    return; const ze = t.selected[t.selected.length - 1]; if (ze)
    return _e === !0 || _e === !1 ? (ze.hitState = _e, _e) : (ze.hitState = !ze.hitState, ze.hitState); }, Pe = _e => { const ze = _e.target.value; if (_e.type === "compositionend")
    t.isOnComposition = !1, Xe(() => j(ze));
else {
    const We = ze[ze.length - 1] || "";
    t.isOnComposition = !Nc(We);
} }, He = () => { Xe(() => Ne(t.selected)); }, je = _e => { Ld ? Ld = !1 : ((e.automaticDropdown || e.filterable) && (e.filterable && !t.visible && (t.menuVisibleOnFocus = !0), t.visible = !0), n.emit("focus", _e)); }, Ue = () => { var _e, ze, We; t.visible = !1, (_e = s.value) == null || _e.blur(), (We = (ze = a.value) == null ? void 0 : ze.blur) == null || We.call(ze); }, Te = _e => { setTimeout(() => { var ze; if ((ze = u.value) != null && ze.isFocusInsideContent()) {
    Ld = !0;
    return;
} t.visible && W(), n.emit("blur", _e); }); }, Ge = _e => { q(_e); }, W = () => { t.visible = !1; }, X = _e => { t.visible && (_e.preventDefault(), _e.stopPropagation(), t.visible = !1); }, $ = _e => { var ze; _e && !t.mouseEnter || T.value || (t.menuVisibleOnFocus ? t.menuVisibleOnFocus = !1 : (!u.value || !u.value.isFocusInsideContent()) && (t.visible = !t.visible), t.visible && ((ze = l.value || s.value) == null || ze.focus())); }, Y = () => { t.visible ? F.value[t.hoverIndex] && re(F.value[t.hoverIndex]) : $(); }, H = _e => yt(_e.value) ? sn(_e.value, e.valueKey) : _e.value, ue = S(() => F.value.filter(_e => _e.visible).every(_e => _e.disabled)), de = S(() => t.selected.slice(0, e.maxCollapseTags)), be = S(() => t.selected.slice(e.maxCollapseTags)), J = _e => { if (!t.visible) {
    t.visible = !0;
    return;
} if (!(t.options.size === 0 || t.filteredOptionsCount === 0) && !t.isOnComposition && !ue.value) {
    _e === "next" ? (t.hoverIndex++, t.hoverIndex === t.options.size && (t.hoverIndex = 0)) : _e === "prev" && (t.hoverIndex--, t.hoverIndex < 0 && (t.hoverIndex = t.options.size - 1));
    const ze = F.value[t.hoverIndex];
    (ze.disabled === !0 || ze.states.groupDisabled === !0 || !ze.visible) && J(_e), Xe(() => Ne(v.value));
} }; return { optionList: g, optionsArray: F, selectSize: K, handleResize: ye, debouncedOnInputChange: le, debouncedQueryChange: oe, deletePrevTag: Ce, deleteTag: Ae, deleteSelected: q, handleOptionSelect: re, scrollToOption: Ne, readonly: w, resetInputHeight: D, showClose: E, iconComponent: x, iconReverse: I, showNewOption: R, collapseTagSize: te, setSelected: se, managePlaceholder: A, selectDisabled: T, emptyText: B, toggleLastOptionHitState: $e, resetInputState: Me, handleComposition: Pe, onOptionCreate: Se, onOptionDestroy: De, handleMenuEnter: He, handleFocus: je, blur: Ue, handleBlur: Te, handleClearClick: Ge, handleClose: W, handleKeydownEscape: X, toggleMenu: $, selectOption: Y, getValueKey: H, navigateOptions: J, handleDeleteTooltipTag: (_e, ze) => { var We, ut; Ae(_e, ze), (ut = (We = c.value) == null ? void 0 : We.updatePopper) == null || ut.call(We); }, dropMenuVisible: U, queryChange: m, groupQueryChange: h, showTagList: de, collapseTagList: be, reference: s, input: l, iOSInput: a, tooltipRef: u, tagTooltipRef: c, tags: d, selectWrapper: f, scrollbar: p, handleMouseEnter: () => { t.mouseEnter = !0; }, handleMouseLeave: () => { t.mouseEnter = !1; } }; };
var NW = ae({ name: "ElOptions", emits: ["update-options"], setup(e, { slots: t, emit: n }) { let o = []; function r(s, l) { if (s.length !== l.length)
        return !1; for (const [a] of s.entries())
        if (s[a] != l[a])
            return !1; return !0; } return () => { var s, l; const a = (s = t.default) == null ? void 0 : s.call(t), u = []; function c(d) { Array.isArray(d) && d.forEach(f => { var p, v, m, h; const g = (p = (f == null ? void 0 : f.type) || {}) == null ? void 0 : p.name; g === "ElOptionGroup" ? c(!it(f.children) && !Array.isArray(f.children) && at((v = f.children) == null ? void 0 : v.default) ? (m = f.children) == null ? void 0 : m.default() : f.children) : g === "ElOption" ? u.push((h = f.props) == null ? void 0 : h.label) : Array.isArray(f.children) && c(f.children); }); } return a.length && c((l = a[0]) == null ? void 0 : l.children), r(u, o) || (o = u, n("update-options", u)), a; }; } });
const R0 = "ElSelect", PW = ae({ name: R0, componentName: R0, components: { ElInput: Ln, ElSelectMenu: xW, ElOption: jh, ElOptions: NW, ElTag: ri, ElScrollbar: Or, ElTooltip: Jn, ElIcon: Je }, directives: { ClickOutside: ns }, props: { name: String, id: String, modelValue: { type: [Array, String, Number, Boolean, Object], default: void 0 }, autocomplete: { type: String, default: "off" }, automaticDropdown: Boolean, size: { type: String, validator: Mc }, effect: { type: String, default: "light" }, disabled: Boolean, clearable: Boolean, filterable: Boolean, allowCreate: Boolean, loading: Boolean, popperClass: { type: String, default: "" }, popperOptions: { type: Object, default: () => ({}) }, remote: Boolean, loadingText: String, noMatchText: String, noDataText: String, remoteMethod: Function, filterMethod: Function, multiple: Boolean, multipleLimit: { type: Number, default: 0 }, placeholder: { type: String }, defaultFirstOption: Boolean, reserveKeyword: { type: Boolean, default: !0 }, valueKey: { type: String, default: "value" }, collapseTags: Boolean, collapseTagsTooltip: { type: Boolean, default: !1 }, maxCollapseTags: { type: Number, default: 1 }, teleported: On.teleported, persistent: { type: Boolean, default: !0 }, clearIcon: { type: Zt, default: ls }, fitInputWidth: { type: Boolean, default: !1 }, suffixIcon: { type: Zt, default: ss }, tagType: { ...Rh.type, default: "info" }, validateEvent: { type: Boolean, default: !0 }, remoteShowSuffix: { type: Boolean, default: !1 }, suffixTransition: { type: Boolean, default: !0 }, placement: { type: String, values: Ys, default: "bottom-start" } }, emits: [gt, en, "remove-tag", "clear", "visible-change", "focus", "blur"], setup(e, t) { const n = Ie("select"), o = Ie("input"), { t: r } = Nt(), s = AW(e), { optionList: l, optionsArray: a, selectSize: u, readonly: c, handleResize: d, collapseTagSize: f, debouncedOnInputChange: p, debouncedQueryChange: v, deletePrevTag: m, deleteTag: h, deleteSelected: g, handleOptionSelect: y, scrollToOption: C, setSelected: b, resetInputHeight: w, managePlaceholder: T, showClose: E, selectDisabled: x, iconComponent: I, iconReverse: L, showNewOption: B, emptyText: F, toggleLastOptionHitState: V, resetInputState: R, handleComposition: K, onOptionCreate: te, onOptionDestroy: U, handleMenuEnter: D, handleFocus: j, blur: A, handleBlur: G, handleClearClick: se, handleClose: Z, handleKeydownEscape: ce, toggleMenu: ye, selectOption: Re, getValueKey: me, navigateOptions: le, handleDeleteTooltipTag: oe, dropMenuVisible: fe, reference: Ce, input: Ae, iOSInput: q, tooltipRef: re, tagTooltipRef: he, tags: Ee, selectWrapper: Ne, scrollbar: Se, queryChange: De, groupQueryChange: Me, handleMouseEnter: $e, handleMouseLeave: Pe, showTagList: He, collapseTagList: je } = MW(e, s, t), { focus: Ue } = o8(Ce), { inputWidth: Te, selected: Ge, inputLength: W, filteredOptionsCount: X, visible: $, selectedLabel: Y, hoverIndex: H, query: ue, inputHovering: de, currentPlaceholder: be, menuVisibleOnFocus: J, isOnComposition: we, options: Ke, cachedOptions: rt, optionsCount: _e, prefixWidth: ze } = Sn(s), We = S(() => { const cn = [n.b()], ir = i(u); return ir && cn.push(n.m(ir)), e.disabled && cn.push(n.m("disabled")), cn; }), ut = S(() => [n.e("tags"), n.is("disabled", i(x))]), rn = S(() => [n.b("tags-wrapper"), { "has-prefix": i(ze) && i(Ge).length }]), Rt = S(() => [n.e("input"), n.is(i(u)), n.is("disabled", i(x))]), Le = S(() => [n.e("input"), n.is(i(u)), n.em("input", "iOS")]), ot = S(() => [n.is("empty", !e.allowCreate && !!i(ue) && i(X) === 0)]), wt = S(() => ({ maxWidth: `${i(Te) - 32}px`, width: "100%" })), zt = S(() => ({ maxWidth: `${i(Te) > 123 ? i(Te) - 123 : i(Te) - 75}px` })), Qn = S(() => ({ marginLeft: `${i(ze)}px`, flexGrow: 1, width: `${i(W) / (i(Te) - 32)}%`, maxWidth: `${i(Te) - 42}px` })); St(Ti, Lt({ props: e, options: Ke, optionsArray: a, cachedOptions: rt, optionsCount: _e, filteredOptionsCount: X, hoverIndex: H, handleOptionSelect: y, onOptionCreate: te, onOptionDestroy: U, selectWrapper: Ne, selected: Ge, setSelected: b, queryChange: De, groupQueryChange: Me })), ft(() => { s.cachedPlaceHolder = be.value = e.placeholder || (() => r("el.select.placeholder")), e.multiple && Array.isArray(e.modelValue) && e.modelValue.length > 0 && (be.value = ""), Vn(Ne, d), e.remote && e.multiple && w(), Xe(() => { const cn = Ce.value && Ce.value.$el; if (cn && (Te.value = cn.getBoundingClientRect().width, t.slots.prefix)) {
        const ir = cn.querySelector(`.${o.e("prefix")}`);
        ze.value = Math.max(ir.getBoundingClientRect().width + 11, 30);
    } }), b(); }), e.multiple && !Array.isArray(e.modelValue) && t.emit(gt, []), !e.multiple && Array.isArray(e.modelValue) && t.emit(gt, ""); const Mn = S(() => { var cn, ir; return (ir = (cn = re.value) == null ? void 0 : cn.popperRef) == null ? void 0 : ir.contentRef; }); return { isIOS: Hb, onOptionsRendered: cn => { l.value = cn; }, prefixWidth: ze, selectSize: u, readonly: c, handleResize: d, collapseTagSize: f, debouncedOnInputChange: p, debouncedQueryChange: v, deletePrevTag: m, deleteTag: h, handleDeleteTooltipTag: oe, deleteSelected: g, handleOptionSelect: y, scrollToOption: C, inputWidth: Te, selected: Ge, inputLength: W, filteredOptionsCount: X, visible: $, selectedLabel: Y, hoverIndex: H, query: ue, inputHovering: de, currentPlaceholder: be, menuVisibleOnFocus: J, isOnComposition: we, options: Ke, resetInputHeight: w, managePlaceholder: T, showClose: E, selectDisabled: x, iconComponent: I, iconReverse: L, showNewOption: B, emptyText: F, toggleLastOptionHitState: V, resetInputState: R, handleComposition: K, handleMenuEnter: D, handleFocus: j, blur: A, handleBlur: G, handleClearClick: se, handleClose: Z, handleKeydownEscape: ce, toggleMenu: ye, selectOption: Re, getValueKey: me, navigateOptions: le, dropMenuVisible: fe, focus: Ue, reference: Ce, input: Ae, iOSInput: q, tooltipRef: re, popperPaneRef: Mn, tags: Ee, selectWrapper: Ne, scrollbar: Se, wrapperKls: We, tagsKls: ut, tagWrapperKls: rn, inputKls: Rt, iOSInputKls: Le, scrollbarKls: ot, selectTagsStyle: wt, nsSelect: n, tagTextStyle: zt, inputStyle: Qn, handleMouseEnter: $e, handleMouseLeave: Pe, showTagList: He, collapseTagList: je, tagTooltipRef: he }; } }), RW = ["disabled", "autocomplete"], LW = ["disabled"], DW = { style: { height: "100%", display: "flex", "justify-content": "center", "align-items": "center" } };
function BW(e, t, n, o, r, s) { const l = ct("el-tag"), a = ct("el-tooltip"), u = ct("el-icon"), c = ct("el-input"), d = ct("el-option"), f = ct("el-options"), p = ct("el-scrollbar"), v = ct("el-select-menu"), m = Va("click-outside"); return dt((k(), z("div", { ref: "selectWrapper", class: O(e.wrapperKls), onMouseenter: t[21] || (t[21] = (...h) => e.handleMouseEnter && e.handleMouseEnter(...h)), onMouseleave: t[22] || (t[22] = (...h) => e.handleMouseLeave && e.handleMouseLeave(...h)), onClick: t[23] || (t[23] = st((...h) => e.toggleMenu && e.toggleMenu(...h), ["stop"])) }, [ee(a, { ref: "tooltipRef", visible: e.dropMenuVisible, placement: e.placement, teleported: e.teleported, "popper-class": [e.nsSelect.e("popper"), e.popperClass], "popper-options": e.popperOptions, "fallback-placements": ["bottom-start", "top-start", "right", "left"], effect: e.effect, pure: "", trigger: "click", transition: `${e.nsSelect.namespace.value}-zoom-in-top`, "stop-popper-mouse-event": !1, "gpu-acceleration": !1, persistent: e.persistent, onShow: e.handleMenuEnter }, { default: ie(() => [Q("div", { class: "select-trigger", onMouseenter: t[19] || (t[19] = h => e.inputHovering = !0), onMouseleave: t[20] || (t[20] = h => e.inputHovering = !1) }, [e.multiple ? (k(), z("div", { key: 0, ref: "tags", class: O(e.tagsKls), style: et(e.selectTagsStyle) }, [e.collapseTags && e.selected.length ? (k(), ge(yn, { key: 0, onAfterLeave: e.resetInputHeight }, { default: ie(() => [Q("span", { class: O(e.tagWrapperKls) }, [(k(!0), z(Qe, null, Et(e.showTagList, h => (k(), ge(l, { key: e.getValueKey(h), closable: !e.selectDisabled && !h.isDisabled, size: e.collapseTagSize, hit: h.hitState, type: e.tagType, "disable-transitions": "", onClose: g => e.deleteTag(g, h) }, { default: ie(() => [Q("span", { class: O(e.nsSelect.e("tags-text")), style: et(e.tagTextStyle) }, Be(h.currentLabel), 7)]), _: 2 }, 1032, ["closable", "size", "hit", "type", "onClose"]))), 128)), e.selected.length > e.maxCollapseTags ? (k(), ge(l, { key: 0, closable: !1, size: e.collapseTagSize, type: e.tagType, "disable-transitions": "" }, { default: ie(() => [e.collapseTagsTooltip ? (k(), ge(a, { key: 0, ref: "tagTooltipRef", disabled: e.dropMenuVisible, "fallback-placements": ["bottom", "top", "right", "left"], effect: e.effect, placement: "bottom", teleported: e.teleported }, { default: ie(() => [Q("span", { class: O(e.nsSelect.e("tags-text")) }, "+ " + Be(e.selected.length - e.maxCollapseTags), 3)]), content: ie(() => [Q("div", { class: O(e.nsSelect.e("collapse-tags")) }, [(k(!0), z(Qe, null, Et(e.collapseTagList, h => (k(), z("div", { key: e.getValueKey(h), class: O(e.nsSelect.e("collapse-tag")) }, [ee(l, { class: "in-tooltip", closable: !e.selectDisabled && !h.isDisabled, size: e.collapseTagSize, hit: h.hitState, type: e.tagType, "disable-transitions": "", style: { margin: "2px" }, onClose: g => e.handleDeleteTooltipTag(g, h) }, { default: ie(() => [Q("span", { class: O(e.nsSelect.e("tags-text")), style: et({ maxWidth: e.inputWidth - 75 + "px" }) }, Be(h.currentLabel), 7)]), _: 2 }, 1032, ["closable", "size", "hit", "type", "onClose"])], 2))), 128))], 2)]), _: 1 }, 8, ["disabled", "effect", "teleported"])) : (k(), z("span", { key: 1, class: O(e.nsSelect.e("tags-text")) }, "+ " + Be(e.selected.length - e.maxCollapseTags), 3))]), _: 1 }, 8, ["size", "type"])) : pe("v-if", !0)], 2)]), _: 1 }, 8, ["onAfterLeave"])) : pe("v-if", !0), e.collapseTags ? pe("v-if", !0) : (k(), ge(yn, { key: 1, onAfterLeave: e.resetInputHeight }, { default: ie(() => [Q("span", { class: O(e.tagWrapperKls), style: et(e.prefixWidth && e.selected.length ? { marginLeft: `${e.prefixWidth}px` } : "") }, [(k(!0), z(Qe, null, Et(e.selected, h => (k(), ge(l, { key: e.getValueKey(h), closable: !e.selectDisabled && !h.isDisabled, size: e.collapseTagSize, hit: h.hitState, type: e.tagType, "disable-transitions": "", onClose: g => e.deleteTag(g, h) }, { default: ie(() => [Q("span", { class: O(e.nsSelect.e("tags-text")), style: et({ maxWidth: e.inputWidth - 75 + "px" }) }, Be(h.currentLabel), 7)]), _: 2 }, 1032, ["closable", "size", "hit", "type", "onClose"]))), 128))], 6)]), _: 1 }, 8, ["onAfterLeave"])), e.filterable && !e.selectDisabled ? dt((k(), z("input", { key: 2, ref: "input", "onUpdate:modelValue": t[0] || (t[0] = h => e.query = h), type: "text", class: O(e.inputKls), disabled: e.selectDisabled, autocomplete: e.autocomplete, style: et(e.inputStyle), onFocus: t[1] || (t[1] = (...h) => e.handleFocus && e.handleFocus(...h)), onBlur: t[2] || (t[2] = (...h) => e.handleBlur && e.handleBlur(...h)), onKeyup: t[3] || (t[3] = (...h) => e.managePlaceholder && e.managePlaceholder(...h)), onKeydown: [t[4] || (t[4] = (...h) => e.resetInputState && e.resetInputState(...h)), t[5] || (t[5] = Mt(st(h => e.navigateOptions("next"), ["prevent"]), ["down"])), t[6] || (t[6] = Mt(st(h => e.navigateOptions("prev"), ["prevent"]), ["up"])), t[7] || (t[7] = Mt((...h) => e.handleKeydownEscape && e.handleKeydownEscape(...h), ["esc"])), t[8] || (t[8] = Mt(st((...h) => e.selectOption && e.selectOption(...h), ["stop", "prevent"]), ["enter"])), t[9] || (t[9] = Mt((...h) => e.deletePrevTag && e.deletePrevTag(...h), ["delete"])), t[10] || (t[10] = Mt(h => e.visible = !1, ["tab"]))], onCompositionstart: t[11] || (t[11] = (...h) => e.handleComposition && e.handleComposition(...h)), onCompositionupdate: t[12] || (t[12] = (...h) => e.handleComposition && e.handleComposition(...h)), onCompositionend: t[13] || (t[13] = (...h) => e.handleComposition && e.handleComposition(...h)), onInput: t[14] || (t[14] = (...h) => e.debouncedQueryChange && e.debouncedQueryChange(...h)) }, null, 46, RW)), [[Fp, e.query]]) : pe("v-if", !0)], 6)) : pe("v-if", !0), pe(" fix: https://github.com/element-plus/element-plus/issues/11415 "), e.isIOS && !e.multiple && e.filterable && e.readonly ? (k(), z("input", { key: 1, ref: "iOSInput", class: O(e.iOSInputKls), disabled: e.selectDisabled, type: "text" }, null, 10, LW)) : pe("v-if", !0), ee(c, { id: e.id, ref: "reference", modelValue: e.selectedLabel, "onUpdate:modelValue": t[15] || (t[15] = h => e.selectedLabel = h), type: "text", placeholder: typeof e.currentPlaceholder == "function" ? e.currentPlaceholder() : e.currentPlaceholder, name: e.name, autocomplete: e.autocomplete, size: e.selectSize, disabled: e.selectDisabled, readonly: e.readonly, "validate-event": !1, class: O([e.nsSelect.is("focus", e.visible)]), tabindex: e.multiple && e.filterable ? -1 : void 0, onFocus: e.handleFocus, onBlur: e.handleBlur, onInput: e.debouncedOnInputChange, onPaste: e.debouncedOnInputChange, onCompositionstart: e.handleComposition, onCompositionupdate: e.handleComposition, onCompositionend: e.handleComposition, onKeydown: [t[16] || (t[16] = Mt(st(h => e.navigateOptions("next"), ["stop", "prevent"]), ["down"])), t[17] || (t[17] = Mt(st(h => e.navigateOptions("prev"), ["stop", "prevent"]), ["up"])), Mt(st(e.selectOption, ["stop", "prevent"]), ["enter"]), Mt(e.handleKeydownEscape, ["esc"]), t[18] || (t[18] = Mt(h => e.visible = !1, ["tab"]))] }, Cr({ suffix: ie(() => [e.iconComponent && !e.showClose ? (k(), ge(u, { key: 0, class: O([e.nsSelect.e("caret"), e.nsSelect.e("icon"), e.iconReverse]) }, { default: ie(() => [(k(), ge(kt(e.iconComponent)))]), _: 1 }, 8, ["class"])) : pe("v-if", !0), e.showClose && e.clearIcon ? (k(), ge(u, { key: 1, class: O([e.nsSelect.e("caret"), e.nsSelect.e("icon")]), onClick: e.handleClearClick }, { default: ie(() => [(k(), ge(kt(e.clearIcon)))]), _: 1 }, 8, ["class", "onClick"])) : pe("v-if", !0)]), _: 2 }, [e.$slots.prefix ? { name: "prefix", fn: ie(() => [Q("div", DW, [ke(e.$slots, "prefix")])]) } : void 0]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])], 32)]), content: ie(() => [ee(v, null, { default: ie(() => [dt(ee(p, { ref: "scrollbar", tag: "ul", "wrap-class": e.nsSelect.be("dropdown", "wrap"), "view-class": e.nsSelect.be("dropdown", "list"), class: O(e.scrollbarKls) }, { default: ie(() => [e.showNewOption ? (k(), ge(d, { key: 0, value: e.query, created: !0 }, null, 8, ["value"])) : pe("v-if", !0), ee(f, { onUpdateOptions: e.onOptionsRendered }, { default: ie(() => [ke(e.$slots, "default")]), _: 3 }, 8, ["onUpdateOptions"])]), _: 3 }, 8, ["wrap-class", "view-class", "class"]), [[Pt, e.options.size > 0 && !e.loading]]), e.emptyText && (!e.allowCreate || e.loading || e.allowCreate && e.options.size === 0) ? (k(), z(Qe, { key: 0 }, [e.$slots.empty ? ke(e.$slots, "empty", { key: 0 }) : (k(), z("p", { key: 1, class: O(e.nsSelect.be("dropdown", "empty")) }, Be(e.emptyText), 3))], 64)) : pe("v-if", !0)]), _: 3 })]), _: 3 }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onShow"])], 34)), [[m, e.handleClose, e.popperPaneRef]]); }
var FW = Fe(PW, [["render", BW], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);
const VW = ae({ name: "ElOptionGroup", componentName: "ElOptionGroup", props: { label: String, disabled: { type: Boolean, default: !1 } }, setup(e) { const t = Ie("select"), n = M(!0), o = ht(), r = M([]); St(y2, Lt({ ...Sn(e) })); const s = Ye(Ti); ft(() => { r.value = l(o.subTree); }); const l = u => { const c = []; return Array.isArray(u.children) && u.children.forEach(d => { var f; d.type && d.type.name === "ElOption" && d.component && d.component.proxy ? c.push(d.component.proxy) : (f = d.children) != null && f.length && c.push(...l(d)); }), c; }, { groupQueryChange: a } = Bt(s); return Oe(a, () => { n.value = r.value.some(u => u.visible === !0); }, { flush: "post" }), { visible: n, ns: t }; } });
function zW(e, t, n, o, r, s) { return dt((k(), z("ul", { class: O(e.ns.be("group", "wrap")) }, [Q("li", { class: O(e.ns.be("group", "title")) }, Be(e.label), 3), Q("li", null, [Q("ul", { class: O(e.ns.b("group")) }, [ke(e.$slots, "default")], 2)])], 2)), [[Pt, e.visible]]); }
var b2 = Fe(VW, [["render", zW], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);
const Hs = vt(FW, { Option: jh, OptionGroup: b2 }), Xu = pn(jh), HW = pn(b2), Wh = () => Ye(g2, {}), KW = Ve({ pageSize: { type: Number, required: !0 }, pageSizes: { type: ve(Array), default: () => ln([10, 20, 30, 40, 50, 100]) }, popperClass: { type: String }, disabled: Boolean, size: { type: String, values: sr } }), jW = ae({ name: "ElPaginationSizes" }), WW = ae({ ...jW, props: KW, emits: ["page-size-change"], setup(e, { emit: t }) { const n = e, { t: o } = Nt(), r = Ie("pagination"), s = Wh(), l = M(n.pageSize); Oe(() => n.pageSizes, (c, d) => { if (!ro(c, d) && Array.isArray(c)) {
        const f = c.includes(n.pageSize) ? n.pageSize : n.pageSizes[0];
        t("page-size-change", f);
    } }), Oe(() => n.pageSize, c => { l.value = c; }); const a = S(() => n.pageSizes); function u(c) { var d; c !== l.value && (l.value = c, (d = s.handleSizeChange) == null || d.call(s, Number(c))); } return (c, d) => (k(), z("span", { class: O(i(r).e("sizes")) }, [ee(i(Hs), { "model-value": l.value, disabled: c.disabled, "popper-class": c.popperClass, size: c.size, "validate-event": !1, onChange: u }, { default: ie(() => [(k(!0), z(Qe, null, Et(i(a), f => (k(), ge(i(Xu), { key: f, value: f, label: f + i(o)("el.pagination.pagesize") }, null, 8, ["value", "label"]))), 128))]), _: 1 }, 8, ["model-value", "disabled", "popper-class", "size"])], 2)); } });
var UW = Fe(WW, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/sizes.vue"]]);
const qW = Ve({ size: { type: String, values: sr } }), YW = ["disabled"], GW = ae({ name: "ElPaginationJumper" }), XW = ae({ ...GW, props: qW, setup(e) { const { t } = Nt(), n = Ie("pagination"), { pageCount: o, disabled: r, currentPage: s, changeEvent: l } = Wh(), a = M(), u = S(() => { var f; return (f = a.value) != null ? f : s == null ? void 0 : s.value; }); function c(f) { a.value = f ? +f : ""; } function d(f) { f = Math.trunc(+f), l == null || l(f), a.value = void 0; } return (f, p) => (k(), z("span", { class: O(i(n).e("jump")), disabled: i(r) }, [Q("span", { class: O([i(n).e("goto")]) }, Be(i(t)("el.pagination.goto")), 3), ee(i(Ln), { size: f.size, class: O([i(n).e("editor"), i(n).is("in-pagination")]), min: 1, max: i(o), disabled: i(r), "model-value": i(u), "validate-event": !1, label: i(t)("el.pagination.page"), type: "number", "onUpdate:modelValue": c, onChange: d }, null, 8, ["size", "class", "max", "disabled", "model-value", "label"]), Q("span", { class: O([i(n).e("classifier")]) }, Be(i(t)("el.pagination.pageClassifier")), 3)], 10, YW)); } });
var JW = Fe(XW, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/jumper.vue"]]);
const ZW = Ve({ total: { type: Number, default: 1e3 } }), QW = ["disabled"], eU = ae({ name: "ElPaginationTotal" }), tU = ae({ ...eU, props: ZW, setup(e) { const { t } = Nt(), n = Ie("pagination"), { disabled: o } = Wh(); return (r, s) => (k(), z("span", { class: O(i(n).e("total")), disabled: i(o) }, Be(i(t)("el.pagination.total", { total: r.total })), 11, QW)); } });
var nU = Fe(tU, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/total.vue"]]);
const oU = Ve({ currentPage: { type: Number, default: 1 }, pageCount: { type: Number, required: !0 }, pagerCount: { type: Number, default: 7 }, disabled: Boolean }), rU = ["onKeyup"], sU = ["aria-current", "aria-label", "tabindex"], lU = ["tabindex", "aria-label"], aU = ["aria-current", "aria-label", "tabindex"], iU = ["tabindex", "aria-label"], uU = ["aria-current", "aria-label", "tabindex"], cU = ae({ name: "ElPaginationPager" }), dU = ae({ ...cU, props: oU, emits: ["change"], setup(e, { emit: t }) { const n = e, o = Ie("pager"), r = Ie("icon"), { t: s } = Nt(), l = M(!1), a = M(!1), u = M(!1), c = M(!1), d = M(!1), f = M(!1), p = S(() => { const w = n.pagerCount, T = (w - 1) / 2, E = Number(n.currentPage), x = Number(n.pageCount); let I = !1, L = !1; x > w && (E > w - T && (I = !0), E < x - T && (L = !0)); const B = []; if (I && !L) {
        const F = x - (w - 2);
        for (let V = F; V < x; V++)
            B.push(V);
    }
    else if (!I && L)
        for (let F = 2; F < w; F++)
            B.push(F);
    else if (I && L) {
        const F = Math.floor(w / 2) - 1;
        for (let V = E - F; V <= E + F; V++)
            B.push(V);
    }
    else
        for (let F = 2; F < x; F++)
            B.push(F); return B; }), v = S(() => ["more", "btn-quickprev", r.b(), o.is("disabled", n.disabled)]), m = S(() => ["more", "btn-quicknext", r.b(), o.is("disabled", n.disabled)]), h = S(() => n.disabled ? -1 : 0); mo(() => { const w = (n.pagerCount - 1) / 2; l.value = !1, a.value = !1, n.pageCount > n.pagerCount && (n.currentPage > n.pagerCount - w && (l.value = !0), n.currentPage < n.pageCount - w && (a.value = !0)); }); function g(w = !1) { n.disabled || (w ? u.value = !0 : c.value = !0); } function y(w = !1) { w ? d.value = !0 : f.value = !0; } function C(w) { const T = w.target; if (T.tagName.toLowerCase() === "li" && Array.from(T.classList).includes("number")) {
        const E = Number(T.textContent);
        E !== n.currentPage && t("change", E);
    }
    else
        T.tagName.toLowerCase() === "li" && Array.from(T.classList).includes("more") && b(w); } function b(w) { const T = w.target; if (T.tagName.toLowerCase() === "ul" || n.disabled)
        return; let E = Number(T.textContent); const x = n.pageCount, I = n.currentPage, L = n.pagerCount - 2; T.className.includes("more") && (T.className.includes("quickprev") ? E = I - L : T.className.includes("quicknext") && (E = I + L)), Number.isNaN(+E) || (E < 1 && (E = 1), E > x && (E = x)), E !== I && t("change", E); } return (w, T) => (k(), z("ul", { class: O(i(o).b()), onClick: b, onKeyup: Mt(C, ["enter"]) }, [w.pageCount > 0 ? (k(), z("li", { key: 0, class: O([[i(o).is("active", w.currentPage === 1), i(o).is("disabled", w.disabled)], "number"]), "aria-current": w.currentPage === 1, "aria-label": i(s)("el.pagination.currentPage", { pager: 1 }), tabindex: i(h) }, " 1 ", 10, sU)) : pe("v-if", !0), l.value ? (k(), z("li", { key: 1, class: O(i(v)), tabindex: i(h), "aria-label": i(s)("el.pagination.prevPages", { pager: w.pagerCount - 2 }), onMouseenter: T[0] || (T[0] = E => g(!0)), onMouseleave: T[1] || (T[1] = E => u.value = !1), onFocus: T[2] || (T[2] = E => y(!0)), onBlur: T[3] || (T[3] = E => d.value = !1) }, [(u.value || d.value) && !w.disabled ? (k(), ge(i(Al), { key: 0 })) : (k(), ge(i(_g), { key: 1 }))], 42, lU)) : pe("v-if", !0), (k(!0), z(Qe, null, Et(i(p), E => (k(), z("li", { key: E, class: O([[i(o).is("active", w.currentPage === E), i(o).is("disabled", w.disabled)], "number"]), "aria-current": w.currentPage === E, "aria-label": i(s)("el.pagination.currentPage", { pager: E }), tabindex: i(h) }, Be(E), 11, aU))), 128)), a.value ? (k(), z("li", { key: 2, class: O(i(m)), tabindex: i(h), "aria-label": i(s)("el.pagination.nextPages", { pager: w.pagerCount - 2 }), onMouseenter: T[4] || (T[4] = E => g()), onMouseleave: T[5] || (T[5] = E => c.value = !1), onFocus: T[6] || (T[6] = E => y()), onBlur: T[7] || (T[7] = E => f.value = !1) }, [(c.value || f.value) && !w.disabled ? (k(), ge(i(Ml), { key: 0 })) : (k(), ge(i(_g), { key: 1 }))], 42, iU)) : pe("v-if", !0), w.pageCount > 1 ? (k(), z("li", { key: 3, class: O([[i(o).is("active", w.currentPage === w.pageCount), i(o).is("disabled", w.disabled)], "number"]), "aria-current": w.currentPage === w.pageCount, "aria-label": i(s)("el.pagination.currentPage", { pager: w.pageCount }), tabindex: i(h) }, Be(w.pageCount), 11, uU)) : pe("v-if", !0)], 42, rU)); } });
var fU = Fe(dU, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/pager.vue"]]);
const Kn = e => typeof e != "number", pU = Ve({ pageSize: Number, defaultPageSize: Number, total: Number, pageCount: Number, pagerCount: { type: Number, validator: e => lt(e) && Math.trunc(e) === e && e > 4 && e < 22 && e % 2 === 1, default: 7 }, currentPage: Number, defaultCurrentPage: Number, layout: { type: String, default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ") }, pageSizes: { type: ve(Array), default: () => ln([10, 20, 30, 40, 50, 100]) }, popperClass: { type: String, default: "" }, prevText: { type: String, default: "" }, prevIcon: { type: Zt, default: () => Zr }, nextText: { type: String, default: "" }, nextIcon: { type: Zt, default: () => Un }, small: Boolean, background: Boolean, disabled: Boolean, hideOnSinglePage: Boolean }), hU = { "update:current-page": e => lt(e), "update:page-size": e => lt(e), "size-change": e => lt(e), "current-change": e => lt(e), "prev-click": e => lt(e), "next-click": e => lt(e) }, L0 = "ElPagination";
var vU = ae({ name: L0, props: pU, emits: hU, setup(e, { emit: t, slots: n }) { const { t: o } = Nt(), r = Ie("pagination"), s = ht().vnode.props || {}, l = "onUpdate:currentPage" in s || "onUpdate:current-page" in s || "onCurrentChange" in s, a = "onUpdate:pageSize" in s || "onUpdate:page-size" in s || "onSizeChange" in s, u = S(() => { if (Kn(e.total) && Kn(e.pageCount) || !Kn(e.currentPage) && !l)
        return !1; if (e.layout.includes("sizes")) {
        if (Kn(e.pageCount)) {
            if (!Kn(e.total) && !Kn(e.pageSize) && !a)
                return !1;
        }
        else if (!a)
            return !1;
    } return !0; }), c = M(Kn(e.defaultPageSize) ? 10 : e.defaultPageSize), d = M(Kn(e.defaultCurrentPage) ? 1 : e.defaultCurrentPage), f = S({ get() { return Kn(e.pageSize) ? c.value : e.pageSize; }, set(b) { Kn(e.pageSize) && (c.value = b), a && (t("update:page-size", b), t("size-change", b)); } }), p = S(() => { let b = 0; return Kn(e.pageCount) ? Kn(e.total) || (b = Math.max(1, Math.ceil(e.total / f.value))) : b = e.pageCount, b; }), v = S({ get() { return Kn(e.currentPage) ? d.value : e.currentPage; }, set(b) { let w = b; b < 1 ? w = 1 : b > p.value && (w = p.value), Kn(e.currentPage) && (d.value = w), l && (t("update:current-page", w), t("current-change", w)); } }); Oe(p, b => { v.value > b && (v.value = b); }); function m(b) { v.value = b; } function h(b) { f.value = b; const w = p.value; v.value > w && (v.value = w); } function g() { e.disabled || (v.value -= 1, t("prev-click", v.value)); } function y() { e.disabled || (v.value += 1, t("next-click", v.value)); } function C(b, w) { b && (b.props || (b.props = {}), b.props.class = [b.props.class, w].join(" ")); } return St(g2, { pageCount: p, disabled: S(() => e.disabled), currentPage: v, changeEvent: m, handleSizeChange: h }), () => { var b, w; if (!u.value)
        return o("el.pagination.deprecationWarning"), null; if (!e.layout || e.hideOnSinglePage && p.value <= 1)
        return null; const T = [], E = [], x = nt("div", { class: r.e("rightwrapper") }, E), I = { prev: nt(yW, { disabled: e.disabled, currentPage: v.value, prevText: e.prevText, prevIcon: e.prevIcon, onClick: g }), jumper: nt(JW, { size: e.small ? "small" : "default" }), pager: nt(fU, { currentPage: v.value, pageCount: p.value, pagerCount: e.pagerCount, onChange: m, disabled: e.disabled }), next: nt(kW, { disabled: e.disabled, currentPage: v.value, pageCount: p.value, nextText: e.nextText, nextIcon: e.nextIcon, onClick: y }), sizes: nt(UW, { pageSize: f.value, pageSizes: e.pageSizes, popperClass: e.popperClass, disabled: e.disabled, size: e.small ? "small" : "default" }), slot: (w = (b = n == null ? void 0 : n.default) == null ? void 0 : b.call(n)) != null ? w : null, total: nt(nU, { total: Kn(e.total) ? 0 : e.total }) }, L = e.layout.split(",").map(F => F.trim()); let B = !1; return L.forEach(F => { if (F === "->") {
        B = !0;
        return;
    } B ? E.push(I[F]) : T.push(I[F]); }), C(T[0], r.is("first")), C(T[T.length - 1], r.is("last")), B && E.length > 0 && (C(E[0], r.is("first")), C(E[E.length - 1], r.is("last")), T.push(x)), nt("div", { class: [r.b(), r.is("background", e.background), { [r.m("small")]: e.small }] }, T); }; } });
const mU = vt(vU), gU = Ve({ title: String, confirmButtonText: String, cancelButtonText: String, confirmButtonType: { type: String, values: kf, default: "primary" }, cancelButtonType: { type: String, values: kf, default: "text" }, icon: { type: Zt, default: () => EP }, iconColor: { type: String, default: "#f90" }, hideIcon: { type: Boolean, default: !1 }, hideAfter: { type: Number, default: 200 }, teleported: On.teleported, persistent: On.persistent, width: { type: [String, Number], default: 150 } }), yU = { confirm: e => e instanceof MouseEvent, cancel: e => e instanceof MouseEvent }, bU = ae({ name: "ElPopconfirm" }), wU = ae({ ...bU, props: gU, emits: yU, setup(e, { emit: t }) { const n = e, { t: o } = Nt(), r = Ie("popconfirm"), s = M(), l = () => { var p, v; (v = (p = s.value) == null ? void 0 : p.onClose) == null || v.call(p); }, a = S(() => ({ width: gn(n.width) })), u = p => { t("confirm", p), l(); }, c = p => { t("cancel", p), l(); }, d = S(() => n.confirmButtonText || o("el.popconfirm.confirmButtonText")), f = S(() => n.cancelButtonText || o("el.popconfirm.cancelButtonText")); return (p, v) => (k(), ge(i(Jn), Ct({ ref_key: "tooltipRef", ref: s, trigger: "click", effect: "light" }, p.$attrs, { "popper-class": `${i(r).namespace.value}-popover`, "popper-style": i(a), teleported: p.teleported, "fallback-placements": ["bottom", "top", "right", "left"], "hide-after": p.hideAfter, persistent: p.persistent }), { content: ie(() => [Q("div", { class: O(i(r).b()) }, [Q("div", { class: O(i(r).e("main")) }, [!p.hideIcon && p.icon ? (k(), ge(i(Je), { key: 0, class: O(i(r).e("icon")), style: et({ color: p.iconColor }) }, { default: ie(() => [(k(), ge(kt(p.icon)))]), _: 1 }, 8, ["class", "style"])) : pe("v-if", !0), Ot(" " + Be(p.title), 1)], 2), Q("div", { class: O(i(r).e("action")) }, [ee(i(xn), { size: "small", type: p.cancelButtonType === "text" ? "" : p.cancelButtonType, text: p.cancelButtonType === "text", onClick: c }, { default: ie(() => [Ot(Be(i(f)), 1)]), _: 1 }, 8, ["type", "text"]), ee(i(xn), { size: "small", type: p.confirmButtonType === "text" ? "" : p.confirmButtonType, text: p.confirmButtonType === "text", onClick: u }, { default: ie(() => [Ot(Be(i(d)), 1)]), _: 1 }, 8, ["type", "text"])], 2)], 2)]), default: ie(() => [p.$slots.reference ? ke(p.$slots, "reference", { key: 0 }) : pe("v-if", !0)]), _: 3 }, 16, ["popper-class", "popper-style", "teleported", "hide-after", "persistent"])); } });
var CU = Fe(wU, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popconfirm/src/popconfirm.vue"]]);
const SU = vt(CU), _U = Ve({ trigger: oi.trigger, placement: Su.placement, disabled: oi.disabled, visible: On.visible, transition: On.transition, popperOptions: Su.popperOptions, tabindex: Su.tabindex, content: On.content, popperStyle: On.popperStyle, popperClass: On.popperClass, enterable: { ...On.enterable, default: !0 }, effect: { ...On.effect, default: "light" }, teleported: On.teleported, title: String, width: { type: [String, Number], default: 150 }, offset: { type: Number, default: void 0 }, showAfter: { type: Number, default: 0 }, hideAfter: { type: Number, default: 200 }, autoClose: { type: Number, default: 0 }, showArrow: { type: Boolean, default: !0 }, persistent: { type: Boolean, default: !0 }, "onUpdate:visible": { type: Function } }), kU = { "update:visible": e => wn(e), "before-enter": () => !0, "before-leave": () => !0, "after-enter": () => !0, "after-leave": () => !0 }, EU = "onUpdate:visible", $U = ae({ name: "ElPopover" }), TU = ae({ ...$U, props: _U, emits: kU, setup(e, { expose: t, emit: n }) { const o = e, r = S(() => o[EU]), s = Ie("popover"), l = M(), a = S(() => { var g; return (g = i(l)) == null ? void 0 : g.popperRef; }), u = S(() => [{ width: gn(o.width) }, o.popperStyle]), c = S(() => [s.b(), o.popperClass, { [s.m("plain")]: !!o.content }]), d = S(() => o.transition === `${s.namespace.value}-fade-in-linear`), f = () => { var g; (g = l.value) == null || g.hide(); }, p = () => { n("before-enter"); }, v = () => { n("before-leave"); }, m = () => { n("after-enter"); }, h = () => { n("update:visible", !1), n("after-leave"); }; return t({ popperRef: a, hide: f }), (g, y) => (k(), ge(i(Jn), Ct({ ref_key: "tooltipRef", ref: l }, g.$attrs, { trigger: g.trigger, placement: g.placement, disabled: g.disabled, visible: g.visible, transition: g.transition, "popper-options": g.popperOptions, tabindex: g.tabindex, content: g.content, offset: g.offset, "show-after": g.showAfter, "hide-after": g.hideAfter, "auto-close": g.autoClose, "show-arrow": g.showArrow, "aria-label": g.title, effect: g.effect, enterable: g.enterable, "popper-class": i(c), "popper-style": i(u), teleported: g.teleported, persistent: g.persistent, "gpu-acceleration": i(d), "onUpdate:visible": i(r), onBeforeShow: p, onBeforeHide: v, onShow: m, onHide: h }), { content: ie(() => [g.title ? (k(), z("div", { key: 0, class: O(i(s).e("title")), role: "title" }, Be(g.title), 3)) : pe("v-if", !0), ke(g.$slots, "default", {}, () => [Ot(Be(g.content), 1)])]), default: ie(() => [g.$slots.reference ? ke(g.$slots, "reference", { key: 0 }) : pe("v-if", !0)]), _: 3 }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"])); } });
var OU = Fe(TU, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);
const D0 = (e, t) => { const n = t.arg || t.value, o = n == null ? void 0 : n.popperRef; o && (o.triggerRef = e); };
var IU = { mounted(e, t) { D0(e, t); }, updated(e, t) { D0(e, t); } };
const xU = "popover", w2 = qR(IU, xU), AU = vt(OU, { directive: w2 }), MU = Ve({ type: { type: String, default: "line", values: ["line", "circle", "dashboard"] }, percentage: { type: Number, default: 0, validator: e => e >= 0 && e <= 100 }, status: { type: String, default: "", values: ["", "success", "exception", "warning"] }, indeterminate: { type: Boolean, default: !1 }, duration: { type: Number, default: 3 }, strokeWidth: { type: Number, default: 6 }, strokeLinecap: { type: ve(String), default: "round" }, textInside: { type: Boolean, default: !1 }, width: { type: Number, default: 126 }, showText: { type: Boolean, default: !0 }, color: { type: ve([String, Array, Function]), default: "" }, striped: Boolean, stripedFlow: Boolean, format: { type: ve(Function), default: e => `${e}%` } }), NU = ["aria-valuenow"], PU = { viewBox: "0 0 100 100" }, RU = ["d", "stroke", "stroke-linecap", "stroke-width"], LU = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"], DU = { key: 0 }, BU = ae({ name: "ElProgress" }), FU = ae({ ...BU, props: MU, setup(e) {
        const t = e, n = { success: "#13ce66", exception: "#ff4949", warning: "#e6a23c", default: "#20a0ff" }, o = Ie("progress"), r = S(() => ({ width: `${t.percentage}%`, animationDuration: `${t.duration}s`, backgroundColor: C(t.percentage) })), s = S(() => (t.strokeWidth / t.width * 100).toFixed(1)), l = S(() => ["circle", "dashboard"].includes(t.type) ? Number.parseInt(`${50 - Number.parseFloat(s.value) / 2}`, 10) : 0), a = S(() => {
            const b = l.value, w = t.type === "dashboard";
            return `
          M 50 50
          m 0 ${w ? "" : "-"}${b}
          a ${b} ${b} 0 1 1 0 ${w ? "-" : ""}${b * 2}
          a ${b} ${b} 0 1 1 0 ${w ? "" : "-"}${b * 2}
          `;
        }), u = S(() => 2 * Math.PI * l.value), c = S(() => t.type === "dashboard" ? .75 : 1), d = S(() => `${-1 * u.value * (1 - c.value) / 2}px`), f = S(() => ({ strokeDasharray: `${u.value * c.value}px, ${u.value}px`, strokeDashoffset: d.value })), p = S(() => ({ strokeDasharray: `${u.value * c.value * (t.percentage / 100)}px, ${u.value}px`, strokeDashoffset: d.value, transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s" })), v = S(() => { let b; return t.color ? b = C(t.percentage) : b = n[t.status] || n.default, b; }), m = S(() => t.status === "warning" ? xc : t.type === "line" ? t.status === "success" ? ah : ls : t.status === "success" ? _i : Ho), h = S(() => t.type === "line" ? 12 + t.strokeWidth * .4 : t.width * .111111 + 2), g = S(() => t.format(t.percentage));
        function y(b) { const w = 100 / b.length; return b.map((E, x) => it(E) ? { color: E, percentage: (x + 1) * w } : E).sort((E, x) => E.percentage - x.percentage); }
        const C = b => { var w; const { color: T } = t; if (at(T))
            return T(b); if (it(T))
            return T; {
            const E = y(T);
            for (const x of E)
                if (x.percentage > b)
                    return x.color;
            return (w = E[E.length - 1]) == null ? void 0 : w.color;
        } };
        return (b, w) => (k(), z("div", { class: O([i(o).b(), i(o).m(b.type), i(o).is(b.status), { [i(o).m("without-text")]: !b.showText, [i(o).m("text-inside")]: b.textInside }]), role: "progressbar", "aria-valuenow": b.percentage, "aria-valuemin": "0", "aria-valuemax": "100" }, [b.type === "line" ? (k(), z("div", { key: 0, class: O(i(o).b("bar")) }, [Q("div", { class: O(i(o).be("bar", "outer")), style: et({ height: `${b.strokeWidth}px` }) }, [Q("div", { class: O([i(o).be("bar", "inner"), { [i(o).bem("bar", "inner", "indeterminate")]: b.indeterminate }, { [i(o).bem("bar", "inner", "striped")]: b.striped }, { [i(o).bem("bar", "inner", "striped-flow")]: b.stripedFlow }]), style: et(i(r)) }, [(b.showText || b.$slots.default) && b.textInside ? (k(), z("div", { key: 0, class: O(i(o).be("bar", "innerText")) }, [ke(b.$slots, "default", { percentage: b.percentage }, () => [Q("span", null, Be(i(g)), 1)])], 2)) : pe("v-if", !0)], 6)], 6)], 2)) : (k(), z("div", { key: 1, class: O(i(o).b("circle")), style: et({ height: `${b.width}px`, width: `${b.width}px` }) }, [(k(), z("svg", PU, [Q("path", { class: O(i(o).be("circle", "track")), d: i(a), stroke: `var(${i(o).cssVarName("fill-color-light")}, #e5e9f2)`, "stroke-linecap": b.strokeLinecap, "stroke-width": i(s), fill: "none", style: et(i(f)) }, null, 14, RU), Q("path", { class: O(i(o).be("circle", "path")), d: i(a), stroke: i(v), fill: "none", opacity: b.percentage ? 1 : 0, "stroke-linecap": b.strokeLinecap, "stroke-width": i(s), style: et(i(p)) }, null, 14, LU)]))], 6)), (b.showText || b.$slots.default) && !b.textInside ? (k(), z("div", { key: 2, class: O(i(o).e("text")), style: et({ fontSize: `${i(h)}px` }) }, [ke(b.$slots, "default", { percentage: b.percentage }, () => [b.status ? (k(), ge(i(Je), { key: 1 }, { default: ie(() => [(k(), ge(kt(i(m))))]), _: 1 })) : (k(), z("span", DU, Be(i(g)), 1))])], 6)) : pe("v-if", !0)], 10, NU));
    } });
var VU = Fe(FU, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);
const C2 = vt(VU), zU = Ve({ modelValue: { type: Number, default: 0 }, id: { type: String, default: void 0 }, lowThreshold: { type: Number, default: 2 }, highThreshold: { type: Number, default: 4 }, max: { type: Number, default: 5 }, colors: { type: ve([Array, Object]), default: () => ln(["", "", ""]) }, voidColor: { type: String, default: "" }, disabledVoidColor: { type: String, default: "" }, icons: { type: ve([Array, Object]), default: () => [Hi, Hi, Hi] }, voidIcon: { type: Zt, default: () => yR }, disabledVoidIcon: { type: Zt, default: () => Hi }, disabled: Boolean, allowHalf: Boolean, showText: Boolean, showScore: Boolean, textColor: { type: String, default: "" }, texts: { type: ve(Array), default: () => ln(["Extremely bad", "Disappointed", "Fair", "Satisfied", "Surprise"]) }, scoreTemplate: { type: String, default: "{value}" }, size: Bn, label: { type: String, default: void 0 }, clearable: { type: Boolean, default: !1 } }), HU = { [en]: e => lt(e), [gt]: e => lt(e) }, KU = ["id", "aria-label", "aria-labelledby", "aria-valuenow", "aria-valuetext", "aria-valuemax"], jU = ["onMousemove", "onClick"], WU = ae({ name: "ElRate" }), UU = ae({ ...WU, props: zU, emits: HU, setup(e, { expose: t, emit: n }) { const o = e; function r(U, D) { const j = se => yt(se), A = Object.keys(D).map(se => +se).filter(se => { const Z = D[se]; return (j(Z) ? Z.excluded : !1) ? U < se : U <= se; }).sort((se, Z) => se - Z), G = D[A[0]]; return j(G) && G.value || G; } const s = Ye(Gs, void 0), l = Ye(rr, void 0), a = kn(), u = Ie("rate"), { inputId: c, isLabeledByFormItem: d } = us(o, { formItemContext: l }), f = M(o.modelValue), p = M(-1), v = M(!0), m = S(() => [u.b(), u.m(a.value)]), h = S(() => o.disabled || (s == null ? void 0 : s.disabled)), g = S(() => u.cssVarBlock({ "void-color": o.voidColor, "disabled-void-color": o.disabledVoidColor, "fill-color": w.value })), y = S(() => { let U = ""; return o.showScore ? U = o.scoreTemplate.replace(/\{\s*value\s*\}/, h.value ? `${o.modelValue}` : `${f.value}`) : o.showText && (U = o.texts[Math.ceil(f.value) - 1]), U; }), C = S(() => o.modelValue * 100 - Math.floor(o.modelValue) * 100), b = S(() => qe(o.colors) ? { [o.lowThreshold]: o.colors[0], [o.highThreshold]: { value: o.colors[1], excluded: !0 }, [o.max]: o.colors[2] } : o.colors), w = S(() => { const U = r(f.value, b.value); return yt(U) ? "" : U; }), T = S(() => { let U = ""; return h.value ? U = `${C.value}%` : o.allowHalf && (U = "50%"), { color: w.value, width: U }; }), E = S(() => { let U = qe(o.icons) ? [...o.icons] : { ...o.icons }; return U = Ns(U), qe(U) ? { [o.lowThreshold]: U[0], [o.highThreshold]: { value: U[1], excluded: !0 }, [o.max]: U[2] } : U; }), x = S(() => r(o.modelValue, E.value)), I = S(() => h.value ? it(o.disabledVoidIcon) ? o.disabledVoidIcon : Ns(o.disabledVoidIcon) : it(o.voidIcon) ? o.voidIcon : Ns(o.voidIcon)), L = S(() => r(f.value, E.value)); function B(U) { const D = h.value && C.value > 0 && U - 1 < o.modelValue && U > o.modelValue, j = o.allowHalf && v.value && U - .5 <= f.value && U > f.value; return D || j; } function F(U) { o.clearable && U === o.modelValue && (U = 0), n(gt, U), o.modelValue !== U && n("change", U); } function V(U) { h.value || (o.allowHalf && v.value ? F(f.value) : F(U)); } function R(U) { if (h.value)
        return; let D = f.value; const j = U.code; return j === tt.up || j === tt.right ? (o.allowHalf ? D += .5 : D += 1, U.stopPropagation(), U.preventDefault()) : (j === tt.left || j === tt.down) && (o.allowHalf ? D -= .5 : D -= 1, U.stopPropagation(), U.preventDefault()), D = D < 0 ? 0 : D, D = D > o.max ? o.max : D, n(gt, D), n("change", D), D; } function K(U, D) { if (!h.value) {
        if (o.allowHalf && D) {
            let j = D.target;
            Vo(j, u.e("item")) && (j = j.querySelector(`.${u.e("icon")}`)), (j.clientWidth === 0 || Vo(j, u.e("decimal"))) && (j = j.parentNode), v.value = D.offsetX * 2 <= j.clientWidth, f.value = v.value ? U - .5 : U;
        }
        else
            f.value = U;
        p.value = U;
    } } function te() { h.value || (o.allowHalf && (v.value = o.modelValue !== Math.floor(o.modelValue)), f.value = o.modelValue, p.value = -1); } return Oe(() => o.modelValue, U => { f.value = U, v.value = o.modelValue !== Math.floor(o.modelValue); }), o.modelValue || n(gt, 0), t({ setCurrentValue: K, resetCurrentValue: te }), (U, D) => { var j; return k(), z("div", { id: i(c), class: O([i(m), i(u).is("disabled", i(h))]), role: "slider", "aria-label": i(d) ? void 0 : U.label || "rating", "aria-labelledby": i(d) ? (j = i(l)) == null ? void 0 : j.labelId : void 0, "aria-valuenow": f.value, "aria-valuetext": i(y) || void 0, "aria-valuemin": "0", "aria-valuemax": U.max, tabindex: "0", style: et(i(g)), onKeydown: R }, [(k(!0), z(Qe, null, Et(U.max, (A, G) => (k(), z("span", { key: G, class: O(i(u).e("item")), onMousemove: se => K(A, se), onMouseleave: te, onClick: se => V(A) }, [ee(i(Je), { class: O([i(u).e("icon"), { hover: p.value === A }, i(u).is("active", A <= f.value)]) }, { default: ie(() => [B(A) ? pe("v-if", !0) : (k(), z(Qe, { key: 0 }, [dt((k(), ge(kt(i(L)), null, null, 512)), [[Pt, A <= f.value]]), dt((k(), ge(kt(i(I)), null, null, 512)), [[Pt, !(A <= f.value)]])], 64)), B(A) ? (k(), ge(i(Je), { key: 1, style: et(i(T)), class: O([i(u).e("icon"), i(u).e("decimal")]) }, { default: ie(() => [(k(), ge(kt(i(x))))]), _: 1 }, 8, ["style", "class"])) : pe("v-if", !0)]), _: 2 }, 1032, ["class"])], 42, jU))), 128)), U.showText || U.showScore ? (k(), z("span", { key: 0, class: O(i(u).e("text")) }, Be(i(y)), 3)) : pe("v-if", !0)], 46, KU); }; } });
var qU = Fe(UU, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/rate/src/rate.vue"]]);
const YU = vt(qU), il = { success: "icon-success", warning: "icon-warning", error: "icon-error", info: "icon-info" }, B0 = { [il.success]: E4, [il.warning]: xc, [il.error]: ih, [il.info]: uh }, GU = Ve({ title: { type: String, default: "" }, subTitle: { type: String, default: "" }, icon: { type: String, values: ["success", "warning", "info", "error"], default: "info" } }), XU = ae({ name: "ElResult" }), JU = ae({ ...XU, props: GU, setup(e) { const t = e, n = Ie("result"), o = S(() => { const r = t.icon, s = r && il[r] ? il[r] : "icon-info", l = B0[s] || B0["icon-info"]; return { class: s, component: l }; }); return (r, s) => (k(), z("div", { class: O(i(n).b()) }, [Q("div", { class: O(i(n).e("icon")) }, [ke(r.$slots, "icon", {}, () => [i(o).component ? (k(), ge(kt(i(o).component), { key: 0, class: O(i(o).class) }, null, 8, ["class"])) : pe("v-if", !0)])], 2), r.title || r.$slots.title ? (k(), z("div", { key: 0, class: O(i(n).e("title")) }, [ke(r.$slots, "title", {}, () => [Q("p", null, Be(r.title), 1)])], 2)) : pe("v-if", !0), r.subTitle || r.$slots["sub-title"] ? (k(), z("div", { key: 1, class: O(i(n).e("subtitle")) }, [ke(r.$slots, "sub-title", {}, () => [Q("p", null, Be(r.subTitle), 1)])], 2)) : pe("v-if", !0), r.$slots.extra ? (k(), z("div", { key: 2, class: O(i(n).e("extra")) }, [ke(r.$slots, "extra")], 2)) : pe("v-if", !0)], 2)); } });
var ZU = Fe(JU, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/result/src/result.vue"]]);
const QU = vt(ZU);
var F0 = Number.isNaN || function (t) { return typeof t == "number" && t !== t; };
function eq(e, t) { return !!(e === t || F0(e) && F0(t)); }
function tq(e, t) { if (e.length !== t.length)
    return !1; for (var n = 0; n < e.length; n++)
    if (!eq(e[n], t[n]))
        return !1; return !0; }
function nq(e, t) { t === void 0 && (t = tq); var n = null; function o() { for (var r = [], s = 0; s < arguments.length; s++)
    r[s] = arguments[s]; if (n && n.lastThis === this && t(r, n.lastArgs))
    return n.lastResult; var l = e.apply(this, r); return n = { lastResult: l, lastArgs: r, lastThis: this }, l; } return o.clear = function () { n = null; }, o; }
const S2 = () => { const t = ht().proxy.$props; return S(() => { const n = (o, r, s) => ({}); return t.perfMode ? $c(n) : nq(n); }); }, jf = 50, Ju = "itemRendered", Zu = "scroll", ul = "forward", Qu = "backward", Co = "auto", Uc = "smart", li = "start", Zo = "center", ai = "end", Fl = "horizontal", Uh = "vertical", oq = "ltr", bl = "rtl", ii = "negative", qh = "positive-ascending", Yh = "positive-descending", rq = { [Fl]: "left", [Uh]: "top" }, sq = 20, lq = { [Fl]: "deltaX", [Uh]: "deltaY" }, aq = ({ atEndEdge: e, atStartEdge: t, layout: n }, o) => { let r, s = 0; const l = u => u < 0 && t.value || u > 0 && e.value; return { hasReachedEdge: l, onWheel: u => { Pc(r); const c = u[lq[n.value]]; l(s) && l(s + c) || (s += c, Wb() || u.preventDefault(), r = Ja(() => { o(s), s = 0; })); } }; }, Wf = Wo({ type: ve([Number, Function]), required: !0 }), Uf = Wo({ type: Number }), qf = Wo({ type: Number, default: 2 }), iq = Wo({ type: String, values: ["ltr", "rtl"], default: "ltr" }), Yf = Wo({ type: Number, default: 0 }), ec = Wo({ type: Number, required: !0 }), _2 = Wo({ type: String, values: ["horizontal", "vertical"], default: Uh }), k2 = Ve({ className: { type: String, default: "" }, containerElement: { type: ve([String, Object]), default: "div" }, data: { type: ve(Array), default: () => ln([]) }, direction: iq, height: { type: [String, Number], required: !0 }, innerElement: { type: [String, Object], default: "div" }, style: { type: ve([Object, String, Array]) }, useIsScrolling: { type: Boolean, default: !1 }, width: { type: [Number, String], required: !1 }, perfMode: { type: Boolean, default: !0 }, scrollbarAlwaysOn: { type: Boolean, default: !1 } }), E2 = Ve({ cache: qf, estimatedItemSize: Uf, layout: _2, initScrollOffset: Yf, total: ec, itemSize: Wf, ...k2 }), Gf = { type: Number, default: 6 }, $2 = { type: Number, default: 0 }, T2 = { type: Number, default: 2 }, Ds = Ve({ columnCache: qf, columnWidth: Wf, estimatedColumnWidth: Uf, estimatedRowHeight: Uf, initScrollLeft: Yf, initScrollTop: Yf, itemKey: { type: ve(Function), default: ({ columnIndex: e, rowIndex: t }) => `${t}:${e}` }, rowCache: qf, rowHeight: Wf, totalColumn: ec, totalRow: ec, hScrollbarSize: Gf, vScrollbarSize: Gf, scrollbarStartGap: $2, scrollbarEndGap: T2, role: String, ...k2 }), O2 = Ve({ alwaysOn: Boolean, class: String, layout: _2, total: ec, ratio: { type: Number, required: !0 }, clientSize: { type: Number, required: !0 }, scrollFrom: { type: Number, required: !0 }, scrollbarSize: Gf, startGap: $2, endGap: T2, visible: Boolean }), Is = (e, t) => e < t ? ul : Qu, ui = e => e === oq || e === bl || e === Fl, V0 = e => e === bl;
let el = null;
function tc(e = !1) { if (el === null || e) {
    const t = document.createElement("div"), n = t.style;
    n.width = "50px", n.height = "50px", n.overflow = "scroll", n.direction = "rtl";
    const o = document.createElement("div"), r = o.style;
    return r.width = "100px", r.height = "100px", t.appendChild(o), document.body.appendChild(t), t.scrollLeft > 0 ? el = Yh : (t.scrollLeft = 1, t.scrollLeft === 0 ? el = ii : el = qh), document.body.removeChild(t), el;
} return el; }
function uq({ move: e, size: t, bar: n }, o) { const r = {}, s = `translate${n.axis}(${e}px)`; return r[n.size] = t, r.transform = s, r.msTransform = s, r.webkitTransform = s, o === "horizontal" ? r.height = "100%" : r.width = "100%", r; }
const Xf = ae({ name: "ElVirtualScrollBar", props: O2, emits: ["scroll", "start-move", "stop-move"], setup(e, { emit: t }) { const n = S(() => e.startGap + e.endGap), o = Ie("virtual-scrollbar"), r = Ie("scrollbar"), s = M(), l = M(); let a = null, u = null; const c = Lt({ isDragging: !1, traveled: 0 }), d = S(() => $w[e.layout]), f = S(() => e.clientSize - i(n)), p = S(() => ({ position: "absolute", width: `${Fl === e.layout ? f.value : e.scrollbarSize}px`, height: `${Fl === e.layout ? e.scrollbarSize : f.value}px`, [rq[e.layout]]: "2px", right: "2px", bottom: "2px", borderRadius: "4px" })), v = S(() => { const E = e.ratio, x = e.clientSize; if (E >= 100)
        return Number.POSITIVE_INFINITY; if (E >= 50)
        return E * x / 100; const I = x / 3; return Math.floor(Math.min(Math.max(E * x, sq), I)); }), m = S(() => { if (!Number.isFinite(v.value))
        return { display: "none" }; const E = `${v.value}px`; return uq({ bar: d.value, size: E, move: c.traveled }, e.layout); }), h = S(() => Math.floor(e.clientSize - v.value - i(n))), g = () => { window.addEventListener("mousemove", w), window.addEventListener("mouseup", b); const E = i(l); E && (u = document.onselectstart, document.onselectstart = () => !1, E.addEventListener("touchmove", w), E.addEventListener("touchend", b)); }, y = () => { window.removeEventListener("mousemove", w), window.removeEventListener("mouseup", b), document.onselectstart = u, u = null; const E = i(l); E && (E.removeEventListener("touchmove", w), E.removeEventListener("touchend", b)); }, C = E => { E.stopImmediatePropagation(), !(E.ctrlKey || [1, 2].includes(E.button)) && (c.isDragging = !0, c[d.value.axis] = E.currentTarget[d.value.offset] - (E[d.value.client] - E.currentTarget.getBoundingClientRect()[d.value.direction]), t("start-move"), g()); }, b = () => { c.isDragging = !1, c[d.value.axis] = 0, t("stop-move"), y(); }, w = E => { const { isDragging: x } = c; if (!x || !l.value || !s.value)
        return; const I = c[d.value.axis]; if (!I)
        return; Pc(a); const L = (s.value.getBoundingClientRect()[d.value.direction] - E[d.value.client]) * -1, B = l.value[d.value.offset] - I, F = L - B; a = Ja(() => { c.traveled = Math.max(e.startGap, Math.min(F, h.value)), t("scroll", F, h.value); }); }, T = E => { const x = Math.abs(E.target.getBoundingClientRect()[d.value.direction] - E[d.value.client]), I = l.value[d.value.offset] / 2, L = x - I; c.traveled = Math.max(0, Math.min(L, h.value)), t("scroll", L, h.value); }; return Oe(() => e.scrollFrom, E => { c.isDragging || (c.traveled = Math.ceil(E * h.value)); }), on(() => { y(); }), () => nt("div", { role: "presentation", ref: s, class: [o.b(), e.class, (e.alwaysOn || c.isDragging) && "always-on"], style: p.value, onMousedown: st(T, ["stop", "prevent"]), onTouchstartPrevent: C }, nt("div", { ref: l, class: r.e("thumb"), style: m.value, onMousedown: C }, [])); } }), I2 = ({ name: e, getOffset: t, getItemSize: n, getItemOffset: o, getEstimatedTotalSize: r, getStartIndexForOffset: s, getStopIndexForStartIndex: l, initCache: a, clearCache: u, validateProps: c }) => ae({ name: e ?? "ElVirtualList", props: E2, emits: [Ju, Zu], setup(d, { emit: f, expose: p }) { c(d); const v = ht(), m = Ie("vl"), h = M(a(d, v)), g = S2(), y = M(), C = M(), b = M(), w = M({ isScrolling: !1, scrollDir: "forward", scrollOffset: lt(d.initScrollOffset) ? d.initScrollOffset : 0, updateRequested: !1, isScrollbarDragging: !1, scrollbarAlwaysOn: d.scrollbarAlwaysOn }), T = S(() => { const { total: ce, cache: ye } = d, { isScrolling: Re, scrollDir: me, scrollOffset: le } = i(w); if (ce === 0)
        return [0, 0, 0, 0]; const oe = s(d, le, i(h)), fe = l(d, oe, le, i(h)), Ce = !Re || me === Qu ? Math.max(1, ye) : 1, Ae = !Re || me === ul ? Math.max(1, ye) : 1; return [Math.max(0, oe - Ce), Math.max(0, Math.min(ce - 1, fe + Ae)), oe, fe]; }), E = S(() => r(d, i(h))), x = S(() => ui(d.layout)), I = S(() => [{ position: "relative", [`overflow-${x.value ? "x" : "y"}`]: "scroll", WebkitOverflowScrolling: "touch", willChange: "transform" }, { direction: d.direction, height: lt(d.height) ? `${d.height}px` : d.height, width: lt(d.width) ? `${d.width}px` : d.width }, d.style]), L = S(() => { const ce = i(E), ye = i(x); return { height: ye ? "100%" : `${ce}px`, pointerEvents: i(w).isScrolling ? "none" : void 0, width: ye ? `${ce}px` : "100%" }; }), B = S(() => x.value ? d.width : d.height), { onWheel: F } = aq({ atStartEdge: S(() => w.value.scrollOffset <= 0), atEndEdge: S(() => w.value.scrollOffset >= E.value), layout: S(() => d.layout) }, ce => { var ye, Re; (Re = (ye = b.value).onMouseUp) == null || Re.call(ye), D(Math.min(w.value.scrollOffset + ce, E.value - B.value)); }), V = () => { const { total: ce } = d; if (ce > 0) {
        const [le, oe, fe, Ce] = i(T);
        f(Ju, le, oe, fe, Ce);
    } const { scrollDir: ye, scrollOffset: Re, updateRequested: me } = i(w); f(Zu, ye, Re, me); }, R = ce => { const { clientHeight: ye, scrollHeight: Re, scrollTop: me } = ce.currentTarget, le = i(w); if (le.scrollOffset === me)
        return; const oe = Math.max(0, Math.min(me, Re - ye)); w.value = { ...le, isScrolling: !0, scrollDir: Is(le.scrollOffset, oe), scrollOffset: oe, updateRequested: !1 }, Xe(G); }, K = ce => { const { clientWidth: ye, scrollLeft: Re, scrollWidth: me } = ce.currentTarget, le = i(w); if (le.scrollOffset === Re)
        return; const { direction: oe } = d; let fe = Re; if (oe === bl)
        switch (tc()) {
            case ii: {
                fe = -Re;
                break;
            }
            case Yh: {
                fe = me - ye - Re;
                break;
            }
        } fe = Math.max(0, Math.min(fe, me - ye)), w.value = { ...le, isScrolling: !0, scrollDir: Is(le.scrollOffset, fe), scrollOffset: fe, updateRequested: !1 }, Xe(G); }, te = ce => { i(x) ? K(ce) : R(ce), V(); }, U = (ce, ye) => { const Re = (E.value - B.value) / ye * ce; D(Math.min(E.value - B.value, Re)); }, D = ce => { ce = Math.max(ce, 0), ce !== i(w).scrollOffset && (w.value = { ...i(w), scrollOffset: ce, scrollDir: Is(i(w).scrollOffset, ce), updateRequested: !0 }, Xe(G)); }, j = (ce, ye = Co) => { const { scrollOffset: Re } = i(w); ce = Math.max(0, Math.min(ce, d.total - 1)), D(t(d, ce, ye, Re, i(h))); }, A = ce => { const { direction: ye, itemSize: Re, layout: me } = d, le = g.value(u && Re, u && me, u && ye); let oe; if (Tt(le, String(ce)))
        oe = le[ce];
    else {
        const fe = o(d, ce, i(h)), Ce = n(d, ce, i(h)), Ae = i(x), q = ye === bl, re = Ae ? fe : 0;
        le[ce] = oe = { position: "absolute", left: q ? void 0 : `${re}px`, right: q ? `${re}px` : void 0, top: Ae ? 0 : `${fe}px`, height: Ae ? "100%" : `${Ce}px`, width: Ae ? `${Ce}px` : "100%" };
    } return oe; }, G = () => { w.value.isScrolling = !1, Xe(() => { g.value(-1, null, null); }); }, se = () => { const ce = y.value; ce && (ce.scrollTop = 0); }; ft(() => { if (!At)
        return; const { initScrollOffset: ce } = d, ye = i(y); lt(ce) && ye && (i(x) ? ye.scrollLeft = ce : ye.scrollTop = ce), V(); }), Er(() => { const { direction: ce, layout: ye } = d, { scrollOffset: Re, updateRequested: me } = i(w), le = i(y); if (me && le)
        if (ye === Fl)
            if (ce === bl)
                switch (tc()) {
                    case ii: {
                        le.scrollLeft = -Re;
                        break;
                    }
                    case qh: {
                        le.scrollLeft = Re;
                        break;
                    }
                    default: {
                        const { clientWidth: oe, scrollWidth: fe } = le;
                        le.scrollLeft = fe - oe - Re;
                        break;
                    }
                }
            else
                le.scrollLeft = Re;
        else
            le.scrollTop = Re; }); const Z = { ns: m, clientSize: B, estimatedTotalSize: E, windowStyle: I, windowRef: y, innerRef: C, innerStyle: L, itemsToRender: T, scrollbarRef: b, states: w, getItemStyle: A, onScroll: te, onScrollbarScroll: U, onWheel: F, scrollTo: D, scrollToItem: j, resetScrollTop: se }; return p({ windowRef: y, innerRef: C, getItemStyleCache: g, scrollTo: D, scrollToItem: j, resetScrollTop: se, states: w }), Z; }, render(d) { var f; const { $slots: p, className: v, clientSize: m, containerElement: h, data: g, getItemStyle: y, innerElement: C, itemsToRender: b, innerStyle: w, layout: T, total: E, onScroll: x, onScrollbarScroll: I, onWheel: L, states: B, useIsScrolling: F, windowStyle: V, ns: R } = d, [K, te] = b, U = kt(h), D = kt(C), j = []; if (E > 0)
        for (let Z = K; Z <= te; Z++)
            j.push((f = p.default) == null ? void 0 : f.call(p, { data: g, key: Z, index: Z, isScrolling: F ? B.isScrolling : void 0, style: y(Z) })); const A = [nt(D, { style: w, ref: "innerRef" }, it(D) ? j : { default: () => j })], G = nt(Xf, { ref: "scrollbarRef", clientSize: m, layout: T, onScroll: I, ratio: m * 100 / this.estimatedTotalSize, scrollFrom: B.scrollOffset / (this.estimatedTotalSize - m), total: E }), se = nt(U, { class: [R.e("window"), v], style: V, onScroll: x, onWheel: L, ref: "windowRef", key: 0 }, it(U) ? [A] : { default: () => [A] }); return nt("div", { key: 0, class: [R.e("wrapper"), B.scrollbarAlwaysOn ? "always-on" : ""] }, [se, G]); } }), x2 = I2({ name: "ElFixedSizeList", getItemOffset: ({ itemSize: e }, t) => t * e, getItemSize: ({ itemSize: e }) => e, getEstimatedTotalSize: ({ total: e, itemSize: t }) => t * e, getOffset: ({ height: e, total: t, itemSize: n, layout: o, width: r }, s, l, a) => { const u = ui(o) ? r : e, c = Math.max(0, t * n - u), d = Math.min(c, s * n), f = Math.max(0, (s + 1) * n - u); switch (l === Uc && (a >= f - u && a <= d + u ? l = Co : l = Zo), l) {
        case li: return d;
        case ai: return f;
        case Zo: {
            const p = Math.round(f + (d - f) / 2);
            return p < Math.ceil(u / 2) ? 0 : p > c + Math.floor(u / 2) ? c : p;
        }
        case Co:
        default: return a >= f && a <= d ? a : a < f ? f : d;
    } }, getStartIndexForOffset: ({ total: e, itemSize: t }, n) => Math.max(0, Math.min(e - 1, Math.floor(n / t))), getStopIndexForStartIndex: ({ height: e, total: t, itemSize: n, layout: o, width: r }, s, l) => { const a = s * n, u = ui(o) ? r : e, c = Math.ceil((u + l - a) / n); return Math.max(0, Math.min(t - 1, s + c - 1)); }, initCache() { }, clearCache: !0, validateProps() { } }), cl = (e, t, n) => { const { itemSize: o } = e, { items: r, lastVisitedIndex: s } = n; if (t > s) {
    let l = 0;
    if (s >= 0) {
        const a = r[s];
        l = a.offset + a.size;
    }
    for (let a = s + 1; a <= t; a++) {
        const u = o(a);
        r[a] = { offset: l, size: u }, l += u;
    }
    n.lastVisitedIndex = t;
} return r[t]; }, cq = (e, t, n) => { const { items: o, lastVisitedIndex: r } = t; return (r > 0 ? o[r].offset : 0) >= n ? A2(e, t, 0, r, n) : dq(e, t, Math.max(0, r), n); }, A2 = (e, t, n, o, r) => { for (; n <= o;) {
    const s = n + Math.floor((o - n) / 2), l = cl(e, s, t).offset;
    if (l === r)
        return s;
    l < r ? n = s + 1 : l > r && (o = s - 1);
} return Math.max(0, n - 1); }, dq = (e, t, n, o) => { const { total: r } = e; let s = 1; for (; n < r && cl(e, n, t).offset < o;)
    n += s, s *= 2; return A2(e, t, Math.floor(n / 2), Math.min(n, r - 1), o); }, z0 = ({ total: e }, { items: t, estimatedItemSize: n, lastVisitedIndex: o }) => { let r = 0; if (o >= e && (o = e - 1), o >= 0) {
    const a = t[o];
    r = a.offset + a.size;
} const l = (e - o - 1) * n; return r + l; }, fq = I2({ name: "ElDynamicSizeList", getItemOffset: (e, t, n) => cl(e, t, n).offset, getItemSize: (e, t, { items: n }) => n[t].size, getEstimatedTotalSize: z0, getOffset: (e, t, n, o, r) => { const { height: s, layout: l, width: a } = e, u = ui(l) ? a : s, c = cl(e, t, r), d = z0(e, r), f = Math.max(0, Math.min(d - u, c.offset)), p = Math.max(0, c.offset - u + c.size); switch (n === Uc && (o >= p - u && o <= f + u ? n = Co : n = Zo), n) {
        case li: return f;
        case ai: return p;
        case Zo: return Math.round(p + (f - p) / 2);
        case Co:
        default: return o >= p && o <= f ? o : o < p ? p : f;
    } }, getStartIndexForOffset: (e, t, n) => cq(e, n, t), getStopIndexForStartIndex: (e, t, n, o) => { const { height: r, total: s, layout: l, width: a } = e, u = ui(l) ? a : r, c = cl(e, t, o), d = n + u; let f = c.offset + c.size, p = t; for (; p < s - 1 && f < d;)
        p++, f += cl(e, p, o).size; return p; }, initCache({ estimatedItemSize: e = jf }, t) { const n = { items: {}, estimatedItemSize: e, lastVisitedIndex: -1 }; return n.clearCacheAfterIndex = (o, r = !0) => { var s, l; n.lastVisitedIndex = Math.min(n.lastVisitedIndex, o - 1), (s = t.exposed) == null || s.getItemStyleCache(-1), r && ((l = t.proxy) == null || l.$forceUpdate()); }, n; }, clearCache: !1, validateProps: ({ itemSize: e }) => { } }), pq = ({ atXEndEdge: e, atXStartEdge: t, atYEndEdge: n, atYStartEdge: o }, r) => { let s = null, l = 0, a = 0; const u = (d, f) => { const p = d <= 0 && t.value || d >= 0 && e.value, v = f <= 0 && o.value || f >= 0 && n.value; return p && v; }; return { hasReachedEdge: u, onWheel: d => { Pc(s); let f = d.deltaX, p = d.deltaY; Math.abs(f) > Math.abs(p) ? p = 0 : f = 0, d.shiftKey && p !== 0 && (f = p, p = 0), !(u(l, a) && u(l + f, a + p)) && (l += f, a += p, d.preventDefault(), s = Ja(() => { r(l, a), l = 0, a = 0; })); } }; }, M2 = ({ name: e, clearCache: t, getColumnPosition: n, getColumnStartIndexForOffset: o, getColumnStopIndexForStartIndex: r, getEstimatedTotalHeight: s, getEstimatedTotalWidth: l, getColumnOffset: a, getRowOffset: u, getRowPosition: c, getRowStartIndexForOffset: d, getRowStopIndexForStartIndex: f, initCache: p, injectToInstance: v, validateProps: m }) => ae({ name: e ?? "ElVirtualList", props: Ds, emits: [Ju, Zu], setup(h, { emit: g, expose: y, slots: C }) { const b = Ie("vl"); m(h); const w = ht(), T = M(p(h, w)); v == null || v(w, T); const E = M(), x = M(), I = M(), L = M(null), B = M({ isScrolling: !1, scrollLeft: lt(h.initScrollLeft) ? h.initScrollLeft : 0, scrollTop: lt(h.initScrollTop) ? h.initScrollTop : 0, updateRequested: !1, xAxisScrollDir: ul, yAxisScrollDir: ul }), F = S2(), V = S(() => Number.parseInt(`${h.height}`, 10)), R = S(() => Number.parseInt(`${h.width}`, 10)), K = S(() => { const { totalColumn: Se, totalRow: De, columnCache: Me } = h, { isScrolling: $e, xAxisScrollDir: Pe, scrollLeft: He } = i(B); if (Se === 0 || De === 0)
        return [0, 0, 0, 0]; const je = o(h, He, i(T)), Ue = r(h, je, He, i(T)), Te = !$e || Pe === Qu ? Math.max(1, Me) : 1, Ge = !$e || Pe === ul ? Math.max(1, Me) : 1; return [Math.max(0, je - Te), Math.max(0, Math.min(Se - 1, Ue + Ge)), je, Ue]; }), te = S(() => { const { totalColumn: Se, totalRow: De, rowCache: Me } = h, { isScrolling: $e, yAxisScrollDir: Pe, scrollTop: He } = i(B); if (Se === 0 || De === 0)
        return [0, 0, 0, 0]; const je = d(h, He, i(T)), Ue = f(h, je, He, i(T)), Te = !$e || Pe === Qu ? Math.max(1, Me) : 1, Ge = !$e || Pe === ul ? Math.max(1, Me) : 1; return [Math.max(0, je - Te), Math.max(0, Math.min(De - 1, Ue + Ge)), je, Ue]; }), U = S(() => s(h, i(T))), D = S(() => l(h, i(T))), j = S(() => { var Se; return [{ position: "relative", overflow: "hidden", WebkitOverflowScrolling: "touch", willChange: "transform" }, { direction: h.direction, height: lt(h.height) ? `${h.height}px` : h.height, width: lt(h.width) ? `${h.width}px` : h.width }, (Se = h.style) != null ? Se : {}]; }), A = S(() => { const Se = `${i(D)}px`; return { height: `${i(U)}px`, pointerEvents: i(B).isScrolling ? "none" : void 0, width: Se }; }), G = () => { const { totalColumn: Se, totalRow: De } = h; if (Se > 0 && De > 0) {
        const [Ue, Te, Ge, W] = i(K), [X, $, Y, H] = i(te);
        g(Ju, { columnCacheStart: Ue, columnCacheEnd: Te, rowCacheStart: X, rowCacheEnd: $, columnVisibleStart: Ge, columnVisibleEnd: W, rowVisibleStart: Y, rowVisibleEnd: H });
    } const { scrollLeft: Me, scrollTop: $e, updateRequested: Pe, xAxisScrollDir: He, yAxisScrollDir: je } = i(B); g(Zu, { xAxisScrollDir: He, scrollLeft: Me, yAxisScrollDir: je, scrollTop: $e, updateRequested: Pe }); }, se = Se => { const { clientHeight: De, clientWidth: Me, scrollHeight: $e, scrollLeft: Pe, scrollTop: He, scrollWidth: je } = Se.currentTarget, Ue = i(B); if (Ue.scrollTop === He && Ue.scrollLeft === Pe)
        return; let Te = Pe; if (V0(h.direction))
        switch (tc()) {
            case ii:
                Te = -Pe;
                break;
            case Yh:
                Te = je - Me - Pe;
                break;
        } B.value = { ...Ue, isScrolling: !0, scrollLeft: Te, scrollTop: Math.max(0, Math.min(He, $e - De)), updateRequested: !0, xAxisScrollDir: Is(Ue.scrollLeft, Te), yAxisScrollDir: Is(Ue.scrollTop, He) }, Xe(() => oe()), fe(), G(); }, Z = (Se, De) => { const Me = i(V), $e = (U.value - Me) / De * Se; Re({ scrollTop: Math.min(U.value - Me, $e) }); }, ce = (Se, De) => { const Me = i(R), $e = (D.value - Me) / De * Se; Re({ scrollLeft: Math.min(D.value - Me, $e) }); }, { onWheel: ye } = pq({ atXStartEdge: S(() => B.value.scrollLeft <= 0), atXEndEdge: S(() => B.value.scrollLeft >= D.value - i(R)), atYStartEdge: S(() => B.value.scrollTop <= 0), atYEndEdge: S(() => B.value.scrollTop >= U.value - i(V)) }, (Se, De) => { var Me, $e, Pe, He; ($e = (Me = x.value) == null ? void 0 : Me.onMouseUp) == null || $e.call(Me), (He = (Pe = I.value) == null ? void 0 : Pe.onMouseUp) == null || He.call(Pe); const je = i(R), Ue = i(V); Re({ scrollLeft: Math.min(B.value.scrollLeft + Se, D.value - je), scrollTop: Math.min(B.value.scrollTop + De, U.value - Ue) }); }), Re = ({ scrollLeft: Se = B.value.scrollLeft, scrollTop: De = B.value.scrollTop }) => { Se = Math.max(Se, 0), De = Math.max(De, 0); const Me = i(B); De === Me.scrollTop && Se === Me.scrollLeft || (B.value = { ...Me, xAxisScrollDir: Is(Me.scrollLeft, Se), yAxisScrollDir: Is(Me.scrollTop, De), scrollLeft: Se, scrollTop: De, updateRequested: !0 }, Xe(() => oe()), fe(), G()); }, me = (Se = 0, De = 0, Me = Co) => { const $e = i(B); De = Math.max(0, Math.min(De, h.totalColumn - 1)), Se = Math.max(0, Math.min(Se, h.totalRow - 1)); const Pe = I1(b.namespace.value), He = i(T), je = s(h, He), Ue = l(h, He); Re({ scrollLeft: a(h, De, Me, $e.scrollLeft, He, Ue > h.width ? Pe : 0), scrollTop: u(h, Se, Me, $e.scrollTop, He, je > h.height ? Pe : 0) }); }, le = (Se, De) => { const { columnWidth: Me, direction: $e, rowHeight: Pe } = h, He = F.value(t && Me, t && Pe, t && $e), je = `${Se},${De}`; if (Tt(He, je))
        return He[je]; {
        const [, Ue] = n(h, De, i(T)), Te = i(T), Ge = V0($e), [W, X] = c(h, Se, Te), [$] = n(h, De, Te);
        return He[je] = { position: "absolute", left: Ge ? void 0 : `${Ue}px`, right: Ge ? `${Ue}px` : void 0, top: `${X}px`, height: `${W}px`, width: `${$}px` }, He[je];
    } }, oe = () => { B.value.isScrolling = !1, Xe(() => { F.value(-1, null, null); }); }; ft(() => { if (!At)
        return; const { initScrollLeft: Se, initScrollTop: De } = h, Me = i(E); Me && (lt(Se) && (Me.scrollLeft = Se), lt(De) && (Me.scrollTop = De)), G(); }); const fe = () => { const { direction: Se } = h, { scrollLeft: De, scrollTop: Me, updateRequested: $e } = i(B), Pe = i(E); if ($e && Pe) {
        if (Se === bl)
            switch (tc()) {
                case ii: {
                    Pe.scrollLeft = -De;
                    break;
                }
                case qh: {
                    Pe.scrollLeft = De;
                    break;
                }
                default: {
                    const { clientWidth: He, scrollWidth: je } = Pe;
                    Pe.scrollLeft = je - He - De;
                    break;
                }
            }
        else
            Pe.scrollLeft = Math.max(0, De);
        Pe.scrollTop = Math.max(0, Me);
    } }, { resetAfterColumnIndex: Ce, resetAfterRowIndex: Ae, resetAfter: q } = w.proxy; y({ windowRef: E, innerRef: L, getItemStyleCache: F, scrollTo: Re, scrollToItem: me, states: B, resetAfterColumnIndex: Ce, resetAfterRowIndex: Ae, resetAfter: q }); const re = () => { const { scrollbarAlwaysOn: Se, scrollbarStartGap: De, scrollbarEndGap: Me, totalColumn: $e, totalRow: Pe } = h, He = i(R), je = i(V), Ue = i(D), Te = i(U), { scrollLeft: Ge, scrollTop: W } = i(B), X = nt(Xf, { ref: x, alwaysOn: Se, startGap: De, endGap: Me, class: b.e("horizontal"), clientSize: He, layout: "horizontal", onScroll: ce, ratio: He * 100 / Ue, scrollFrom: Ge / (Ue - He), total: Pe, visible: !0 }), $ = nt(Xf, { ref: I, alwaysOn: Se, startGap: De, endGap: Me, class: b.e("vertical"), clientSize: je, layout: "vertical", onScroll: Z, ratio: je * 100 / Te, scrollFrom: W / (Te - je), total: $e, visible: !0 }); return { horizontalScrollbar: X, verticalScrollbar: $ }; }, he = () => { var Se; const [De, Me] = i(K), [$e, Pe] = i(te), { data: He, totalColumn: je, totalRow: Ue, useIsScrolling: Te, itemKey: Ge } = h, W = []; if (Ue > 0 && je > 0)
        for (let X = $e; X <= Pe; X++)
            for (let $ = De; $ <= Me; $++)
                W.push((Se = C.default) == null ? void 0 : Se.call(C, { columnIndex: $, data: He, key: Ge({ columnIndex: $, data: He, rowIndex: X }), isScrolling: Te ? i(B).isScrolling : void 0, style: le(X, $), rowIndex: X })); return W; }, Ee = () => { const Se = kt(h.innerElement), De = he(); return [nt(Se, { style: i(A), ref: L }, it(Se) ? De : { default: () => De })]; }; return () => { const Se = kt(h.containerElement), { horizontalScrollbar: De, verticalScrollbar: Me } = re(), $e = Ee(); return nt("div", { key: 0, class: b.e("wrapper"), role: h.role }, [nt(Se, { class: h.className, style: i(j), onScroll: se, onWheel: ye, ref: E }, it(Se) ? $e : { default: () => $e }), De, Me]); }; } }), hq = M2({ name: "ElFixedSizeGrid", getColumnPosition: ({ columnWidth: e }, t) => [e, t * e], getRowPosition: ({ rowHeight: e }, t) => [e, t * e], getEstimatedTotalHeight: ({ totalRow: e, rowHeight: t }) => t * e, getEstimatedTotalWidth: ({ totalColumn: e, columnWidth: t }) => t * e, getColumnOffset: ({ totalColumn: e, columnWidth: t, width: n }, o, r, s, l, a) => { n = Number(n); const u = Math.max(0, e * t - n), c = Math.min(u, o * t), d = Math.max(0, o * t - n + a + t); switch (r === "smart" && (s >= d - n && s <= c + n ? r = Co : r = Zo), r) {
        case li: return c;
        case ai: return d;
        case Zo: {
            const f = Math.round(d + (c - d) / 2);
            return f < Math.ceil(n / 2) ? 0 : f > u + Math.floor(n / 2) ? u : f;
        }
        case Co:
        default: return s >= d && s <= c ? s : d > c || s < d ? d : c;
    } }, getRowOffset: ({ rowHeight: e, height: t, totalRow: n }, o, r, s, l, a) => { t = Number(t); const u = Math.max(0, n * e - t), c = Math.min(u, o * e), d = Math.max(0, o * e - t + a + e); switch (r === Uc && (s >= d - t && s <= c + t ? r = Co : r = Zo), r) {
        case li: return c;
        case ai: return d;
        case Zo: {
            const f = Math.round(d + (c - d) / 2);
            return f < Math.ceil(t / 2) ? 0 : f > u + Math.floor(t / 2) ? u : f;
        }
        case Co:
        default: return s >= d && s <= c ? s : d > c || s < d ? d : c;
    } }, getColumnStartIndexForOffset: ({ columnWidth: e, totalColumn: t }, n) => Math.max(0, Math.min(t - 1, Math.floor(n / e))), getColumnStopIndexForStartIndex: ({ columnWidth: e, totalColumn: t, width: n }, o, r) => { const s = o * e, l = Math.ceil((n + r - s) / e); return Math.max(0, Math.min(t - 1, o + l - 1)); }, getRowStartIndexForOffset: ({ rowHeight: e, totalRow: t }, n) => Math.max(0, Math.min(t - 1, Math.floor(n / e))), getRowStopIndexForStartIndex: ({ rowHeight: e, totalRow: t, height: n }, o, r) => { const s = o * e, l = Math.ceil((n + r - s) / e); return Math.max(0, Math.min(t - 1, o + l - 1)); }, initCache: () => { }, clearCache: !0, validateProps: ({ columnWidth: e, rowHeight: t }) => { } }), { max: nc, min: N2, floor: P2 } = Math, vq = { column: "columnWidth", row: "rowHeight" }, Jf = { column: "lastVisitedColumnIndex", row: "lastVisitedRowIndex" }, vr = (e, t, n, o) => { const [r, s, l] = [n[o], e[vq[o]], n[Jf[o]]]; if (t > l) {
    let a = 0;
    if (l >= 0) {
        const u = r[l];
        a = u.offset + u.size;
    }
    for (let u = l + 1; u <= t; u++) {
        const c = s(u);
        r[u] = { offset: a, size: c }, a += c;
    }
    n[Jf[o]] = t;
} return r[t]; }, R2 = (e, t, n, o, r, s) => { for (; n <= o;) {
    const l = n + P2((o - n) / 2), a = vr(e, l, t, s).offset;
    if (a === r)
        return l;
    a < r ? n = l + 1 : o = l - 1;
} return nc(0, n - 1); }, mq = (e, t, n, o, r) => { const s = r === "column" ? e.totalColumn : e.totalRow; let l = 1; for (; n < s && vr(e, n, t, r).offset < o;)
    n += l, l *= 2; return R2(e, t, P2(n / 2), N2(n, s - 1), o, r); }, H0 = (e, t, n, o) => { const [r, s] = [t[o], t[Jf[o]]]; return (s > 0 ? r[s].offset : 0) >= n ? R2(e, t, 0, s, n, o) : mq(e, t, nc(0, s), n, o); }, L2 = ({ totalRow: e }, { estimatedRowHeight: t, lastVisitedRowIndex: n, row: o }) => { let r = 0; if (n >= e && (n = e - 1), n >= 0) {
    const a = o[n];
    r = a.offset + a.size;
} const l = (e - n - 1) * t; return r + l; }, D2 = ({ totalColumn: e }, { column: t, estimatedColumnWidth: n, lastVisitedColumnIndex: o }) => { let r = 0; if (o > e && (o = e - 1), o >= 0) {
    const a = t[o];
    r = a.offset + a.size;
} const l = (e - o - 1) * n; return r + l; }, gq = { column: D2, row: L2 }, K0 = (e, t, n, o, r, s, l) => { const [a, u] = [s === "row" ? e.height : e.width, gq[s]], c = vr(e, t, r, s), d = u(e, r), f = nc(0, N2(d - a, c.offset)), p = nc(0, c.offset - a + l + c.size); switch (n === Uc && (o >= p - a && o <= f + a ? n = Co : n = Zo), n) {
    case li: return f;
    case ai: return p;
    case Zo: return Math.round(p + (f - p) / 2);
    case Co:
    default: return o >= p && o <= f ? o : p > f || o < p ? p : f;
} }, yq = M2({ name: "ElDynamicSizeGrid", getColumnPosition: (e, t, n) => { const o = vr(e, t, n, "column"); return [o.size, o.offset]; }, getRowPosition: (e, t, n) => { const o = vr(e, t, n, "row"); return [o.size, o.offset]; }, getColumnOffset: (e, t, n, o, r, s) => K0(e, t, n, o, r, "column", s), getRowOffset: (e, t, n, o, r, s) => K0(e, t, n, o, r, "row", s), getColumnStartIndexForOffset: (e, t, n) => H0(e, n, t, "column"), getColumnStopIndexForStartIndex: (e, t, n, o) => { const r = vr(e, t, o, "column"), s = n + e.width; let l = r.offset + r.size, a = t; for (; a < e.totalColumn - 1 && l < s;)
        a++, l += vr(e, t, o, "column").size; return a; }, getEstimatedTotalHeight: L2, getEstimatedTotalWidth: D2, getRowStartIndexForOffset: (e, t, n) => H0(e, n, t, "row"), getRowStopIndexForStartIndex: (e, t, n, o) => { const { totalRow: r, height: s } = e, l = vr(e, t, o, "row"), a = n + s; let u = l.size + l.offset, c = t; for (; c < r - 1 && u < a;)
        c++, u += vr(e, c, o, "row").size; return c; }, injectToInstance: (e, t) => { const n = ({ columnIndex: s, rowIndex: l }, a) => { var u, c; a = En(a) ? !0 : a, lt(s) && (t.value.lastVisitedColumnIndex = Math.min(t.value.lastVisitedColumnIndex, s - 1)), lt(l) && (t.value.lastVisitedRowIndex = Math.min(t.value.lastVisitedRowIndex, l - 1)), (u = e.exposed) == null || u.getItemStyleCache.value(-1, null, null), a && ((c = e.proxy) == null || c.$forceUpdate()); }, o = (s, l) => { n({ columnIndex: s }, l); }, r = (s, l) => { n({ rowIndex: s }, l); }; Object.assign(e.proxy, { resetAfterColumnIndex: o, resetAfterRowIndex: r, resetAfter: n }); }, initCache: ({ estimatedColumnWidth: e = jf, estimatedRowHeight: t = jf }) => ({ column: {}, estimatedColumnWidth: e, estimatedRowHeight: t, lastVisitedColumnIndex: -1, lastVisitedRowIndex: -1, row: {} }), clearCache: !1, validateProps: ({ columnWidth: e, rowHeight: t }) => { } }), bq = ae({ props: { item: { type: Object, required: !0 }, style: Object, height: Number }, setup() { return { ns: Ie("select") }; } });
function wq(e, t, n, o, r, s) { return e.item.isTitle ? (k(), z("div", { key: 0, class: O(e.ns.be("group", "title")), style: et([e.style, { lineHeight: `${e.height}px` }]) }, Be(e.item.label), 7)) : (k(), z("div", { key: 1, class: O(e.ns.be("group", "split")), style: et(e.style) }, [Q("span", { class: O(e.ns.be("group", "split-dash")), style: et({ top: `${e.height / 2}px` }) }, null, 6)], 6)); }
var Cq = Fe(bq, [["render", wq], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/group-item.vue"]]);
function Sq(e, { emit: t }) { return { hoverItem: () => { e.disabled || t("hover", e.index); }, selectOptionClick: () => { e.disabled || t("select", e.item, e.index); } }; }
const _q = { allowCreate: Boolean, autocomplete: { type: String, default: "none" }, automaticDropdown: Boolean, clearable: Boolean, clearIcon: { type: [String, Object], default: ls }, effect: { type: String, default: "light" }, collapseTags: Boolean, collapseTagsTooltip: { type: Boolean, default: !1 }, maxCollapseTags: { type: Number, default: 1 }, defaultFirstOption: Boolean, disabled: Boolean, estimatedOptionHeight: { type: Number, default: void 0 }, filterable: Boolean, filterMethod: Function, height: { type: Number, default: 170 }, itemHeight: { type: Number, default: 34 }, id: String, loading: Boolean, loadingText: String, label: String, modelValue: [Array, String, Number, Boolean, Object], multiple: Boolean, multipleLimit: { type: Number, default: 0 }, name: String, noDataText: String, noMatchText: String, remoteMethod: Function, reserveKeyword: { type: Boolean, default: !0 }, options: { type: Array, required: !0 }, placeholder: { type: String }, teleported: On.teleported, persistent: { type: Boolean, default: !0 }, popperClass: { type: String, default: "" }, popperOptions: { type: Object, default: () => ({}) }, remote: Boolean, size: { type: String, validator: Mc }, valueKey: { type: String, default: "value" }, scrollbarAlwaysOn: { type: Boolean, default: !1 }, validateEvent: { type: Boolean, default: !0 }, placement: { type: ve(String), values: Ys, default: "bottom-start" } }, kq = { data: Array, disabled: Boolean, hovering: Boolean, item: Object, index: Number, style: Object, selected: Boolean, created: Boolean }, Eq = ae({ props: kq, emits: ["select", "hover"], setup(e, { emit: t }) { const n = Ie("select"), { hoverItem: o, selectOptionClick: r } = Sq(e, { emit: t }); return { ns: n, hoverItem: o, selectOptionClick: r }; } }), $q = ["aria-selected"];
function Tq(e, t, n, o, r, s) { return k(), z("li", { "aria-selected": e.selected, style: et(e.style), class: O([e.ns.be("dropdown", "option-item"), e.ns.is("selected", e.selected), e.ns.is("disabled", e.disabled), e.ns.is("created", e.created), { hover: e.hovering }]), onMouseenter: t[0] || (t[0] = (...l) => e.hoverItem && e.hoverItem(...l)), onClick: t[1] || (t[1] = st((...l) => e.selectOptionClick && e.selectOptionClick(...l), ["stop"])) }, [ke(e.$slots, "default", { item: e.item, index: e.index, disabled: e.disabled }, () => [Q("span", null, Be(e.item.label), 1)])], 46, $q); }
var Oq = Fe(Eq, [["render", Tq], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/option-item.vue"]]);
const B2 = Symbol("ElSelectV2Injection");
var Iq = ae({ name: "ElSelectDropdown", props: { data: { type: Array, required: !0 }, hoveringIndex: Number, width: Number }, setup(e, { slots: t, expose: n }) { const o = Ye(B2), r = Ie("select"), s = M([]), l = M(), a = S(() => e.data.length); Oe(() => a.value, () => { var I, L; (L = (I = o.popper.value).updatePopper) == null || L.call(I); }); const u = S(() => En(o.props.estimatedOptionHeight)), c = S(() => u.value ? { itemSize: o.props.itemHeight } : { estimatedSize: o.props.estimatedOptionHeight, itemSize: I => s.value[I] }), d = (I = [], L) => { const { props: { valueKey: B } } = o; return yt(L) ? I && I.some(F => sn(F, B) === sn(L, B)) : I.includes(L); }, f = (I, L) => { if (yt(L)) {
        const { valueKey: B } = o.props;
        return sn(I, B) === sn(L, B);
    }
    else
        return I === L; }, p = (I, L) => { const { valueKey: B } = o.props; return o.props.multiple ? d(I, sn(L, B)) : f(I, sn(L, B)); }, v = (I, L) => { const { disabled: B, multiple: F, multipleLimit: V } = o.props; return B || !L && (F ? V > 0 && I.length >= V : !1); }, m = I => e.hoveringIndex === I; n({ listRef: l, isSized: u, isItemDisabled: v, isItemHovering: m, isItemSelected: p, scrollToItem: I => { const L = l.value; L && L.scrollToItem(I); }, resetScrollTop: () => { const I = l.value; I && I.resetScrollTop(); } }); const y = I => { const { index: L, data: B, style: F } = I, V = i(u), { itemSize: R, estimatedSize: K } = i(c), { modelValue: te } = o.props, { onSelect: U, onHover: D } = o, j = B[L]; if (j.type === "Group")
        return ee(Cq, { item: j, style: F, height: V ? R : K }, null); const A = p(te, j), G = v(te, A), se = m(L); return ee(Oq, Ct(I, { selected: A, disabled: j.disabled || G, created: !!j.created, hovering: se, item: j, onSelect: U, onHover: D }), { default: Z => { var ce; return ((ce = t.default) == null ? void 0 : ce.call(t, Z)) || ee("span", null, [j.label]); } }); }, { onKeyboardNavigate: C, onKeyboardSelect: b } = o, w = () => { C("forward"); }, T = () => { C("backward"); }, E = () => { o.expanded = !1; }, x = I => { const { code: L } = I, { tab: B, esc: F, down: V, up: R, enter: K } = tt; switch (L !== B && (I.preventDefault(), I.stopPropagation()), L) {
        case B:
        case F: {
            E();
            break;
        }
        case V: {
            w();
            break;
        }
        case R: {
            T();
            break;
        }
        case K: {
            b();
            break;
        }
    } }; return () => { var I; const { data: L, width: B } = e, { height: F, multiple: V, scrollbarAlwaysOn: R } = o.props; if (L.length === 0)
        return ee("div", { class: r.b("dropdown"), style: { width: `${B}px` } }, [(I = t.empty) == null ? void 0 : I.call(t)]); const K = i(u) ? x2 : fq; return ee("div", { class: [r.b("dropdown"), r.is("multiple", V)] }, [ee(K, Ct({ ref: l }, i(c), { className: r.be("dropdown", "list"), scrollbarAlwaysOn: R, data: L, height: F, width: B, total: L.length, onKeydown: x }), { default: te => ee(y, te, null) })]); }; } });
function xq(e, t) { const n = M(0), o = M(null), r = S(() => e.allowCreate && e.filterable); function s(d) { const f = p => p.value === d; return e.options && e.options.some(f) || t.createdOptions.some(f); } function l(d) { r.value && (e.multiple && d.created ? n.value++ : o.value = d); } function a(d) { if (r.value)
    if (d && d.length > 0 && !s(d)) {
        const f = { value: d, label: d, created: !0, disabled: !1 };
        t.createdOptions.length >= n.value ? t.createdOptions[n.value] = f : t.createdOptions.push(f);
    }
    else if (e.multiple)
        t.createdOptions.length = n.value;
    else {
        const f = o.value;
        t.createdOptions.length = 0, f && f.created && t.createdOptions.push(f);
    } } function u(d) { if (!r.value || !d || !d.created || d.created && e.reserveKeyword && t.inputValue === d.label)
    return; const f = t.createdOptions.findIndex(p => p.value === d.value); ~f && (t.createdOptions.splice(f, 1), n.value--); } function c() { r.value && (t.createdOptions.length = 0, n.value = 0); } return { createNewOption: a, removeNewOption: u, selectNewOption: l, clearAllNewOption: c }; }
const Aq = e => { const t = []; return e.forEach(n => { qe(n.options) ? (t.push({ label: n.label, isTitle: !0, type: "Group" }), n.options.forEach(o => { t.push(o); }), t.push({ type: "Group" })) : t.push(n); }), t; };
function Mq(e) { const t = M(!1); return { handleCompositionStart: () => { t.value = !0; }, handleCompositionUpdate: s => { const l = s.target.value, a = l[l.length - 1] || ""; t.value = !Nc(a); }, handleCompositionEnd: s => { t.value && (t.value = !1, at(e) && e(s)); } }; }
const j0 = "", W0 = 11, Nq = { larget: 51, default: 42, small: 33 }, Pq = (e, t) => { const { t: n } = Nt(), o = Ie("select-v2"), r = Ie("input"), { form: s, formItem: l } = Zn(), a = Lt({ inputValue: j0, displayInputValue: j0, calculatedWidth: 0, cachedPlaceholder: "", cachedOptions: [], createdOptions: [], createdLabel: "", createdSelected: !1, currentPlaceholder: "", hoveringIndex: -1, comboBoxHovering: !1, isOnComposition: !1, isSilentBlur: !1, isComposing: !1, inputLength: 20, selectWidth: 200, initialInputHeight: 0, previousQuery: null, previousValue: void 0, query: "", selectedLabel: "", softFocus: !1, tagInMultiLine: !1 }), u = M(-1), c = M(-1), d = M(null), f = M(null), p = M(null), v = M(null), m = M(null), h = M(null), g = M(null), y = M(!1), C = S(() => e.disabled || (s == null ? void 0 : s.disabled)), b = S(() => { const Le = V.value.length * 34; return Le > e.height ? e.height : Le; }), w = S(() => !bn(e.modelValue)), T = S(() => { const Le = e.multiple ? Array.isArray(e.modelValue) && e.modelValue.length > 0 : w.value; return e.clearable && !C.value && a.comboBoxHovering && Le; }), E = S(() => e.remote && e.filterable ? "" : Ic), x = S(() => E.value && o.is("reverse", y.value)), I = S(() => (l == null ? void 0 : l.validateState) || ""), L = S(() => B1[I.value]), B = S(() => e.remote ? 300 : 0), F = S(() => { const Le = V.value; return e.loading ? e.loadingText || n("el.select.loading") : e.remote && a.inputValue === "" && Le.length === 0 ? !1 : e.filterable && a.inputValue && Le.length > 0 ? e.noMatchText || n("el.select.noMatch") : Le.length === 0 ? e.noDataText || n("el.select.noData") : null; }), V = S(() => { const Le = ot => { const wt = a.inputValue, zt = new RegExp(T1(wt), "i"); return wt ? zt.test(ot.label || "") : !0; }; return e.loading ? [] : Aq(e.options.concat(a.createdOptions).map(ot => { if (qe(ot.options)) {
    const wt = ot.options.filter(Le);
    if (wt.length > 0)
        return { ...ot, options: wt };
}
else if (e.remote || Le(ot))
    return ot; return null; }).filter(ot => ot !== null)); }), R = S(() => { const Le = new Map; return V.value.forEach((ot, wt) => { Le.set(He(ot), { option: ot, index: wt }); }), Le; }), K = S(() => V.value.every(Le => Le.disabled)), te = kn(), U = S(() => te.value === "small" ? "small" : "default"), D = S(() => { const Le = h.value, ot = U.value || "default", wt = Le ? Number.parseInt(getComputedStyle(Le).paddingLeft) : 0, zt = Le ? Number.parseInt(getComputedStyle(Le).paddingRight) : 0; return a.selectWidth - zt - wt - Nq[ot]; }), j = () => { var Le; c.value = ((Le = m.value) == null ? void 0 : Le.offsetWidth) || 200; }, A = S(() => ({ width: `${a.calculatedWidth === 0 ? W0 : Math.ceil(a.calculatedWidth) + W0}px` })), G = S(() => qe(e.modelValue) ? e.modelValue.length === 0 && !a.displayInputValue : e.filterable ? a.displayInputValue.length === 0 : !0), se = S(() => { const Le = e.placeholder || n("el.select.placeholder"); return e.multiple || bn(e.modelValue) ? Le : a.selectedLabel; }), Z = S(() => { var Le, ot; return (ot = (Le = v.value) == null ? void 0 : Le.popperRef) == null ? void 0 : ot.contentRef; }), ce = S(() => { if (e.multiple) {
    const Le = e.modelValue.length;
    if (e.modelValue.length > 0 && R.value.has(e.modelValue[Le - 1])) {
        const { index: ot } = R.value.get(e.modelValue[Le - 1]);
        return ot;
    }
}
else if (e.modelValue && R.value.has(e.modelValue)) {
    const { index: Le } = R.value.get(e.modelValue);
    return Le;
} return -1; }), ye = S({ get() { return y.value && F.value !== !1; }, set(Le) { y.value = Le; } }), Re = S(() => a.cachedOptions.slice(0, e.maxCollapseTags)), me = S(() => a.cachedOptions.slice(e.maxCollapseTags)), { createNewOption: le, removeNewOption: oe, selectNewOption: fe, clearAllNewOption: Ce } = xq(e, a), { handleCompositionStart: Ae, handleCompositionUpdate: q, handleCompositionEnd: re } = Mq(Le => ze(Le)), he = () => { var Le, ot, wt; (ot = (Le = f.value) == null ? void 0 : Le.focus) == null || ot.call(Le), (wt = v.value) == null || wt.updatePopper(); }, Ee = () => { if (!e.automaticDropdown && !C.value)
    return a.isComposing && (a.softFocus = !0), Xe(() => { var Le, ot; y.value = !y.value, (ot = (Le = f.value) == null ? void 0 : Le.focus) == null || ot.call(Le); }); }, Ne = () => (e.filterable && a.inputValue !== a.selectedLabel && (a.query = a.selectedLabel), De(a.inputValue), Xe(() => { le(a.inputValue); })), Se = Xn(Ne, B.value), De = Le => { a.previousQuery !== Le && (a.previousQuery = Le, e.filterable && at(e.filterMethod) ? e.filterMethod(Le) : e.filterable && e.remote && at(e.remoteMethod) && e.remoteMethod(Le)); }, Me = Le => { ro(e.modelValue, Le) || t(en, Le); }, $e = Le => { t(gt, Le), Me(Le), a.previousValue = Le == null ? void 0 : Le.toString(); }, Pe = (Le = [], ot) => { if (!yt(ot))
    return Le.indexOf(ot); const wt = e.valueKey; let zt = -1; return Le.some((Qn, Mn) => sn(Qn, wt) === sn(ot, wt) ? (zt = Mn, !0) : !1), zt; }, He = Le => yt(Le) ? sn(Le, e.valueKey) : Le, je = Le => yt(Le) ? Le.label : Le, Ue = () => Xe(() => { var Le, ot; if (!f.value)
    return; const wt = h.value; m.value.height = wt.offsetHeight, y.value && F.value !== !1 && ((ot = (Le = v.value) == null ? void 0 : Le.updatePopper) == null || ot.call(Le)); }), Te = () => { var Le, ot; if (Ge(), j(), (ot = (Le = v.value) == null ? void 0 : Le.updatePopper) == null || ot.call(Le), e.multiple)
    return Ue(); }, Ge = () => { const Le = h.value; Le && (a.selectWidth = Le.getBoundingClientRect().width); }, W = (Le, ot, wt = !0) => { var zt, Qn; if (e.multiple) {
    let Mn = e.modelValue.slice();
    const Ir = Pe(Mn, He(Le));
    Ir > -1 ? (Mn = [...Mn.slice(0, Ir), ...Mn.slice(Ir + 1)], a.cachedOptions.splice(Ir, 1), oe(Le)) : (e.multipleLimit <= 0 || Mn.length < e.multipleLimit) && (Mn = [...Mn, He(Le)], a.cachedOptions.push(Le), fe(Le), Ke(ot)), $e(Mn), Le.created && (a.query = "", De(""), a.inputLength = 20), e.filterable && !e.reserveKeyword && ((Qn = (zt = f.value).focus) == null || Qn.call(zt), be("")), e.filterable && (a.calculatedWidth = g.value.getBoundingClientRect().width), Ue(), _e();
}
else
    u.value = ot, a.selectedLabel = Le.label, $e(He(Le)), y.value = !1, a.isComposing = !1, a.isSilentBlur = wt, fe(Le), Le.created || Ce(), Ke(ot); }, X = (Le, ot) => { const { valueKey: wt } = e, zt = e.modelValue.indexOf(sn(ot, wt)); if (zt > -1 && !C.value) {
    const Qn = [...e.modelValue.slice(0, zt), ...e.modelValue.slice(zt + 1)];
    return a.cachedOptions.splice(zt, 1), $e(Qn), t("remove-tag", sn(ot, wt)), a.softFocus = !0, oe(ot), Xe(he);
} Le.stopPropagation(); }, $ = Le => { const ot = a.isComposing; a.isComposing = !0, a.softFocus ? a.softFocus = !1 : ot || t("focus", Le); }, Y = Le => (a.softFocus = !1, Xe(() => { var ot, wt; (wt = (ot = f.value) == null ? void 0 : ot.blur) == null || wt.call(ot), g.value && (a.calculatedWidth = g.value.getBoundingClientRect().width), a.isSilentBlur ? a.isSilentBlur = !1 : a.isComposing && t("blur", Le), a.isComposing = !1; })), H = () => { a.displayInputValue.length > 0 ? be("") : y.value = !1; }, ue = Le => { if (a.displayInputValue.length === 0) {
    Le.preventDefault();
    const ot = e.modelValue.slice();
    ot.pop(), oe(a.cachedOptions.pop()), $e(ot);
} }, de = () => { let Le; return qe(e.modelValue) ? Le = [] : Le = void 0, a.softFocus = !0, e.multiple ? a.cachedOptions = [] : a.selectedLabel = "", y.value = !1, $e(Le), t("clear"), Ce(), Xe(he); }, be = Le => { a.displayInputValue = Le, a.inputValue = Le; }, J = (Le, ot = void 0) => { const wt = V.value; if (!["forward", "backward"].includes(Le) || C.value || wt.length <= 0 || K.value)
    return; if (!y.value)
    return Ee(); ot === void 0 && (ot = a.hoveringIndex); let zt = -1; Le === "forward" ? (zt = ot + 1, zt >= wt.length && (zt = 0)) : Le === "backward" && (zt = ot - 1, (zt < 0 || zt >= wt.length) && (zt = wt.length - 1)); const Qn = wt[zt]; if (Qn.disabled || Qn.type === "Group")
    return J(Le, zt); Ke(zt), rn(zt); }, we = () => { if (y.value)
    ~a.hoveringIndex && V.value[a.hoveringIndex] && W(V.value[a.hoveringIndex], a.hoveringIndex, !1);
else
    return Ee(); }, Ke = Le => { a.hoveringIndex = Le; }, rt = () => { a.hoveringIndex = -1; }, _e = () => { var Le; const ot = f.value; ot && ((Le = ot.focus) == null || Le.call(ot)); }, ze = Le => { const ot = Le.target.value; if (be(ot), a.displayInputValue.length > 0 && !y.value && (y.value = !0), a.calculatedWidth = g.value.getBoundingClientRect().width, e.multiple && Ue(), e.remote)
    Se();
else
    return Ne(); }, We = () => (y.value = !1, Y()), ut = () => (a.inputValue = a.displayInputValue, Xe(() => { ~ce.value && (Ke(ce.value), rn(a.hoveringIndex)); })), rn = Le => { p.value.scrollToItem(Le); }, Rt = () => { if (rt(), e.multiple)
    if (e.modelValue.length > 0) {
        let Le = !1;
        a.cachedOptions.length = 0, a.previousValue = e.modelValue.toString();
        for (const ot of e.modelValue)
            if (R.value.has(ot)) {
                const { index: wt, option: zt } = R.value.get(ot);
                a.cachedOptions.push(zt), Le || Ke(wt), Le = !0;
            }
    }
    else
        a.cachedOptions = [], a.previousValue = void 0;
else if (w.value) {
    a.previousValue = e.modelValue;
    const Le = V.value, ot = Le.findIndex(wt => He(wt) === He(e.modelValue));
    ~ot ? (a.selectedLabel = Le[ot].label, Ke(ot)) : a.selectedLabel = `${e.modelValue}`;
}
else
    a.selectedLabel = "", a.previousValue = void 0; Ce(), j(); }; return Oe(y, Le => { var ot, wt; t("visible-change", Le), Le ? (wt = (ot = v.value).update) == null || wt.call(ot) : (a.displayInputValue = "", a.previousQuery = null, le("")); }), Oe(() => e.modelValue, (Le, ot) => { var wt; (!Le || Le.toString() !== a.previousValue) && Rt(), !ro(Le, ot) && e.validateEvent && ((wt = l == null ? void 0 : l.validate) == null || wt.call(l, "change").catch(zt => void 0)); }, { deep: !0 }), Oe(() => e.options, () => { const Le = f.value; (!Le || Le && document.activeElement !== Le) && Rt(); }, { deep: !0 }), Oe(V, () => Xe(p.value.resetScrollTop)), Oe(() => ye.value, Le => { Le || rt(); }), ft(() => { Rt(); }), Vn(m, Te), { collapseTagSize: U, currentPlaceholder: se, expanded: y, emptyText: F, popupHeight: b, debounce: B, filteredOptions: V, iconComponent: E, iconReverse: x, inputWrapperStyle: A, popperSize: c, dropdownMenuVisible: ye, hasModelValue: w, shouldShowPlaceholder: G, selectDisabled: C, selectSize: te, showClearBtn: T, states: a, tagMaxWidth: D, nsSelectV2: o, nsInput: r, calculatorRef: g, controlRef: d, inputRef: f, menuRef: p, popper: v, selectRef: m, selectionRef: h, popperRef: Z, validateState: I, validateIcon: L, showTagList: Re, collapseTagList: me, debouncedOnInputChange: Se, deleteTag: X, getLabel: je, getValueKey: He, handleBlur: Y, handleClear: de, handleClickOutside: We, handleDel: ue, handleEsc: H, handleFocus: $, handleMenuEnter: ut, handleResize: Te, toggleMenu: Ee, scrollTo: rn, onInput: ze, onKeyboardNavigate: J, onKeyboardSelect: we, onSelect: W, onHover: Ke, onUpdateInputValue: be, handleCompositionStart: Ae, handleCompositionEnd: re, handleCompositionUpdate: q }; }, Rq = ae({ name: "ElSelectV2", components: { ElSelectMenu: Iq, ElTag: ri, ElTooltip: Jn, ElIcon: Je }, directives: { ClickOutside: ns, ModelText: Fp }, props: _q, emits: [gt, en, "remove-tag", "clear", "visible-change", "focus", "blur"], setup(e, { emit: t }) { const n = S(() => { const { modelValue: r, multiple: s } = e, l = s ? [] : void 0; return qe(r) ? s ? r : l : s ? l : r; }), o = Pq(Lt({ ...Sn(e), modelValue: n }), t); return St(B2, { props: Lt({ ...Sn(e), height: o.popupHeight, modelValue: n }), popper: o.popper, onSelect: o.onSelect, onHover: o.onHover, onKeyboardNavigate: o.onKeyboardNavigate, onKeyboardSelect: o.onKeyboardSelect }), { ...o, modelValue: n }; } }), Lq = { key: 0 }, Dq = ["id", "autocomplete", "aria-expanded", "aria-labelledby", "disabled", "readonly", "name", "unselectable"], Bq = ["textContent"], Fq = ["id", "aria-labelledby", "aria-expanded", "autocomplete", "disabled", "name", "readonly", "unselectable"], Vq = ["textContent"];
function zq(e, t, n, o, r, s) { const l = ct("el-tag"), a = ct("el-tooltip"), u = ct("el-icon"), c = ct("el-select-menu"), d = Va("model-text"), f = Va("click-outside"); return dt((k(), z("div", { ref: "selectRef", class: O([e.nsSelectV2.b(), e.nsSelectV2.m(e.selectSize)]), onClick: t[24] || (t[24] = st((...p) => e.toggleMenu && e.toggleMenu(...p), ["stop"])), onMouseenter: t[25] || (t[25] = p => e.states.comboBoxHovering = !0), onMouseleave: t[26] || (t[26] = p => e.states.comboBoxHovering = !1) }, [ee(a, { ref: "popper", visible: e.dropdownMenuVisible, teleported: e.teleported, "popper-class": [e.nsSelectV2.e("popper"), e.popperClass], "gpu-acceleration": !1, "stop-popper-mouse-event": !1, "popper-options": e.popperOptions, "fallback-placements": ["bottom-start", "top-start", "right", "left"], effect: e.effect, placement: e.placement, pure: "", transition: `${e.nsSelectV2.namespace.value}-zoom-in-top`, trigger: "click", persistent: e.persistent, onBeforeShow: e.handleMenuEnter, onHide: t[23] || (t[23] = p => e.states.inputValue = e.states.displayInputValue) }, { default: ie(() => [Q("div", { ref: "selectionRef", class: O([e.nsSelectV2.e("wrapper"), e.nsSelectV2.is("focused", e.states.isComposing || e.expanded), e.nsSelectV2.is("hovering", e.states.comboBoxHovering), e.nsSelectV2.is("filterable", e.filterable), e.nsSelectV2.is("disabled", e.selectDisabled)]) }, [e.$slots.prefix ? (k(), z("div", Lq, [ke(e.$slots, "prefix")])) : pe("v-if", !0), e.multiple ? (k(), z("div", { key: 1, class: O(e.nsSelectV2.e("selection")) }, [e.collapseTags && e.modelValue.length > 0 ? (k(), z(Qe, { key: 0 }, [(k(!0), z(Qe, null, Et(e.showTagList, p => (k(), z("div", { key: e.getValueKey(p), class: O(e.nsSelectV2.e("selected-item")) }, [ee(l, { closable: !e.selectDisabled && !(p != null && p.disable), size: e.collapseTagSize, type: "info", "disable-transitions": "", onClose: v => e.deleteTag(v, p) }, { default: ie(() => [Q("span", { class: O(e.nsSelectV2.e("tags-text")), style: et({ maxWidth: `${e.tagMaxWidth}px` }) }, Be(p == null ? void 0 : p.label), 7)]), _: 2 }, 1032, ["closable", "size", "onClose"])], 2))), 128)), Q("div", { class: O(e.nsSelectV2.e("selected-item")) }, [e.modelValue.length > e.maxCollapseTags ? (k(), ge(l, { key: 0, closable: !1, size: e.collapseTagSize, type: "info", "disable-transitions": "" }, { default: ie(() => [e.collapseTagsTooltip ? (k(), ge(a, { key: 0, disabled: e.dropdownMenuVisible, "fallback-placements": ["bottom", "top", "right", "left"], effect: e.effect, placement: "bottom", teleported: !1 }, { default: ie(() => [Q("span", { class: O(e.nsSelectV2.e("tags-text")), style: et({ maxWidth: `${e.tagMaxWidth}px` }) }, "+ " + Be(e.modelValue.length - e.maxCollapseTags), 7)]), content: ie(() => [Q("div", { class: O(e.nsSelectV2.e("selection")) }, [(k(!0), z(Qe, null, Et(e.collapseTagList, p => (k(), z("div", { key: e.getValueKey(p), class: O(e.nsSelectV2.e("selected-item")) }, [ee(l, { closable: !e.selectDisabled && !p.disabled, size: e.collapseTagSize, class: "in-tooltip", type: "info", "disable-transitions": "", onClose: v => e.deleteTag(v, p) }, { default: ie(() => [Q("span", { class: O(e.nsSelectV2.e("tags-text")), style: et({ maxWidth: `${e.tagMaxWidth}px` }) }, Be(e.getLabel(p)), 7)]), _: 2 }, 1032, ["closable", "size", "onClose"])], 2))), 128))], 2)]), _: 1 }, 8, ["disabled", "effect"])) : (k(), z("span", { key: 1, class: O(e.nsSelectV2.e("tags-text")), style: et({ maxWidth: `${e.tagMaxWidth}px` }) }, "+ " + Be(e.modelValue.length - e.maxCollapseTags), 7))]), _: 1 }, 8, ["size"])) : pe("v-if", !0)], 2)], 64)) : (k(!0), z(Qe, { key: 1 }, Et(e.states.cachedOptions, p => (k(), z("div", { key: e.getValueKey(p), class: O(e.nsSelectV2.e("selected-item")) }, [ee(l, { closable: !e.selectDisabled && !p.disabled, size: e.collapseTagSize, type: "info", "disable-transitions": "", onClose: v => e.deleteTag(v, p) }, { default: ie(() => [Q("span", { class: O(e.nsSelectV2.e("tags-text")), style: et({ maxWidth: `${e.tagMaxWidth}px` }) }, Be(e.getLabel(p)), 7)]), _: 2 }, 1032, ["closable", "size", "onClose"])], 2))), 128)), Q("div", { class: O([e.nsSelectV2.e("selected-item"), e.nsSelectV2.e("input-wrapper")]), style: et(e.inputWrapperStyle) }, [dt(Q("input", { id: e.id, ref: "inputRef", autocomplete: e.autocomplete, "aria-autocomplete": "list", "aria-haspopup": "listbox", autocapitalize: "off", "aria-expanded": e.expanded, "aria-labelledby": e.label, class: O([e.nsSelectV2.is(e.selectSize), e.nsSelectV2.e("combobox-input")]), disabled: e.disabled, role: "combobox", readonly: !e.filterable, spellcheck: "false", type: "text", name: e.name, unselectable: e.expanded ? "on" : void 0, "onUpdate:modelValue": t[0] || (t[0] = (...p) => e.onUpdateInputValue && e.onUpdateInputValue(...p)), onFocus: t[1] || (t[1] = (...p) => e.handleFocus && e.handleFocus(...p)), onBlur: t[2] || (t[2] = (...p) => e.handleBlur && e.handleBlur(...p)), onInput: t[3] || (t[3] = (...p) => e.onInput && e.onInput(...p)), onCompositionstart: t[4] || (t[4] = (...p) => e.handleCompositionStart && e.handleCompositionStart(...p)), onCompositionupdate: t[5] || (t[5] = (...p) => e.handleCompositionUpdate && e.handleCompositionUpdate(...p)), onCompositionend: t[6] || (t[6] = (...p) => e.handleCompositionEnd && e.handleCompositionEnd(...p)), onKeydown: [t[7] || (t[7] = Mt(st(p => e.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])), t[8] || (t[8] = Mt(st(p => e.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])), t[9] || (t[9] = Mt(st((...p) => e.onKeyboardSelect && e.onKeyboardSelect(...p), ["stop", "prevent"]), ["enter"])), t[10] || (t[10] = Mt(st((...p) => e.handleEsc && e.handleEsc(...p), ["stop", "prevent"]), ["esc"])), t[11] || (t[11] = Mt(st((...p) => e.handleDel && e.handleDel(...p), ["stop"]), ["delete"]))] }, null, 42, Dq), [[d, e.states.displayInputValue]]), e.filterable ? (k(), z("span", { key: 0, ref: "calculatorRef", "aria-hidden": "true", class: O(e.nsSelectV2.e("input-calculator")), textContent: Be(e.states.displayInputValue) }, null, 10, Bq)) : pe("v-if", !0)], 6)], 2)) : (k(), z(Qe, { key: 2 }, [Q("div", { class: O([e.nsSelectV2.e("selected-item"), e.nsSelectV2.e("input-wrapper")]) }, [dt(Q("input", { id: e.id, ref: "inputRef", "aria-autocomplete": "list", "aria-haspopup": "listbox", "aria-labelledby": e.label, "aria-expanded": e.expanded, autocapitalize: "off", autocomplete: e.autocomplete, class: O(e.nsSelectV2.e("combobox-input")), disabled: e.disabled, name: e.name, role: "combobox", readonly: !e.filterable, spellcheck: "false", type: "text", unselectable: e.expanded ? "on" : void 0, onCompositionstart: t[12] || (t[12] = (...p) => e.handleCompositionStart && e.handleCompositionStart(...p)), onCompositionupdate: t[13] || (t[13] = (...p) => e.handleCompositionUpdate && e.handleCompositionUpdate(...p)), onCompositionend: t[14] || (t[14] = (...p) => e.handleCompositionEnd && e.handleCompositionEnd(...p)), onFocus: t[15] || (t[15] = (...p) => e.handleFocus && e.handleFocus(...p)), onBlur: t[16] || (t[16] = (...p) => e.handleBlur && e.handleBlur(...p)), onInput: t[17] || (t[17] = (...p) => e.onInput && e.onInput(...p)), onKeydown: [t[18] || (t[18] = Mt(st(p => e.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])), t[19] || (t[19] = Mt(st(p => e.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])), t[20] || (t[20] = Mt(st((...p) => e.onKeyboardSelect && e.onKeyboardSelect(...p), ["stop", "prevent"]), ["enter"])), t[21] || (t[21] = Mt(st((...p) => e.handleEsc && e.handleEsc(...p), ["stop", "prevent"]), ["esc"]))], "onUpdate:modelValue": t[22] || (t[22] = (...p) => e.onUpdateInputValue && e.onUpdateInputValue(...p)) }, null, 42, Fq), [[d, e.states.displayInputValue]])], 2), e.filterable ? (k(), z("span", { key: 0, ref: "calculatorRef", "aria-hidden": "true", class: O([e.nsSelectV2.e("selected-item"), e.nsSelectV2.e("input-calculator")]), textContent: Be(e.states.displayInputValue) }, null, 10, Vq)) : pe("v-if", !0)], 64)), e.shouldShowPlaceholder ? (k(), z("span", { key: 3, class: O([e.nsSelectV2.e("placeholder"), e.nsSelectV2.is("transparent", e.multiple ? e.modelValue.length === 0 : !e.hasModelValue)]) }, Be(e.currentPlaceholder), 3)) : pe("v-if", !0), Q("span", { class: O(e.nsSelectV2.e("suffix")) }, [e.iconComponent ? dt((k(), ge(u, { key: 0, class: O([e.nsSelectV2.e("caret"), e.nsInput.e("icon"), e.iconReverse]) }, { default: ie(() => [(k(), ge(kt(e.iconComponent)))]), _: 1 }, 8, ["class"])), [[Pt, !e.showClearBtn]]) : pe("v-if", !0), e.showClearBtn && e.clearIcon ? (k(), ge(u, { key: 1, class: O([e.nsSelectV2.e("caret"), e.nsInput.e("icon")]), onClick: st(e.handleClear, ["prevent", "stop"]) }, { default: ie(() => [(k(), ge(kt(e.clearIcon)))]), _: 1 }, 8, ["class", "onClick"])) : pe("v-if", !0), e.validateState && e.validateIcon ? (k(), ge(u, { key: 2, class: O([e.nsInput.e("icon"), e.nsInput.e("validateIcon")]) }, { default: ie(() => [(k(), ge(kt(e.validateIcon)))]), _: 1 }, 8, ["class"])) : pe("v-if", !0)], 2)], 2)]), content: ie(() => [ee(c, { ref: "menuRef", data: e.filteredOptions, width: e.popperSize, "hovering-index": e.states.hoveringIndex, "scrollbar-always-on": e.scrollbarAlwaysOn }, { default: ie(p => [ke(e.$slots, "default", Lo(yc(p)))]), empty: ie(() => [ke(e.$slots, "empty", {}, () => [Q("p", { class: O(e.nsSelectV2.e("empty")) }, Be(e.emptyText ? e.emptyText : ""), 3)])]), _: 3 }, 8, ["data", "width", "hovering-index", "scrollbar-always-on"])]), _: 3 }, 8, ["visible", "teleported", "popper-class", "popper-options", "effect", "placement", "transition", "persistent", "onBeforeShow"])], 34)), [[f, e.handleClickOutside, e.popperRef]]); }
var _u = Fe(Rq, [["render", zq], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/select.vue"]]);
_u.install = e => { e.component(_u.name, _u); };
const Hq = _u, Kq = Hq, jq = Ve({ animated: { type: Boolean, default: !1 }, count: { type: Number, default: 1 }, rows: { type: Number, default: 3 }, loading: { type: Boolean, default: !0 }, throttle: { type: Number } }), Wq = Ve({ variant: { type: String, values: ["circle", "rect", "h1", "h3", "text", "caption", "p", "image", "button"], default: "text" } }), Uq = ae({ name: "ElSkeletonItem" }), qq = ae({ ...Uq, props: Wq, setup(e) { const t = Ie("skeleton"); return (n, o) => (k(), z("div", { class: O([i(t).e("item"), i(t).e(n.variant)]) }, [n.variant === "image" ? (k(), ge(i(hP), { key: 0 })) : pe("v-if", !0)], 2)); } });
var oc = Fe(qq, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton-item.vue"]]);
const Yq = ae({ name: "ElSkeleton" }), Gq = ae({ ...Yq, props: jq, setup(e, { expose: t }) { const n = e, o = Ie("skeleton"), r = h6(an(n, "loading"), n.throttle); return t({ uiLoading: r }), (s, l) => i(r) ? (k(), z("div", Ct({ key: 0, class: [i(o).b(), i(o).is("animated", s.animated)] }, s.$attrs), [(k(!0), z(Qe, null, Et(s.count, a => (k(), z(Qe, { key: a }, [s.loading ? ke(s.$slots, "template", { key: a }, () => [ee(oc, { class: O(i(o).is("first")), variant: "p" }, null, 8, ["class"]), (k(!0), z(Qe, null, Et(s.rows, u => (k(), ge(oc, { key: u, class: O([i(o).e("paragraph"), i(o).is("last", u === s.rows && s.rows > 1)]), variant: "p" }, null, 8, ["class"]))), 128))]) : pe("v-if", !0)], 64))), 128))], 16)) : ke(s.$slots, "default", Lo(Ct({ key: 1 }, s.$attrs))); } });
var Xq = Fe(Gq, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton.vue"]]);
const Jq = vt(Xq, { SkeletonItem: oc }), Zq = pn(oc), F2 = Symbol("sliderContextKey"), Qq = Ve({ modelValue: { type: ve([Number, Array]), default: 0 }, id: { type: String, default: void 0 }, min: { type: Number, default: 0 }, max: { type: Number, default: 100 }, step: { type: Number, default: 1 }, showInput: Boolean, showInputControls: { type: Boolean, default: !0 }, size: Bn, inputSize: Bn, showStops: Boolean, showTooltip: { type: Boolean, default: !0 }, formatTooltip: { type: ve(Function), default: void 0 }, disabled: Boolean, range: Boolean, vertical: Boolean, height: String, debounce: { type: Number, default: 300 }, label: { type: String, default: void 0 }, rangeStartLabel: { type: String, default: void 0 }, rangeEndLabel: { type: String, default: void 0 }, formatValueText: { type: ve(Function), default: void 0 }, tooltipClass: { type: String, default: void 0 }, placement: { type: String, values: Ys, default: "top" }, marks: { type: ve(Object) }, validateEvent: { type: Boolean, default: !0 } }), Dd = e => lt(e) || qe(e) && e.every(lt), eY = { [gt]: Dd, [qn]: Dd, [en]: Dd }, tY = (e, t, n) => { const o = M(); return ft(async () => { e.range ? (Array.isArray(e.modelValue) ? (t.firstValue = Math.max(e.min, e.modelValue[0]), t.secondValue = Math.min(e.max, e.modelValue[1])) : (t.firstValue = e.min, t.secondValue = e.max), t.oldValue = [t.firstValue, t.secondValue]) : (typeof e.modelValue != "number" || Number.isNaN(e.modelValue) ? t.firstValue = e.min : t.firstValue = Math.min(e.max, Math.max(e.min, e.modelValue)), t.oldValue = t.firstValue), nn(window, "resize", n), await Xe(), n(); }), { sliderWrapper: o }; }, nY = e => S(() => e.marks ? Object.keys(e.marks).map(Number.parseFloat).sort((n, o) => n - o).filter(n => n <= e.max && n >= e.min).map(n => ({ point: n, position: (n - e.min) * 100 / (e.max - e.min), mark: e.marks[n] })) : []), oY = (e, t, n) => { const { form: o, formItem: r } = Zn(), s = Xt(), l = M(), a = M(), u = { firstButton: l, secondButton: a }, c = S(() => e.disabled || (o == null ? void 0 : o.disabled) || !1), d = S(() => Math.min(t.firstValue, t.secondValue)), f = S(() => Math.max(t.firstValue, t.secondValue)), p = S(() => e.range ? `${100 * (f.value - d.value) / (e.max - e.min)}%` : `${100 * (t.firstValue - e.min) / (e.max - e.min)}%`), v = S(() => e.range ? `${100 * (d.value - e.min) / (e.max - e.min)}%` : "0%"), m = S(() => e.vertical ? { height: e.height } : {}), h = S(() => e.vertical ? { height: p.value, bottom: v.value } : { width: p.value, left: v.value }), g = () => { s.value && (t.sliderSize = s.value[`client${e.vertical ? "Height" : "Width"}`]); }, y = F => { const V = e.min + F * (e.max - e.min) / 100; if (!e.range)
    return l; let R; return Math.abs(d.value - V) < Math.abs(f.value - V) ? R = t.firstValue < t.secondValue ? "firstButton" : "secondButton" : R = t.firstValue > t.secondValue ? "firstButton" : "secondButton", u[R]; }, C = F => { const V = y(F); return V.value.setPosition(F), V; }, b = F => { t.firstValue = F, T(e.range ? [d.value, f.value] : F); }, w = F => { t.secondValue = F, e.range && T([d.value, f.value]); }, T = F => { n(gt, F), n(qn, F); }, E = async () => { await Xe(), n(en, e.range ? [d.value, f.value] : e.modelValue); }, x = F => { var V, R, K, te, U, D; if (c.value || t.dragging)
    return; g(); let j = 0; if (e.vertical) {
    const A = (K = (R = (V = F.touches) == null ? void 0 : V.item(0)) == null ? void 0 : R.clientY) != null ? K : F.clientY;
    j = (s.value.getBoundingClientRect().bottom - A) / t.sliderSize * 100;
}
else {
    const A = (D = (U = (te = F.touches) == null ? void 0 : te.item(0)) == null ? void 0 : U.clientX) != null ? D : F.clientX, G = s.value.getBoundingClientRect().left;
    j = (A - G) / t.sliderSize * 100;
} if (!(j < 0 || j > 100))
    return C(j); }; return { elFormItem: r, slider: s, firstButton: l, secondButton: a, sliderDisabled: c, minValue: d, maxValue: f, runwayStyle: m, barStyle: h, resetSize: g, setPosition: C, emitChange: E, onSliderWrapperPrevent: F => { var V, R; ((V = u.firstButton.value) != null && V.dragging || (R = u.secondButton.value) != null && R.dragging) && F.preventDefault(); }, onSliderClick: F => { x(F) && E(); }, onSliderDown: async (F) => { const V = x(F); V && (await Xe(), V.value.onButtonDown(F)); }, setFirstValue: b, setSecondValue: w }; }, { left: rY, down: sY, right: lY, up: aY, home: iY, end: uY, pageUp: cY, pageDown: dY } = tt, fY = (e, t, n) => { const o = M(), r = M(!1), s = S(() => t.value instanceof Function), l = S(() => s.value && t.value(e.modelValue) || e.modelValue), a = Xn(() => { n.value && (r.value = !0); }, 50), u = Xn(() => { n.value && (r.value = !1); }, 50); return { tooltip: o, tooltipVisible: r, formatValue: l, displayTooltip: a, hideTooltip: u }; }, pY = (e, t, n) => { const { disabled: o, min: r, max: s, step: l, showTooltip: a, precision: u, sliderSize: c, formatTooltip: d, emitChange: f, resetSize: p, updateDragging: v } = Ye(F2), { tooltip: m, tooltipVisible: h, formatValue: g, displayTooltip: y, hideTooltip: C } = fY(e, d, a), b = M(), w = S(() => `${(e.modelValue - r.value) / (s.value - r.value) * 100}%`), T = S(() => e.vertical ? { bottom: w.value } : { left: w.value }), E = () => { t.hovering = !0, y(); }, x = () => { t.hovering = !1, t.dragging || C(); }, I = Z => { o.value || (Z.preventDefault(), j(Z), window.addEventListener("mousemove", A), window.addEventListener("touchmove", A), window.addEventListener("mouseup", G), window.addEventListener("touchend", G), window.addEventListener("contextmenu", G), b.value.focus()); }, L = Z => { o.value || (t.newPosition = Number.parseFloat(w.value) + Z / (s.value - r.value) * 100, se(t.newPosition), f()); }, B = () => { L(-l.value); }, F = () => { L(l.value); }, V = () => { L(-l.value * 4); }, R = () => { L(l.value * 4); }, K = () => { o.value || (se(0), f()); }, te = () => { o.value || (se(100), f()); }, U = Z => { let ce = !0; [rY, sY].includes(Z.key) ? B() : [lY, aY].includes(Z.key) ? F() : Z.key === iY ? K() : Z.key === uY ? te() : Z.key === dY ? V() : Z.key === cY ? R() : ce = !1, ce && Z.preventDefault(); }, D = Z => { let ce, ye; return Z.type.startsWith("touch") ? (ye = Z.touches[0].clientY, ce = Z.touches[0].clientX) : (ye = Z.clientY, ce = Z.clientX), { clientX: ce, clientY: ye }; }, j = Z => { t.dragging = !0, t.isClick = !0; const { clientX: ce, clientY: ye } = D(Z); e.vertical ? t.startY = ye : t.startX = ce, t.startPosition = Number.parseFloat(w.value), t.newPosition = t.startPosition; }, A = Z => { if (t.dragging) {
    t.isClick = !1, y(), p();
    let ce;
    const { clientX: ye, clientY: Re } = D(Z);
    e.vertical ? (t.currentY = Re, ce = (t.startY - t.currentY) / c.value * 100) : (t.currentX = ye, ce = (t.currentX - t.startX) / c.value * 100), t.newPosition = t.startPosition + ce, se(t.newPosition);
} }, G = () => { t.dragging && (setTimeout(() => { t.dragging = !1, t.hovering || C(), t.isClick || se(t.newPosition), f(); }, 0), window.removeEventListener("mousemove", A), window.removeEventListener("touchmove", A), window.removeEventListener("mouseup", G), window.removeEventListener("touchend", G), window.removeEventListener("contextmenu", G)); }, se = async (Z) => { if (Z === null || Number.isNaN(+Z))
    return; Z < 0 ? Z = 0 : Z > 100 && (Z = 100); const ce = 100 / ((s.value - r.value) / l.value); let Re = Math.round(Z / ce) * ce * (s.value - r.value) * .01 + r.value; Re = Number.parseFloat(Re.toFixed(u.value)), Re !== e.modelValue && n(gt, Re), !t.dragging && e.modelValue !== t.oldValue && (t.oldValue = e.modelValue), await Xe(), t.dragging && y(), m.value.updatePopper(); }; return Oe(() => t.dragging, Z => { v(Z); }), { disabled: o, button: b, tooltip: m, tooltipVisible: h, showTooltip: a, wrapperStyle: T, formatValue: g, handleMouseEnter: E, handleMouseLeave: x, onButtonDown: I, onKeyDown: U, setPosition: se }; }, hY = (e, t, n, o) => ({ stops: S(() => { if (!e.showStops || e.min > e.max)
        return []; if (e.step === 0)
        return []; const l = (e.max - e.min) / e.step, a = 100 * e.step / (e.max - e.min), u = Array.from({ length: l - 1 }).map((c, d) => (d + 1) * a); return e.range ? u.filter(c => c < 100 * (n.value - e.min) / (e.max - e.min) || c > 100 * (o.value - e.min) / (e.max - e.min)) : u.filter(c => c > 100 * (t.firstValue - e.min) / (e.max - e.min)); }), getStopStyle: l => e.vertical ? { bottom: `${l}%` } : { left: `${l}%` } }), vY = (e, t, n, o, r, s) => { const l = c => { r(gt, c), r(qn, c); }, a = () => e.range ? ![n.value, o.value].every((c, d) => c === t.oldValue[d]) : e.modelValue !== t.oldValue, u = () => { var c, d; e.min > e.max && _n("Slider", "min should not be greater than max."); const f = e.modelValue; e.range && Array.isArray(f) ? f[1] < e.min ? l([e.min, e.min]) : f[0] > e.max ? l([e.max, e.max]) : f[0] < e.min ? l([e.min, f[1]]) : f[1] > e.max ? l([f[0], e.max]) : (t.firstValue = f[0], t.secondValue = f[1], a() && (e.validateEvent && ((c = s == null ? void 0 : s.validate) == null || c.call(s, "change").catch(p => void 0)), t.oldValue = f.slice())) : !e.range && typeof f == "number" && !Number.isNaN(f) && (f < e.min ? l(e.min) : f > e.max ? l(e.max) : (t.firstValue = f, a() && (e.validateEvent && ((d = s == null ? void 0 : s.validate) == null || d.call(s, "change").catch(p => void 0)), t.oldValue = f))); }; u(), Oe(() => t.dragging, c => { c || u(); }), Oe(() => e.modelValue, (c, d) => { t.dragging || Array.isArray(c) && Array.isArray(d) && c.every((f, p) => f === d[p]) && t.firstValue === c[0] && t.secondValue === c[1] || u(); }, { deep: !0 }), Oe(() => [e.min, e.max], () => { u(); }); }, mY = Ve({ modelValue: { type: Number, default: 0 }, vertical: Boolean, tooltipClass: String, placement: { type: String, values: Ys, default: "top" } }), gY = { [gt]: e => lt(e) }, yY = ["tabindex"], bY = ae({ name: "ElSliderButton" }), wY = ae({ ...bY, props: mY, emits: gY, setup(e, { expose: t, emit: n }) { const o = e, r = Ie("slider"), s = Lt({ hovering: !1, dragging: !1, isClick: !1, startX: 0, currentX: 0, startY: 0, currentY: 0, startPosition: 0, newPosition: 0, oldValue: o.modelValue }), { disabled: l, button: a, tooltip: u, showTooltip: c, tooltipVisible: d, wrapperStyle: f, formatValue: p, handleMouseEnter: v, handleMouseLeave: m, onButtonDown: h, onKeyDown: g, setPosition: y } = pY(o, s, n), { hovering: C, dragging: b } = Sn(s); return t({ onButtonDown: h, onKeyDown: g, setPosition: y, hovering: C, dragging: b }), (w, T) => (k(), z("div", { ref_key: "button", ref: a, class: O([i(r).e("button-wrapper"), { hover: i(C), dragging: i(b) }]), style: et(i(f)), tabindex: i(l) ? -1 : 0, onMouseenter: T[0] || (T[0] = (...E) => i(v) && i(v)(...E)), onMouseleave: T[1] || (T[1] = (...E) => i(m) && i(m)(...E)), onMousedown: T[2] || (T[2] = (...E) => i(h) && i(h)(...E)), onTouchstart: T[3] || (T[3] = (...E) => i(h) && i(h)(...E)), onFocus: T[4] || (T[4] = (...E) => i(v) && i(v)(...E)), onBlur: T[5] || (T[5] = (...E) => i(m) && i(m)(...E)), onKeydown: T[6] || (T[6] = (...E) => i(g) && i(g)(...E)) }, [ee(i(Jn), { ref_key: "tooltip", ref: u, visible: i(d), placement: w.placement, "fallback-placements": ["top", "bottom", "right", "left"], "stop-popper-mouse-event": !1, "popper-class": w.tooltipClass, disabled: !i(c), persistent: "" }, { content: ie(() => [Q("span", null, Be(i(p)), 1)]), default: ie(() => [Q("div", { class: O([i(r).e("button"), { hover: i(C), dragging: i(b) }]) }, null, 2)]), _: 1 }, 8, ["visible", "placement", "popper-class", "disabled"])], 46, yY)); } });
var U0 = Fe(wY, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/button.vue"]]);
const CY = Ve({ mark: { type: ve([String, Object]), default: void 0 } });
var SY = ae({ name: "ElSliderMarker", props: CY, setup(e) { const t = Ie("slider"), n = S(() => it(e.mark) ? e.mark : e.mark.label), o = S(() => it(e.mark) ? void 0 : e.mark.style); return () => nt("div", { class: t.e("marks-text"), style: o.value }, n.value); } });
const _Y = ["id", "role", "aria-label", "aria-labelledby"], kY = { key: 1 }, EY = ae({ name: "ElSlider" }), $Y = ae({ ...EY, props: Qq, emits: eY, setup(e, { expose: t, emit: n }) { const o = e, r = Ie("slider"), { t: s } = Nt(), l = Lt({ firstValue: 0, secondValue: 0, oldValue: 0, dragging: !1, sliderSize: 1 }), { elFormItem: a, slider: u, firstButton: c, secondButton: d, sliderDisabled: f, minValue: p, maxValue: v, runwayStyle: m, barStyle: h, resetSize: g, emitChange: y, onSliderWrapperPrevent: C, onSliderClick: b, onSliderDown: w, setFirstValue: T, setSecondValue: E } = oY(o, l, n), { stops: x, getStopStyle: I } = hY(o, l, p, v), { inputId: L, isLabeledByFormItem: B } = us(o, { formItemContext: a }), F = kn(), V = S(() => o.inputSize || F.value), R = S(() => o.label || s("el.slider.defaultLabel", { min: o.min, max: o.max })), K = S(() => o.range ? o.rangeStartLabel || s("el.slider.defaultRangeStartLabel") : R.value), te = S(() => o.formatValueText ? o.formatValueText(Z.value) : `${Z.value}`), U = S(() => o.rangeEndLabel || s("el.slider.defaultRangeEndLabel")), D = S(() => o.formatValueText ? o.formatValueText(ce.value) : `${ce.value}`), j = S(() => [r.b(), r.m(F.value), r.is("vertical", o.vertical), { [r.m("with-input")]: o.showInput }]), A = nY(o); vY(o, l, p, v, n, a); const G = S(() => { const me = [o.min, o.max, o.step].map(le => { const oe = `${le}`.split(".")[1]; return oe ? oe.length : 0; }); return Math.max.apply(null, me); }), { sliderWrapper: se } = tY(o, l, g), { firstValue: Z, secondValue: ce, sliderSize: ye } = Sn(l), Re = me => { l.dragging = me; }; return St(F2, { ...Sn(o), sliderSize: ye, disabled: f, precision: G, emitChange: y, resetSize: g, updateDragging: Re }), t({ onSliderClick: b }), (me, le) => { var oe, fe; return k(), z("div", { id: me.range ? i(L) : void 0, ref_key: "sliderWrapper", ref: se, class: O(i(j)), role: me.range ? "group" : void 0, "aria-label": me.range && !i(B) ? i(R) : void 0, "aria-labelledby": me.range && i(B) ? (oe = i(a)) == null ? void 0 : oe.labelId : void 0, onTouchstart: le[2] || (le[2] = (...Ce) => i(C) && i(C)(...Ce)), onTouchmove: le[3] || (le[3] = (...Ce) => i(C) && i(C)(...Ce)) }, [Q("div", { ref_key: "slider", ref: u, class: O([i(r).e("runway"), { "show-input": me.showInput && !me.range }, i(r).is("disabled", i(f))]), style: et(i(m)), onMousedown: le[0] || (le[0] = (...Ce) => i(w) && i(w)(...Ce)), onTouchstart: le[1] || (le[1] = (...Ce) => i(w) && i(w)(...Ce)) }, [Q("div", { class: O(i(r).e("bar")), style: et(i(h)) }, null, 6), ee(U0, { id: me.range ? void 0 : i(L), ref_key: "firstButton", ref: c, "model-value": i(Z), vertical: me.vertical, "tooltip-class": me.tooltipClass, placement: me.placement, role: "slider", "aria-label": me.range || !i(B) ? i(K) : void 0, "aria-labelledby": !me.range && i(B) ? (fe = i(a)) == null ? void 0 : fe.labelId : void 0, "aria-valuemin": me.min, "aria-valuemax": me.range ? i(ce) : me.max, "aria-valuenow": i(Z), "aria-valuetext": i(te), "aria-orientation": me.vertical ? "vertical" : "horizontal", "aria-disabled": i(f), "onUpdate:modelValue": i(T) }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]), me.range ? (k(), ge(U0, { key: 0, ref_key: "secondButton", ref: d, "model-value": i(ce), vertical: me.vertical, "tooltip-class": me.tooltipClass, placement: me.placement, role: "slider", "aria-label": i(U), "aria-valuemin": i(Z), "aria-valuemax": me.max, "aria-valuenow": i(ce), "aria-valuetext": i(D), "aria-orientation": me.vertical ? "vertical" : "horizontal", "aria-disabled": i(f), "onUpdate:modelValue": i(E) }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : pe("v-if", !0), me.showStops ? (k(), z("div", kY, [(k(!0), z(Qe, null, Et(i(x), (Ce, Ae) => (k(), z("div", { key: Ae, class: O(i(r).e("stop")), style: et(i(I)(Ce)) }, null, 6))), 128))])) : pe("v-if", !0), i(A).length > 0 ? (k(), z(Qe, { key: 2 }, [Q("div", null, [(k(!0), z(Qe, null, Et(i(A), (Ce, Ae) => (k(), z("div", { key: Ae, style: et(i(I)(Ce.position)), class: O([i(r).e("stop"), i(r).e("marks-stop")]) }, null, 6))), 128))]), Q("div", { class: O(i(r).e("marks")) }, [(k(!0), z(Qe, null, Et(i(A), (Ce, Ae) => (k(), ge(i(SY), { key: Ae, mark: Ce.mark, style: et(i(I)(Ce.position)) }, null, 8, ["mark", "style"]))), 128))], 2)], 64)) : pe("v-if", !0)], 38), me.showInput && !me.range ? (k(), ge(i(f2), { key: 0, ref: "input", "model-value": i(Z), class: O(i(r).e("input")), step: me.step, disabled: i(f), controls: me.showInputControls, min: me.min, max: me.max, debounce: me.debounce, size: i(V), "onUpdate:modelValue": i(T), onChange: i(y) }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : pe("v-if", !0)], 42, _Y); }; } });
var TY = Fe($Y, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/slider.vue"]]);
const OY = vt(TY), IY = Ve({ prefixCls: { type: String } }), q0 = ae({ name: "ElSpaceItem", props: IY, setup(e, { slots: t }) { const n = Ie("space"), o = S(() => `${e.prefixCls || n.b()}__item`); return () => nt("div", { class: o.value }, ke(t, "default")); } }), Y0 = { small: 8, default: 12, large: 16 };
function xY(e) { const t = Ie("space"), n = S(() => [t.b(), t.m(e.direction), e.class]), o = M(0), r = M(0), s = S(() => { const a = e.wrap || e.fill ? { flexWrap: "wrap", marginBottom: `-${r.value}px` } : {}, u = { alignItems: e.alignment }; return [a, u, e.style]; }), l = S(() => { const a = { paddingBottom: `${r.value}px`, marginRight: `${o.value}px` }, u = e.fill ? { flexGrow: 1, minWidth: `${e.fillRatio}%` } : {}; return [a, u]; }); return mo(() => { const { size: a = "small", wrap: u, direction: c, fill: d } = e; if (qe(a)) {
    const [f = 0, p = 0] = a;
    o.value = f, r.value = p;
}
else {
    let f;
    lt(a) ? f = a : f = Y0[a || "small"] || Y0.small, (u || d) && c === "horizontal" ? o.value = r.value = f : c === "horizontal" ? (o.value = f, r.value = 0) : (r.value = f, o.value = 0);
} }), { classes: n, containerStyle: s, itemStyle: l }; }
const AY = Ve({ direction: { type: String, values: ["horizontal", "vertical"], default: "horizontal" }, class: { type: ve([String, Object, Array]), default: "" }, style: { type: ve([String, Array, Object]), default: "" }, alignment: { type: ve(String), default: "center" }, prefixCls: { type: String }, spacer: { type: ve([Object, String, Number, Array]), default: null, validator: e => un(e) || lt(e) || it(e) }, wrap: Boolean, fill: Boolean, fillRatio: { type: Number, default: 100 }, size: { type: [String, Array, Number], values: sr, validator: e => lt(e) || qe(e) && e.length === 2 && e.every(lt) } }), MY = ae({ name: "ElSpace", props: AY, setup(e, { slots: t }) { const { classes: n, containerStyle: o, itemStyle: r } = xY(e); function s(l, a = "", u = []) { const { prefixCls: c } = e; return l.forEach((d, f) => { hf(d) ? qe(d.children) && d.children.forEach((p, v) => { hf(p) && qe(p.children) ? s(p.children, `${a + v}-`, u) : u.push(ee(q0, { style: r.value, prefixCls: c, key: `nested-${a + v}` }, { default: () => [p] }, bo.PROPS | bo.STYLE, ["style", "prefixCls"])); }) : ZR(d) && u.push(ee(q0, { style: r.value, prefixCls: c, key: `LoopKey${a + f}` }, { default: () => [d] }, bo.PROPS | bo.STYLE, ["style", "prefixCls"])); }), u; } return () => { var l; const { spacer: a, direction: u } = e, c = ke(t, "default", { key: 0 }, () => []); if (((l = c.children) != null ? l : []).length === 0)
        return null; if (qe(c.children)) {
        let d = s(c.children);
        if (a) {
            const f = d.length - 1;
            d = d.reduce((p, v, m) => { const h = [...p, v]; return m !== f && h.push(ee("span", { style: [r.value, u === "vertical" ? "width: 100%" : null], key: m }, [un(a) ? a : Ot(a, bo.TEXT)], bo.STYLE)), h; }, []);
        }
        return ee("div", { class: n.value, style: o.value }, d, bo.STYLE | bo.CLASS);
    } return c.children; }; } }), NY = vt(MY), PY = Ve({ decimalSeparator: { type: String, default: "." }, groupSeparator: { type: String, default: "," }, precision: { type: Number, default: 0 }, formatter: Function, value: { type: ve([Number, Object]), default: 0 }, prefix: String, suffix: String, title: String, valueStyle: { type: ve([String, Object, Array]) } }), RY = ae({ name: "ElStatistic" }), LY = ae({ ...RY, props: PY, setup(e, { expose: t }) { const n = e, o = Ie("statistic"), r = S(() => { const { value: s, formatter: l, precision: a, decimalSeparator: u, groupSeparator: c } = n; if (at(l))
        return l(s); if (!lt(s))
        return s; let [d, f = ""] = String(s).split("."); return f = f.padEnd(a, "0").slice(0, a > 0 ? a : 0), d = d.replace(/\B(?=(\d{3})+(?!\d))/g, c), [d, f].join(f ? u : ""); }); return t({ displayValue: r }), (s, l) => (k(), z("div", { class: O(i(o).b()) }, [s.$slots.title || s.title ? (k(), z("div", { key: 0, class: O(i(o).e("head")) }, [ke(s.$slots, "title", {}, () => [Ot(Be(s.title), 1)])], 2)) : pe("v-if", !0), Q("div", { class: O(i(o).e("content")) }, [s.$slots.prefix || s.prefix ? (k(), z("div", { key: 0, class: O(i(o).e("prefix")) }, [ke(s.$slots, "prefix", {}, () => [Q("span", null, Be(s.prefix), 1)])], 2)) : pe("v-if", !0), Q("span", { class: O(i(o).e("number")), style: et(s.valueStyle) }, Be(i(r)), 7), s.$slots.suffix || s.suffix ? (k(), z("div", { key: 1, class: O(i(o).e("suffix")) }, [ke(s.$slots, "suffix", {}, () => [Q("span", null, Be(s.suffix), 1)])], 2)) : pe("v-if", !0)], 2)], 2)); } });
var DY = Fe(LY, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/statistic/src/statistic.vue"]]);
const V2 = vt(DY), BY = Ve({ format: { type: String, default: "HH:mm:ss" }, prefix: String, suffix: String, title: String, value: { type: ve([Number, Object]), default: 0 }, valueStyle: { type: ve([String, Object, Array]) } }), FY = { finish: () => !0, [en]: e => lt(e) }, VY = [["Y", 1e3 * 60 * 60 * 24 * 365], ["M", 1e3 * 60 * 60 * 24 * 30], ["D", 1e3 * 60 * 60 * 24], ["H", 1e3 * 60 * 60], ["m", 1e3 * 60], ["s", 1e3], ["S", 1]], G0 = e => lt(e) ? new Date(e).getTime() : e.valueOf(), X0 = (e, t) => { let n = e; const o = /\[([^\]]*)]/g; return VY.reduce((s, [l, a]) => { const u = new RegExp(`${l}+(?![^\\[\\]]*\\])`, "g"); if (u.test(s)) {
    const c = Math.floor(n / a);
    return n -= c * a, s.replace(u, d => String(c).padStart(d.length, "0"));
} return s; }, t).replace(o, "$1"); }, zY = ae({ name: "ElCountdown" }), HY = ae({ ...zY, props: BY, emits: FY, setup(e, { expose: t, emit: n }) { const o = e; let r; const s = M(G0(o.value) - Date.now()), l = S(() => X0(s.value, o.format)), a = d => X0(d, o.format), u = () => { r && (Pc(r), r = void 0); }, c = () => { const d = G0(o.value), f = () => { let p = d - Date.now(); n("change", p), p <= 0 ? (p = 0, u(), n("finish")) : r = Ja(f), s.value = p; }; r = Ja(f); }; return Oe(() => [o.value, o.format], () => { u(), c(); }, { immediate: !0 }), on(() => { u(); }), t({ displayValue: l }), (d, f) => (k(), ge(i(V2), { value: s.value, title: d.title, prefix: d.prefix, suffix: d.suffix, "value-style": d.valueStyle, formatter: a }, Cr({ _: 2 }, [Et(d.$slots, (p, v) => ({ name: v, fn: ie(() => [ke(d.$slots, v)]) }))]), 1032, ["value", "title", "prefix", "suffix", "value-style"])); } });
var KY = Fe(HY, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/countdown/src/countdown.vue"]]);
const jY = vt(KY), WY = Ve({ space: { type: [Number, String], default: "" }, active: { type: Number, default: 0 }, direction: { type: String, default: "horizontal", values: ["horizontal", "vertical"] }, alignCenter: { type: Boolean }, simple: { type: Boolean }, finishStatus: { type: String, values: ["wait", "process", "finish", "error", "success"], default: "finish" }, processStatus: { type: String, values: ["wait", "process", "finish", "error", "success"], default: "process" } }), UY = { [en]: (e, t) => [e, t].every(lt) }, qY = ae({ name: "ElSteps" }), YY = ae({ ...qY, props: WY, emits: UY, setup(e, { emit: t }) { const n = e, o = Ie("steps"), { children: r, addChild: s, removeChild: l } = $h(ht(), "ElStep"); return Oe(r, () => { r.value.forEach((a, u) => { a.setIndex(u); }); }), St("ElSteps", { props: n, steps: r, addStep: s, removeStep: l }), Oe(() => n.active, (a, u) => { t(en, a, u); }), (a, u) => (k(), z("div", { class: O([i(o).b(), i(o).m(a.simple ? "simple" : a.direction)]) }, [ke(a.$slots, "default")], 2)); } });
var GY = Fe(YY, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/steps/src/steps.vue"]]);
const XY = Ve({ title: { type: String, default: "" }, icon: { type: Zt }, description: { type: String, default: "" }, status: { type: String, values: ["", "wait", "process", "finish", "error", "success"], default: "" } }), JY = ae({ name: "ElStep" }), ZY = ae({ ...JY, props: XY, setup(e) { const t = e, n = Ie("step"), o = M(-1), r = M({}), s = M(""), l = Ye("ElSteps"), a = ht(); ft(() => { Oe([() => l.props.active, () => l.props.processStatus, () => l.props.finishStatus], ([E]) => { w(E); }, { immediate: !0 }); }), on(() => { l.removeStep(T.uid); }); const u = S(() => t.status || s.value), c = S(() => { const E = l.steps.value[o.value - 1]; return E ? E.currentStatus : "wait"; }), d = S(() => l.props.alignCenter), f = S(() => l.props.direction === "vertical"), p = S(() => l.props.simple), v = S(() => l.steps.value.length), m = S(() => { var E; return ((E = l.steps.value[v.value - 1]) == null ? void 0 : E.uid) === (a == null ? void 0 : a.uid); }), h = S(() => p.value ? "" : l.props.space), g = S(() => [n.b(), n.is(p.value ? "simple" : l.props.direction), n.is("flex", m.value && !h.value && !d.value), n.is("center", d.value && !f.value && !p.value)]), y = S(() => { const E = { flexBasis: lt(h.value) ? `${h.value}px` : h.value ? h.value : `${100 / (v.value - (d.value ? 0 : 1))}%` }; return f.value || m.value && (E.maxWidth = `${100 / v.value}%`), E; }), C = E => { o.value = E; }, b = E => { const x = E === "wait", I = { transitionDelay: `${x ? "-" : ""}${150 * o.value}ms` }, L = E === l.props.processStatus || x ? 0 : 100; I.borderWidth = L && !p.value ? "1px" : 0, I[l.props.direction === "vertical" ? "height" : "width"] = `${L}%`, r.value = I; }, w = E => { E > o.value ? s.value = l.props.finishStatus : E === o.value && c.value !== "error" ? s.value = l.props.processStatus : s.value = "wait"; const x = l.steps.value[o.value - 1]; x && x.calcProgress(s.value); }, T = Lt({ uid: a.uid, currentStatus: u, setIndex: C, calcProgress: b }); return l.addStep(T), (E, x) => (k(), z("div", { style: et(i(y)), class: O(i(g)) }, [pe(" icon & line "), Q("div", { class: O([i(n).e("head"), i(n).is(i(u))]) }, [i(p) ? pe("v-if", !0) : (k(), z("div", { key: 0, class: O(i(n).e("line")) }, [Q("i", { class: O(i(n).e("line-inner")), style: et(r.value) }, null, 6)], 2)), Q("div", { class: O([i(n).e("icon"), i(n).is(E.icon || E.$slots.icon ? "icon" : "text")]) }, [ke(E.$slots, "icon", {}, () => [E.icon ? (k(), ge(i(Je), { key: 0, class: O(i(n).e("icon-inner")) }, { default: ie(() => [(k(), ge(kt(E.icon)))]), _: 1 }, 8, ["class"])) : i(u) === "success" ? (k(), ge(i(Je), { key: 1, class: O([i(n).e("icon-inner"), i(n).is("status")]) }, { default: ie(() => [ee(i(_i))]), _: 1 }, 8, ["class"])) : i(u) === "error" ? (k(), ge(i(Je), { key: 2, class: O([i(n).e("icon-inner"), i(n).is("status")]) }, { default: ie(() => [ee(i(Ho))]), _: 1 }, 8, ["class"])) : i(p) ? pe("v-if", !0) : (k(), z("div", { key: 3, class: O(i(n).e("icon-inner")) }, Be(o.value + 1), 3))])], 2)], 2), pe(" title & description "), Q("div", { class: O(i(n).e("main")) }, [Q("div", { class: O([i(n).e("title"), i(n).is(i(u))]) }, [ke(E.$slots, "title", {}, () => [Ot(Be(E.title), 1)])], 2), i(p) ? (k(), z("div", { key: 0, class: O(i(n).e("arrow")) }, null, 2)) : (k(), z("div", { key: 1, class: O([i(n).e("description"), i(n).is(i(u))]) }, [ke(E.$slots, "description", {}, () => [Ot(Be(E.description), 1)])], 2))], 2)], 6)); } });
var z2 = Fe(ZY, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/steps/src/item.vue"]]);
const QY = vt(GY, { Step: z2 }), eG = pn(z2), tG = Ve({ modelValue: { type: [Boolean, String, Number], default: !1 }, disabled: { type: Boolean, default: !1 }, loading: { type: Boolean, default: !1 }, size: { type: String, validator: Mc }, width: { type: [String, Number], default: "" }, inlinePrompt: { type: Boolean, default: !1 }, activeIcon: { type: Zt }, inactiveIcon: { type: Zt }, activeText: { type: String, default: "" }, inactiveText: { type: String, default: "" }, activeValue: { type: [Boolean, String, Number], default: !0 }, inactiveValue: { type: [Boolean, String, Number], default: !1 }, activeColor: { type: String, default: "" }, inactiveColor: { type: String, default: "" }, borderColor: { type: String, default: "" }, name: { type: String, default: "" }, validateEvent: { type: Boolean, default: !0 }, beforeChange: { type: ve(Function) }, id: String, tabindex: { type: [String, Number] }, value: { type: [Boolean, String, Number], default: !1 } }), nG = { [gt]: e => wn(e) || it(e) || lt(e), [en]: e => wn(e) || it(e) || lt(e), [qn]: e => wn(e) || it(e) || lt(e) }, oG = ["onClick"], rG = ["id", "aria-checked", "aria-disabled", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"], sG = ["aria-hidden"], lG = ["aria-hidden"], aG = ["aria-hidden"], Zf = "ElSwitch", iG = ae({ name: Zf }), uG = ae({ ...iG, props: tG, emits: nG, setup(e, { expose: t, emit: n }) { const o = e, r = ht(), { formItem: s } = Zn(), l = kn(), a = Ie("switch"); (I => { I.forEach(L => { tr({ from: L[0], replacement: L[1], scope: Zf, version: "2.3.0", ref: "https://element-plus.org/en-US/component/switch.html#attributes", type: "Attribute" }, S(() => { var B; return !!((B = r.vnode.props) != null && B[L[2]]); })); }); })([['"value"', '"model-value" or "v-model"', "value"], ['"active-color"', "CSS var `--el-switch-on-color`", "activeColor"], ['"inactive-color"', "CSS var `--el-switch-off-color`", "inactiveColor"], ['"border-color"', "CSS var `--el-switch-border-color`", "borderColor"]]); const { inputId: c } = us(o, { formItemContext: s }), d = uo(S(() => o.loading)), f = M(o.modelValue !== !1), p = M(), v = M(), m = S(() => [a.b(), a.m(l.value), a.is("disabled", d.value), a.is("checked", b.value)]), h = S(() => [a.e("label"), a.em("label", "left"), a.is("active", !b.value)]), g = S(() => [a.e("label"), a.em("label", "right"), a.is("active", b.value)]), y = S(() => ({ width: gn(o.width) })); Oe(() => o.modelValue, () => { f.value = !0; }), Oe(() => o.value, () => { f.value = !1; }); const C = S(() => f.value ? o.modelValue : o.value), b = S(() => C.value === o.activeValue); [o.activeValue, o.inactiveValue].includes(C.value) || (n(gt, o.inactiveValue), n(en, o.inactiveValue), n(qn, o.inactiveValue)), Oe(b, I => { var L; p.value.checked = I, o.validateEvent && ((L = s == null ? void 0 : s.validate) == null || L.call(s, "change").catch(B => void 0)); }); const w = () => { const I = b.value ? o.inactiveValue : o.activeValue; n(gt, I), n(en, I), n(qn, I), Xe(() => { p.value.checked = b.value; }); }, T = () => { if (d.value)
        return; const { beforeChange: I } = o; if (!I) {
        w();
        return;
    } const L = I(); [Na(L), wn(L)].includes(!0) || _n(Zf, "beforeChange must return type `Promise<boolean>` or `boolean`"), Na(L) ? L.then(F => { F && w(); }).catch(F => { }) : L && w(); }, E = S(() => a.cssVarBlock({ ...o.activeColor ? { "on-color": o.activeColor } : null, ...o.inactiveColor ? { "off-color": o.inactiveColor } : null, ...o.borderColor ? { "border-color": o.borderColor } : null })), x = () => { var I, L; (L = (I = p.value) == null ? void 0 : I.focus) == null || L.call(I); }; return ft(() => { p.value.checked = b.value; }), t({ focus: x, checked: b }), (I, L) => (k(), z("div", { class: O(i(m)), style: et(i(E)), onClick: st(T, ["prevent"]) }, [Q("input", { id: i(c), ref_key: "input", ref: p, class: O(i(a).e("input")), type: "checkbox", role: "switch", "aria-checked": i(b), "aria-disabled": i(d), name: I.name, "true-value": I.activeValue, "false-value": I.inactiveValue, disabled: i(d), tabindex: I.tabindex, onChange: w, onKeydown: Mt(T, ["enter"]) }, null, 42, rG), !I.inlinePrompt && (I.inactiveIcon || I.inactiveText) ? (k(), z("span", { key: 0, class: O(i(h)) }, [I.inactiveIcon ? (k(), ge(i(Je), { key: 0 }, { default: ie(() => [(k(), ge(kt(I.inactiveIcon)))]), _: 1 })) : pe("v-if", !0), !I.inactiveIcon && I.inactiveText ? (k(), z("span", { key: 1, "aria-hidden": i(b) }, Be(I.inactiveText), 9, sG)) : pe("v-if", !0)], 2)) : pe("v-if", !0), Q("span", { ref_key: "core", ref: v, class: O(i(a).e("core")), style: et(i(y)) }, [I.inlinePrompt ? (k(), z("div", { key: 0, class: O(i(a).e("inner")) }, [I.activeIcon || I.inactiveIcon ? (k(), ge(i(Je), { key: 0, class: O(i(a).is("icon")) }, { default: ie(() => [(k(), ge(kt(i(b) ? I.activeIcon : I.inactiveIcon)))]), _: 1 }, 8, ["class"])) : I.activeText || I.inactiveText ? (k(), z("span", { key: 1, class: O(i(a).is("text")), "aria-hidden": !i(b) }, Be(i(b) ? I.activeText : I.inactiveText), 11, lG)) : pe("v-if", !0)], 2)) : pe("v-if", !0), Q("div", { class: O(i(a).e("action")) }, [I.loading ? (k(), ge(i(Je), { key: 0, class: O(i(a).is("loading")) }, { default: ie(() => [ee(i(as))]), _: 1 }, 8, ["class"])) : pe("v-if", !0)], 2)], 6), !I.inlinePrompt && (I.activeIcon || I.activeText) ? (k(), z("span", { key: 1, class: O(i(g)) }, [I.activeIcon ? (k(), ge(i(Je), { key: 0 }, { default: ie(() => [(k(), ge(kt(I.activeIcon)))]), _: 1 })) : pe("v-if", !0), !I.activeIcon && I.activeText ? (k(), z("span", { key: 1, "aria-hidden": !i(b) }, Be(I.activeText), 9, aG)) : pe("v-if", !0)], 2)) : pe("v-if", !0)], 14, oG)); } });
var cG = Fe(uG, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/switch/src/switch.vue"]]);
const dG = vt(cG); /*!
* escape-html
* Copyright(c) 2012-2013 TJ Holowaychuk
* Copyright(c) 2015 Andreas Lubbe
* Copyright(c) 2015 Tiancheng "Timothy" Gu
* MIT Licensed
*/
var fG = /["'&<>]/, pG = hG;
function hG(e) { var t = "" + e, n = fG.exec(t); if (!n)
    return t; var o, r = "", s = 0, l = 0; for (s = n.index; s < t.length; s++) {
    switch (t.charCodeAt(s)) {
        case 34:
            o = "&quot;";
            break;
        case 38:
            o = "&amp;";
            break;
        case 39:
            o = "&#39;";
            break;
        case 60:
            o = "&lt;";
            break;
        case 62:
            o = "&gt;";
            break;
        default: continue;
    }
    l !== s && (r += t.substring(l, s)), l = s + 1, r += o;
} return l !== s ? r + t.substring(l, s) : r; }
const vG = lr(pG), Bd = function (e) { var t; return (t = e.target) == null ? void 0 : t.closest("td"); }, mG = function (e, t, n, o, r) { if (!t && !o && (!r || Array.isArray(r) && !r.length))
    return e; typeof n == "string" ? n = n === "descending" ? -1 : 1 : n = n && n < 0 ? -1 : 1; const s = o ? null : function (a, u) { return r ? (Array.isArray(r) || (r = [r]), r.map(c => typeof c == "string" ? sn(a, c) : c(a, u, e))) : (t !== "$key" && yt(a) && "$value" in a && (a = a.$value), [yt(a) ? sn(a, t) : a]); }, l = function (a, u) { if (o)
    return o(a.value, u.value); for (let c = 0, d = a.key.length; c < d; c++) {
    if (a.key[c] < u.key[c])
        return -1;
    if (a.key[c] > u.key[c])
        return 1;
} return 0; }; return e.map((a, u) => ({ value: a, index: u, key: s ? s(a, u) : null })).sort((a, u) => { let c = l(a, u); return c || (c = a.index - u.index), c * +n; }).map(a => a.value); }, H2 = function (e, t) { let n = null; return e.columns.forEach(o => { o.id === t && (n = o); }), n; }, gG = function (e, t) { let n = null; for (let o = 0; o < e.columns.length; o++) {
    const r = e.columns[o];
    if (r.columnKey === t) {
        n = r;
        break;
    }
} return n || _n("ElTable", `No column matching with column-key: ${t}`), n; }, J0 = function (e, t, n) { const o = (t.className || "").match(new RegExp(`${n}-table_[^\\s]+`, "gm")); return o ? H2(e, o[0]) : null; }, Pn = (e, t) => { if (!e)
    throw new Error("Row is required when get row identity"); if (typeof t == "string") {
    if (!t.includes("."))
        return `${e[t]}`;
    const n = t.split(".");
    let o = e;
    for (const r of n)
        o = o[r];
    return `${o}`;
}
else if (typeof t == "function")
    return t.call(null, e); }, xs = function (e, t) { const n = {}; return (e || []).forEach((o, r) => { n[Pn(o, t)] = { row: o, index: r }; }), n; };
function yG(e, t) { const n = {}; let o; for (o in e)
    n[o] = e[o]; for (o in t)
    if (Tt(t, o)) {
        const r = t[o];
        typeof r < "u" && (n[o] = r);
    } return n; }
function Gh(e) { return e === "" || e !== void 0 && (e = Number.parseInt(e, 10), Number.isNaN(e) && (e = "")), e; }
function K2(e) { return e === "" || e !== void 0 && (e = Gh(e), Number.isNaN(e) && (e = 80)), e; }
function bG(e) { return typeof e == "number" ? e : typeof e == "string" ? /^\d+(?:px)?$/.test(e) ? Number.parseInt(e, 10) : e : null; }
function wG(...e) { return e.length === 0 ? t => t : e.length === 1 ? e[0] : e.reduce((t, n) => (...o) => t(n(...o))); }
function xa(e, t, n) { let o = !1; const r = e.indexOf(t), s = r !== -1, l = a => { a === "add" ? e.push(t) : e.splice(r, 1), o = !0, qe(t.children) && t.children.forEach(u => { xa(e, u, n ?? !s); }); }; return wn(n) ? n && !s ? l("add") : !n && s && l("remove") : l(s ? "remove" : "add"), o; }
function CG(e, t, n = "children", o = "hasChildren") { const r = l => !(Array.isArray(l) && l.length); function s(l, a, u) { t(l, a, u), a.forEach(c => { if (c[o]) {
    t(c, null, u + 1);
    return;
} const d = c[n]; r(d) || s(c, d, u + 1); }); } e.forEach(l => { if (l[o]) {
    t(l, null, 0);
    return;
} const a = l[n]; r(a) || s(l, a, 0); }); }
let pr;
function SG(e, t, n, o, r) { r = E1({ enterable: !0, showArrow: !0 }, r); const s = e == null ? void 0 : e.dataset.prefix, l = e == null ? void 0 : e.querySelector(`.${s}-scrollbar__wrap`); function a() { const g = r.effect === "light", y = document.createElement("div"); return y.className = [`${s}-popper`, g ? "is-light" : "is-dark", r.popperClass || ""].join(" "), n = vG(n), y.innerHTML = n, y.style.zIndex = String(o()), e == null || e.appendChild(y), y; } function u() { const g = document.createElement("div"); return g.className = `${s}-popper__arrow`, g; } function c() { d && d.update(); } pr == null || pr(), pr = () => { try {
    d && d.destroy(), v && (e == null || e.removeChild(v)), t.removeEventListener("mouseenter", f), t.removeEventListener("mouseleave", p), l == null || l.removeEventListener("scroll", pr), pr = void 0;
}
catch { } }; let d = null, f = c, p = pr; r.enterable && ({ onOpen: f, onClose: p } = lw({ showAfter: r.showAfter, hideAfter: r.hideAfter, open: c, close: pr })); const v = a(); v.onmouseenter = f, v.onmouseleave = p; const m = []; if (r.offset && m.push({ name: "offset", options: { offset: [0, r.offset] } }), r.showArrow) {
    const g = v.appendChild(u());
    m.push({ name: "arrow", options: { element: g, padding: 10 } });
} const h = r.popperOptions || {}; return d = ow(t, v, { placement: r.placement || "top", strategy: "fixed", ...h, modifiers: h.modifiers ? m.concat(h.modifiers) : m }), t.addEventListener("mouseenter", f), t.addEventListener("mouseleave", p), l == null || l.addEventListener("scroll", pr), d; }
function j2(e) { return e.children ? rM(e.children, j2) : [e]; }
function Z0(e, t) { return e + t.colSpan; }
const W2 = (e, t, n, o) => { let r = 0, s = e; const l = n.states.columns.value; if (o) {
    const u = j2(o[e]);
    r = l.slice(0, l.indexOf(u[0])).reduce(Z0, 0), s = r + u.reduce(Z0, 0) - 1;
}
else
    r = e; let a; switch (t) {
    case "left":
        s < n.states.fixedLeafColumnsLength.value && (a = "left");
        break;
    case "right":
        r >= l.length - n.states.rightFixedLeafColumnsLength.value && (a = "right");
        break;
    default: s < n.states.fixedLeafColumnsLength.value ? a = "left" : r >= l.length - n.states.rightFixedLeafColumnsLength.value && (a = "right");
} return a ? { direction: a, start: r, after: s } : {}; }, Xh = (e, t, n, o, r, s = 0) => { const l = [], { direction: a, start: u, after: c } = W2(t, n, o, r); if (a) {
    const d = a === "left";
    l.push(`${e}-fixed-column--${a}`), d && c + s === o.states.fixedLeafColumnsLength.value - 1 ? l.push("is-last-column") : !d && u - s === o.states.columns.value.length - o.states.rightFixedLeafColumnsLength.value && l.push("is-first-column");
} return l; };
function Q0(e, t) { return e + (t.realWidth === null || Number.isNaN(t.realWidth) ? Number(t.width) : t.realWidth); }
const Jh = (e, t, n, o) => { const { direction: r, start: s = 0, after: l = 0 } = W2(e, t, n, o); if (!r)
    return; const a = {}, u = r === "left", c = n.states.columns.value; return u ? a.left = c.slice(0, s).reduce(Q0, 0) : a.right = c.slice(l + 1).reverse().reduce(Q0, 0), a; }, Vl = (e, t) => { e && (Number.isNaN(e[t]) || (e[t] = `${e[t]}px`)); };
function _G(e) { const t = ht(), n = M(!1), o = M([]); return { updateExpandRows: () => { const u = e.data.value || [], c = e.rowKey.value; if (n.value)
        o.value = u.slice();
    else if (c) {
        const d = xs(o.value, c);
        o.value = u.reduce((f, p) => { const v = Pn(p, c); return d[v] && f.push(p), f; }, []);
    }
    else
        o.value = []; }, toggleRowExpansion: (u, c) => { xa(o.value, u, c) && t.emit("expand-change", u, o.value.slice()); }, setExpandRowKeys: u => { t.store.assertRowKey(); const c = e.data.value || [], d = e.rowKey.value, f = xs(c, d); o.value = u.reduce((p, v) => { const m = f[v]; return m && p.push(m.row), p; }, []); }, isRowExpanded: u => { const c = e.rowKey.value; return c ? !!xs(o.value, c)[Pn(u, c)] : o.value.includes(u); }, states: { expandRows: o, defaultExpandAll: n } }; }
function kG(e) { const t = ht(), n = M(null), o = M(null), r = c => { t.store.assertRowKey(), n.value = c, l(c); }, s = () => { n.value = null; }, l = c => { const { data: d, rowKey: f } = e; let p = null; f.value && (p = (i(d) || []).find(v => Pn(v, f.value) === c)), o.value = p, t.emit("current-change", o.value, null); }; return { setCurrentRowKey: r, restoreCurrentRowKey: s, setCurrentRowByKey: l, updateCurrentRow: c => { const d = o.value; if (c && c !== d) {
        o.value = c, t.emit("current-change", o.value, d);
        return;
    } !c && d && (o.value = null, t.emit("current-change", null, d)); }, updateCurrentRowData: () => { const c = e.rowKey.value, d = e.data.value || [], f = o.value; if (!d.includes(f) && f) {
        if (c) {
            const p = Pn(f, c);
            l(p);
        }
        else
            o.value = null;
        o.value === null && t.emit("current-change", null, f);
    }
    else
        n.value && (l(n.value), s()); }, states: { _currentRowKey: n, currentRow: o } }; }
function EG(e) { const t = M([]), n = M({}), o = M(16), r = M(!1), s = M({}), l = M("hasChildren"), a = M("children"), u = ht(), c = S(() => { if (!e.rowKey.value)
    return {}; const y = e.data.value || []; return f(y); }), d = S(() => { const y = e.rowKey.value, C = Object.keys(s.value), b = {}; return C.length && C.forEach(w => { if (s.value[w].length) {
    const T = { children: [] };
    s.value[w].forEach(E => { const x = Pn(E, y); T.children.push(x), E[l.value] && !b[x] && (b[x] = { children: [] }); }), b[w] = T;
} }), b; }), f = y => { const C = e.rowKey.value, b = {}; return CG(y, (w, T, E) => { const x = Pn(w, C); Array.isArray(T) ? b[x] = { children: T.map(I => Pn(I, C)), level: E } : r.value && (b[x] = { children: [], lazy: !0, level: E }); }, a.value, l.value), b; }, p = (y = !1, C = (b => (b = u.store) == null ? void 0 : b.states.defaultExpandAll.value)()) => { var b; const w = c.value, T = d.value, E = Object.keys(w), x = {}; if (E.length) {
    const I = i(n), L = [], B = (V, R) => { if (y)
        return t.value ? C || t.value.includes(R) : !!(C || V != null && V.expanded); {
        const K = C || t.value && t.value.includes(R);
        return !!(V != null && V.expanded || K);
    } };
    E.forEach(V => { const R = I[V], K = { ...w[V] }; if (K.expanded = B(R, V), K.lazy) {
        const { loaded: te = !1, loading: U = !1 } = R || {};
        K.loaded = !!te, K.loading = !!U, L.push(V);
    } x[V] = K; });
    const F = Object.keys(T);
    r.value && F.length && L.length && F.forEach(V => { const R = I[V], K = T[V].children; if (L.includes(V)) {
        if (x[V].children.length !== 0)
            throw new Error("[ElTable]children must be an empty array.");
        x[V].children = K;
    }
    else {
        const { loaded: te = !1, loading: U = !1 } = R || {};
        x[V] = { lazy: !0, loaded: !!te, loading: !!U, expanded: B(R, V), children: K, level: "" };
    } });
} n.value = x, (b = u.store) == null || b.updateTableScrollY(); }; Oe(() => t.value, () => { p(!0); }), Oe(() => c.value, () => { p(); }), Oe(() => d.value, () => { p(); }); const v = y => { t.value = y, p(); }, m = (y, C) => { u.store.assertRowKey(); const b = e.rowKey.value, w = Pn(y, b), T = w && n.value[w]; if (w && T && "expanded" in T) {
    const E = T.expanded;
    C = typeof C > "u" ? !T.expanded : C, n.value[w].expanded = C, E !== C && u.emit("expand-change", y, C), u.store.updateTableScrollY();
} }, h = y => { u.store.assertRowKey(); const C = e.rowKey.value, b = Pn(y, C), w = n.value[b]; r.value && w && "loaded" in w && !w.loaded ? g(y, b, w) : m(y, void 0); }, g = (y, C, b) => { const { load: w } = u.props; w && !n.value[C].loaded && (n.value[C].loading = !0, w(y, b, T => { if (!Array.isArray(T))
    throw new TypeError("[ElTable] data must be an array"); n.value[C].loading = !1, n.value[C].loaded = !0, n.value[C].expanded = !0, T.length && (s.value[C] = T), u.emit("expand-change", y, !0); })); }; return { loadData: g, loadOrToggle: h, toggleTreeExpansion: m, updateTreeExpandKeys: v, updateTreeData: p, normalize: f, states: { expandRowKeys: t, treeData: n, indent: o, lazy: r, lazyTreeNodeMap: s, lazyColumnIdentifier: l, childrenColumnName: a } }; }
const $G = (e, t) => { const n = t.sortingColumn; return !n || typeof n.sortable == "string" ? e : mG(e, t.sortProp, t.sortOrder, n.sortMethod, n.sortBy); }, ku = e => { const t = []; return e.forEach(n => { n.children && n.children.length > 0 ? t.push.apply(t, ku(n.children)) : t.push(n); }), t; };
function TG() { var e; const t = ht(), { size: n } = Sn((e = t.proxy) == null ? void 0 : e.$props), o = M(null), r = M([]), s = M([]), l = M(!1), a = M([]), u = M([]), c = M([]), d = M([]), f = M([]), p = M([]), v = M([]), m = M([]), h = [], g = M(0), y = M(0), C = M(0), b = M(!1), w = M([]), T = M(!1), E = M(!1), x = M(null), I = M({}), L = M(null), B = M(null), F = M(null), V = M(null), R = M(null); Oe(r, () => t.state && D(!1), { deep: !0 }); const K = () => { if (!o.value)
    throw new Error("[ElTable] prop row-key is required"); }, te = Y => { var H; (H = Y.children) == null || H.forEach(ue => { ue.fixed = Y.fixed, te(ue); }); }, U = () => { a.value.forEach(be => { te(be); }), d.value = a.value.filter(be => be.fixed === !0 || be.fixed === "left"), f.value = a.value.filter(be => be.fixed === "right"), d.value.length > 0 && a.value[0] && a.value[0].type === "selection" && !a.value[0].fixed && (a.value[0].fixed = !0, d.value.unshift(a.value[0])); const Y = a.value.filter(be => !be.fixed); u.value = [].concat(d.value).concat(Y).concat(f.value); const H = ku(Y), ue = ku(d.value), de = ku(f.value); g.value = H.length, y.value = ue.length, C.value = de.length, c.value = [].concat(ue).concat(H).concat(de), l.value = d.value.length > 0 || f.value.length > 0; }, D = (Y, H = !1) => { Y && U(), H ? t.state.doLayout() : t.state.debouncedUpdateLayout(); }, j = Y => w.value.includes(Y), A = () => { b.value = !1, w.value.length && (w.value = [], t.emit("selection-change", [])); }, G = () => { let Y; if (o.value) {
    Y = [];
    const H = xs(w.value, o.value), ue = xs(r.value, o.value);
    for (const de in H)
        Tt(H, de) && !ue[de] && Y.push(H[de].row);
}
else
    Y = w.value.filter(H => !r.value.includes(H)); if (Y.length) {
    const H = w.value.filter(ue => !Y.includes(ue));
    w.value = H, t.emit("selection-change", H.slice());
} }, se = () => (w.value || []).slice(), Z = (Y, H = void 0, ue = !0) => { if (xa(w.value, Y, H)) {
    const be = (w.value || []).slice();
    ue && t.emit("select", be, Y), t.emit("selection-change", be);
} }, ce = () => { var Y, H; const ue = E.value ? !b.value : !(b.value || w.value.length); b.value = ue; let de = !1, be = 0; const J = (H = (Y = t == null ? void 0 : t.store) == null ? void 0 : Y.states) == null ? void 0 : H.rowKey.value; r.value.forEach((we, Ke) => { const rt = Ke + be; x.value ? x.value.call(null, we, rt) && xa(w.value, we, ue) && (de = !0) : xa(w.value, we, ue) && (de = !0), be += me(Pn(we, J)); }), de && t.emit("selection-change", w.value ? w.value.slice() : []), t.emit("select-all", w.value); }, ye = () => { const Y = xs(w.value, o.value); r.value.forEach(H => { const ue = Pn(H, o.value), de = Y[ue]; de && (w.value[de.index] = H); }); }, Re = () => { var Y, H, ue; if (((Y = r.value) == null ? void 0 : Y.length) === 0) {
    b.value = !1;
    return;
} let de; o.value && (de = xs(w.value, o.value)); const be = function (rt) { return de ? !!de[Pn(rt, o.value)] : w.value.includes(rt); }; let J = !0, we = 0, Ke = 0; for (let rt = 0, _e = (r.value || []).length; rt < _e; rt++) {
    const ze = (ue = (H = t == null ? void 0 : t.store) == null ? void 0 : H.states) == null ? void 0 : ue.rowKey.value, We = rt + Ke, ut = r.value[rt], rn = x.value && x.value.call(null, ut, We);
    if (be(ut))
        we++;
    else if (!x.value || rn) {
        J = !1;
        break;
    }
    Ke += me(Pn(ut, ze));
} we === 0 && (J = !1), b.value = J; }, me = Y => { var H; if (!t || !t.store)
    return 0; const { treeData: ue } = t.store.states; let de = 0; const be = (H = ue.value[Y]) == null ? void 0 : H.children; return be && (de += be.length, be.forEach(J => { de += me(J); })), de; }, le = (Y, H) => { Array.isArray(Y) || (Y = [Y]); const ue = {}; return Y.forEach(de => { I.value[de.id] = H, ue[de.columnKey || de.id] = H; }), ue; }, oe = (Y, H, ue) => { B.value && B.value !== Y && (B.value.order = null), B.value = Y, F.value = H, V.value = ue; }, fe = () => { let Y = i(s); Object.keys(I.value).forEach(H => { const ue = I.value[H]; if (!ue || ue.length === 0)
    return; const de = H2({ columns: c.value }, H); de && de.filterMethod && (Y = Y.filter(be => ue.some(J => de.filterMethod.call(null, J, be, de)))); }), L.value = Y; }, Ce = () => { r.value = $G(L.value, { sortingColumn: B.value, sortProp: F.value, sortOrder: V.value }); }, Ae = (Y = void 0) => { Y && Y.filter || fe(), Ce(); }, q = Y => { const { tableHeaderRef: H } = t.refs; if (!H)
    return; const ue = Object.assign({}, H.filterPanels), de = Object.keys(ue); if (de.length)
    if (typeof Y == "string" && (Y = [Y]), Array.isArray(Y)) {
        const be = Y.map(J => gG({ columns: c.value }, J));
        de.forEach(J => { const we = be.find(Ke => Ke.id === J); we && (we.filteredValue = []); }), t.store.commit("filterChange", { column: be, values: [], silent: !0, multi: !0 });
    }
    else
        de.forEach(be => { const J = c.value.find(we => we.id === be); J && (J.filteredValue = []); }), I.value = {}, t.store.commit("filterChange", { column: {}, values: [], silent: !0 }); }, re = () => { B.value && (oe(null, null, null), t.store.commit("changeSortCondition", { silent: !0 })); }, { setExpandRowKeys: he, toggleRowExpansion: Ee, updateExpandRows: Ne, states: Se, isRowExpanded: De } = _G({ data: r, rowKey: o }), { updateTreeExpandKeys: Me, toggleTreeExpansion: $e, updateTreeData: Pe, loadOrToggle: He, states: je } = EG({ data: r, rowKey: o }), { updateCurrentRowData: Ue, updateCurrentRow: Te, setCurrentRowKey: Ge, states: W } = kG({ data: r, rowKey: o }); return { assertRowKey: K, updateColumns: U, scheduleLayout: D, isSelected: j, clearSelection: A, cleanSelection: G, getSelectionRows: se, toggleRowSelection: Z, _toggleAllSelection: ce, toggleAllSelection: null, updateSelectionByRowKey: ye, updateAllSelected: Re, updateFilters: le, updateCurrentRow: Te, updateSort: oe, execFilter: fe, execSort: Ce, execQuery: Ae, clearFilter: q, clearSort: re, toggleRowExpansion: Ee, setExpandRowKeysAdapter: Y => { he(Y), Me(Y); }, setCurrentRowKey: Ge, toggleRowExpansionAdapter: (Y, H) => { c.value.some(({ type: de }) => de === "expand") ? Ee(Y, H) : $e(Y, H); }, isRowExpanded: De, updateExpandRows: Ne, updateCurrentRowData: Ue, loadOrToggle: He, updateTreeData: Pe, states: { tableSize: n, rowKey: o, data: r, _data: s, isComplex: l, _columns: a, originColumns: u, columns: c, fixedColumns: d, rightFixedColumns: f, leafColumns: p, fixedLeafColumns: v, rightFixedLeafColumns: m, updateOrderFns: h, leafColumnsLength: g, fixedLeafColumnsLength: y, rightFixedLeafColumnsLength: C, isAllSelected: b, selection: w, reserveSelection: T, selectOnIndeterminate: E, selectable: x, filters: I, filteredData: L, sortingColumn: B, sortProp: F, sortOrder: V, hoverRow: R, ...Se, ...je, ...W } }; }
function Qf(e, t) { return e.map(n => { var o; return n.id === t.id ? t : ((o = n.children) != null && o.length && (n.children = Qf(n.children, t)), n); }); }
function ep(e) { e.forEach(t => { var n, o; t.no = (n = t.getColumnIndex) == null ? void 0 : n.call(t), (o = t.children) != null && o.length && ep(t.children); }), e.sort((t, n) => t.no - n.no); }
function OG() { const e = ht(), t = TG(); return { ns: Ie("table"), ...t, mutations: { setData(l, a) { const u = i(l._data) !== a; l.data.value = a, l._data.value = a, e.store.execQuery(), e.store.updateCurrentRowData(), e.store.updateExpandRows(), e.store.updateTreeData(e.store.states.defaultExpandAll.value), i(l.reserveSelection) ? (e.store.assertRowKey(), e.store.updateSelectionByRowKey()) : u ? e.store.clearSelection() : e.store.cleanSelection(), e.store.updateAllSelected(), e.$ready && e.store.scheduleLayout(); }, insertColumn(l, a, u, c) { const d = i(l._columns); let f = []; u ? (u && !u.children && (u.children = []), u.children.push(a), f = Qf(d, u)) : (d.push(a), f = d), ep(f), l._columns.value = f, l.updateOrderFns.push(c), a.type === "selection" && (l.selectable.value = a.selectable, l.reserveSelection.value = a.reserveSelection), e.$ready && (e.store.updateColumns(), e.store.scheduleLayout()); }, updateColumnOrder(l, a) { var u; ((u = a.getColumnIndex) == null ? void 0 : u.call(a)) !== a.no && (ep(l._columns.value), e.$ready && e.store.updateColumns()); }, removeColumn(l, a, u, c) { const d = i(l._columns) || []; if (u)
            u.children.splice(u.children.findIndex(p => p.id === a.id), 1), Xe(() => { var p; ((p = u.children) == null ? void 0 : p.length) === 0 && delete u.children; }), l._columns.value = Qf(d, u);
        else {
            const p = d.indexOf(a);
            p > -1 && (d.splice(p, 1), l._columns.value = d);
        } const f = l.updateOrderFns.indexOf(c); f > -1 && l.updateOrderFns.splice(f, 1), e.$ready && (e.store.updateColumns(), e.store.scheduleLayout()); }, sort(l, a) { const { prop: u, order: c, init: d } = a; if (u) {
            const f = i(l.columns).find(p => p.property === u);
            f && (f.order = c, e.store.updateSort(f, u, c), e.store.commit("changeSortCondition", { init: d }));
        } }, changeSortCondition(l, a) { const { sortingColumn: u, sortProp: c, sortOrder: d } = l, f = i(u), p = i(c), v = i(d); v === null && (l.sortingColumn.value = null, l.sortProp.value = null); const m = { filter: !0 }; e.store.execQuery(m), (!a || !(a.silent || a.init)) && e.emit("sort-change", { column: f, prop: p, order: v }), e.store.updateTableScrollY(); }, filterChange(l, a) { const { column: u, values: c, silent: d } = a, f = e.store.updateFilters(u, c); e.store.execQuery(), d || e.emit("filter-change", f), e.store.updateTableScrollY(); }, toggleAllSelection() { e.store.toggleAllSelection(); }, rowSelectedChanged(l, a) { e.store.toggleRowSelection(a), e.store.updateAllSelected(); }, setHoverRow(l, a) { l.hoverRow.value = a; }, setCurrentRow(l, a) { e.store.updateCurrentRow(a); } }, commit: function (l, ...a) { const u = e.store.mutations; if (u[l])
        u[l].apply(e, [e.store.states].concat(a));
    else
        throw new Error(`Action not found: ${l}`); }, updateTableScrollY: function () { Xe(() => e.layout.updateScrollY.apply(e.layout)); } }; }
const Aa = { rowKey: "rowKey", defaultExpandAll: "defaultExpandAll", selectOnIndeterminate: "selectOnIndeterminate", indent: "indent", lazy: "lazy", data: "data", "treeProps.hasChildren": { key: "lazyColumnIdentifier", default: "hasChildren" }, "treeProps.children": { key: "childrenColumnName", default: "children" } };
function IG(e, t) { if (!e)
    throw new Error("Table is required."); const n = OG(); return n.toggleAllSelection = Xn(n._toggleAllSelection, 10), Object.keys(Aa).forEach(o => { U2(q2(t, o), o, n); }), xG(n, t), n; }
function xG(e, t) { Object.keys(Aa).forEach(n => { Oe(() => q2(t, n), o => { U2(o, n, e); }); }); }
function U2(e, t, n) { let o = e, r = Aa[t]; typeof Aa[t] == "object" && (r = r.key, o = o || Aa[t].default), n.states[r].value = o; }
function q2(e, t) { if (t.includes(".")) {
    const n = t.split(".");
    let o = e;
    return n.forEach(r => { o = o[r]; }), o;
}
else
    return e[t]; }
class AG {
    constructor(t) { this.observers = [], this.table = null, this.store = null, this.columns = [], this.fit = !0, this.showHeader = !0, this.height = M(null), this.scrollX = M(!1), this.scrollY = M(!1), this.bodyWidth = M(null), this.fixedWidth = M(null), this.rightFixedWidth = M(null), this.gutterWidth = 0; for (const n in t)
        Tt(t, n) && (Jt(this[n]) ? this[n].value = t[n] : this[n] = t[n]); if (!this.table)
        throw new Error("Table is required for Table Layout"); if (!this.store)
        throw new Error("Store is required for Table Layout"); }
    updateScrollY() { if (this.height.value === null)
        return !1; const n = this.table.refs.scrollBarRef; if (this.table.vnode.el && (n != null && n.wrapRef)) {
        let o = !0;
        const r = this.scrollY.value;
        return o = n.wrapRef.scrollHeight > n.wrapRef.clientHeight, this.scrollY.value = o, r !== o;
    } return !1; }
    setHeight(t, n = "height") { if (!At)
        return; const o = this.table.vnode.el; if (t = bG(t), this.height.value = Number(t), !o && (t || t === 0))
        return Xe(() => this.setHeight(t, n)); typeof t == "number" ? (o.style[n] = `${t}px`, this.updateElsHeight()) : typeof t == "string" && (o.style[n] = t, this.updateElsHeight()); }
    setMaxHeight(t) { this.setHeight(t, "max-height"); }
    getFlattenColumns() { const t = []; return this.table.store.states.columns.value.forEach(o => { o.isColumnGroup ? t.push.apply(t, o.columns) : t.push(o); }), t; }
    updateElsHeight() { this.updateScrollY(), this.notifyObservers("scrollable"); }
    headerDisplayNone(t) { if (!t)
        return !0; let n = t; for (; n.tagName !== "DIV";) {
        if (getComputedStyle(n).display === "none")
            return !0;
        n = n.parentElement;
    } return !1; }
    updateColumnsWidth() { if (!At)
        return; const t = this.fit, n = this.table.vnode.el.clientWidth; let o = 0; const r = this.getFlattenColumns(), s = r.filter(u => typeof u.width != "number"); if (r.forEach(u => { typeof u.width == "number" && u.realWidth && (u.realWidth = null); }), s.length > 0 && t) {
        if (r.forEach(u => { o += Number(u.width || u.minWidth || 80); }), o <= n) {
            this.scrollX.value = !1;
            const u = n - o;
            if (s.length === 1)
                s[0].realWidth = Number(s[0].minWidth || 80) + u;
            else {
                const c = s.reduce((p, v) => p + Number(v.minWidth || 80), 0), d = u / c;
                let f = 0;
                s.forEach((p, v) => { if (v === 0)
                    return; const m = Math.floor(Number(p.minWidth || 80) * d); f += m, p.realWidth = Number(p.minWidth || 80) + m; }), s[0].realWidth = Number(s[0].minWidth || 80) + u - f;
            }
        }
        else
            this.scrollX.value = !0, s.forEach(u => { u.realWidth = Number(u.minWidth); });
        this.bodyWidth.value = Math.max(o, n), this.table.state.resizeState.value.width = this.bodyWidth.value;
    }
    else
        r.forEach(u => { !u.width && !u.minWidth ? u.realWidth = 80 : u.realWidth = Number(u.width || u.minWidth), o += u.realWidth; }), this.scrollX.value = o > n, this.bodyWidth.value = o; const l = this.store.states.fixedColumns.value; if (l.length > 0) {
        let u = 0;
        l.forEach(c => { u += Number(c.realWidth || c.width); }), this.fixedWidth.value = u;
    } const a = this.store.states.rightFixedColumns.value; if (a.length > 0) {
        let u = 0;
        a.forEach(c => { u += Number(c.realWidth || c.width); }), this.rightFixedWidth.value = u;
    } this.notifyObservers("columns"); }
    addObserver(t) { this.observers.push(t); }
    removeObserver(t) { const n = this.observers.indexOf(t); n !== -1 && this.observers.splice(n, 1); }
    notifyObservers(t) { this.observers.forEach(o => { var r, s; switch (t) {
        case "columns":
            (r = o.state) == null || r.onColumnsChange(this);
            break;
        case "scrollable":
            (s = o.state) == null || s.onScrollableChange(this);
            break;
        default: throw new Error(`Table Layout don't have event ${t}.`);
    } }); }
}
const { CheckboxGroup: MG } = Ao, NG = ae({ name: "ElTableFilterPanel", components: { ElCheckbox: Ao, ElCheckboxGroup: MG, ElScrollbar: Or, ElTooltip: Jn, ElIcon: Je, ArrowDown: ss, ArrowUp: Ic }, directives: { ClickOutside: ns }, props: { placement: { type: String, default: "bottom-start" }, store: { type: Object }, column: { type: Object }, upDataColumn: { type: Function } }, setup(e) { const t = ht(), { t: n } = Nt(), o = Ie("table-filter"), r = t == null ? void 0 : t.parent; r.filterPanels.value[e.column.id] || (r.filterPanels.value[e.column.id] = t); const s = M(!1), l = M(null), a = S(() => e.column && e.column.filters), u = S({ get: () => { var w; return (((w = e.column) == null ? void 0 : w.filteredValue) || [])[0]; }, set: w => { c.value && (typeof w < "u" && w !== null ? c.value.splice(0, 1, w) : c.value.splice(0, 1)); } }), c = S({ get() { return e.column ? e.column.filteredValue || [] : []; }, set(w) { e.column && e.upDataColumn("filteredValue", w); } }), d = S(() => e.column ? e.column.filterMultiple : !0), f = w => w.value === u.value, p = () => { s.value = !1; }, v = w => { w.stopPropagation(), s.value = !s.value; }, m = () => { s.value = !1; }, h = () => { C(c.value), p(); }, g = () => { c.value = [], C(c.value), p(); }, y = w => { u.value = w, C(typeof w < "u" && w !== null ? c.value : []), p(); }, C = w => { e.store.commit("filterChange", { column: e.column, values: w }), e.store.updateAllSelected(); }; Oe(s, w => { e.column && e.upDataColumn("filterOpened", w); }, { immediate: !0 }); const b = S(() => { var w, T; return (T = (w = l.value) == null ? void 0 : w.popperRef) == null ? void 0 : T.contentRef; }); return { tooltipVisible: s, multiple: d, filteredValue: c, filterValue: u, filters: a, handleConfirm: h, handleReset: g, handleSelect: y, isActive: f, t: n, ns: o, showFilterPanel: v, hideFilterPanel: m, popperPaneRef: b, tooltip: l }; } }), PG = { key: 0 }, RG = ["disabled"], LG = ["label", "onClick"];
function DG(e, t, n, o, r, s) { const l = ct("el-checkbox"), a = ct("el-checkbox-group"), u = ct("el-scrollbar"), c = ct("arrow-up"), d = ct("arrow-down"), f = ct("el-icon"), p = ct("el-tooltip"), v = Va("click-outside"); return k(), ge(p, { ref: "tooltip", visible: e.tooltipVisible, offset: 0, placement: e.placement, "show-arrow": !1, "stop-popper-mouse-event": !1, teleported: "", effect: "light", pure: "", "popper-class": e.ns.b(), persistent: "" }, { content: ie(() => [e.multiple ? (k(), z("div", PG, [Q("div", { class: O(e.ns.e("content")) }, [ee(u, { "wrap-class": e.ns.e("wrap") }, { default: ie(() => [ee(a, { modelValue: e.filteredValue, "onUpdate:modelValue": t[0] || (t[0] = m => e.filteredValue = m), class: O(e.ns.e("checkbox-group")) }, { default: ie(() => [(k(!0), z(Qe, null, Et(e.filters, m => (k(), ge(l, { key: m.value, label: m.value }, { default: ie(() => [Ot(Be(m.text), 1)]), _: 2 }, 1032, ["label"]))), 128))]), _: 1 }, 8, ["modelValue", "class"])]), _: 1 }, 8, ["wrap-class"])], 2), Q("div", { class: O(e.ns.e("bottom")) }, [Q("button", { class: O({ [e.ns.is("disabled")]: e.filteredValue.length === 0 }), disabled: e.filteredValue.length === 0, type: "button", onClick: t[1] || (t[1] = (...m) => e.handleConfirm && e.handleConfirm(...m)) }, Be(e.t("el.table.confirmFilter")), 11, RG), Q("button", { type: "button", onClick: t[2] || (t[2] = (...m) => e.handleReset && e.handleReset(...m)) }, Be(e.t("el.table.resetFilter")), 1)], 2)])) : (k(), z("ul", { key: 1, class: O(e.ns.e("list")) }, [Q("li", { class: O([e.ns.e("list-item"), { [e.ns.is("active")]: e.filterValue === void 0 || e.filterValue === null }]), onClick: t[3] || (t[3] = m => e.handleSelect(null)) }, Be(e.t("el.table.clearFilter")), 3), (k(!0), z(Qe, null, Et(e.filters, m => (k(), z("li", { key: m.value, class: O([e.ns.e("list-item"), e.ns.is("active", e.isActive(m))]), label: m.value, onClick: h => e.handleSelect(m.value) }, Be(m.text), 11, LG))), 128))], 2))]), default: ie(() => [dt((k(), z("span", { class: O([`${e.ns.namespace.value}-table__column-filter-trigger`, `${e.ns.namespace.value}-none-outline`]), onClick: t[4] || (t[4] = (...m) => e.showFilterPanel && e.showFilterPanel(...m)) }, [ee(f, null, { default: ie(() => [e.column.filterOpened ? (k(), ge(c, { key: 0 })) : (k(), ge(d, { key: 1 }))]), _: 1 })], 2)), [[v, e.hideFilterPanel, e.popperPaneRef]])]), _: 1 }, 8, ["visible", "placement", "popper-class"]); }
var BG = Fe(NG, [["render", DG], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/filter-panel.vue"]]);
function Y2(e) { const t = ht(); mc(() => { n.value.addObserver(t); }), ft(() => { o(n.value), r(n.value); }), Er(() => { o(n.value), r(n.value); }), rs(() => { n.value.removeObserver(t); }); const n = S(() => { const s = e.layout; if (!s)
    throw new Error("Can not find table layout."); return s; }), o = s => { var l; const a = ((l = e.vnode.el) == null ? void 0 : l.querySelectorAll("colgroup > col")) || []; if (!a.length)
    return; const u = s.getFlattenColumns(), c = {}; u.forEach(d => { c[d.id] = d; }); for (let d = 0, f = a.length; d < f; d++) {
    const p = a[d], v = p.getAttribute("name"), m = c[v];
    m && p.setAttribute("width", m.realWidth || m.width);
} }, r = s => { var l, a; const u = ((l = e.vnode.el) == null ? void 0 : l.querySelectorAll("colgroup > col[name=gutter]")) || []; for (let d = 0, f = u.length; d < f; d++)
    u[d].setAttribute("width", s.scrollY.value ? s.gutterWidth : "0"); const c = ((a = e.vnode.el) == null ? void 0 : a.querySelectorAll("th.gutter")) || []; for (let d = 0, f = c.length; d < f; d++) {
    const p = c[d];
    p.style.width = s.scrollY.value ? `${s.gutterWidth}px` : "0", p.style.display = s.scrollY.value ? "" : "none";
} }; return { tableLayout: n.value, onColumnsChange: o, onScrollableChange: r }; }
const ar = Symbol("ElTable");
function FG(e, t) { const n = ht(), o = Ye(ar), r = h => { h.stopPropagation(); }, s = (h, g) => { !g.filters && g.sortable ? m(h, g, !1) : g.filterable && !g.sortable && r(h), o == null || o.emit("header-click", g, h); }, l = (h, g) => { o == null || o.emit("header-contextmenu", g, h); }, a = M(null), u = M(!1), c = M({}), d = (h, g) => { if (At && !(g.children && g.children.length > 0) && a.value && e.border) {
    u.value = !0;
    const y = o;
    t("set-drag-visible", !0);
    const b = (y == null ? void 0 : y.vnode.el).getBoundingClientRect().left, w = n.vnode.el.querySelector(`th.${g.id}`), T = w.getBoundingClientRect(), E = T.left - b + 30;
    Jo(w, "noclick"), c.value = { startMouseLeft: h.clientX, startLeft: T.right - b, startColumnLeft: T.left - b, tableLeft: b };
    const x = y == null ? void 0 : y.refs.resizeProxy;
    x.style.left = `${c.value.startLeft}px`, document.onselectstart = function () { return !1; }, document.ondragstart = function () { return !1; };
    const I = B => { const F = B.clientX - c.value.startMouseLeft, V = c.value.startLeft + F; x.style.left = `${Math.max(E, V)}px`; }, L = () => { if (u.value) {
        const { startColumnLeft: B, startLeft: F } = c.value, R = Number.parseInt(x.style.left, 10) - B;
        g.width = g.realWidth = R, y == null || y.emit("header-dragend", g.width, F - B, g, h), requestAnimationFrame(() => { e.store.scheduleLayout(!1, !0); }), document.body.style.cursor = "", u.value = !1, a.value = null, c.value = {}, t("set-drag-visible", !1);
    } document.removeEventListener("mousemove", I), document.removeEventListener("mouseup", L), document.onselectstart = null, document.ondragstart = null, setTimeout(() => { so(w, "noclick"); }, 0); };
    document.addEventListener("mousemove", I), document.addEventListener("mouseup", L);
} }, f = (h, g) => { if (g.children && g.children.length > 0)
    return; const y = h.target; if (!To(y))
    return; const C = y == null ? void 0 : y.closest("th"); if (!(!g || !g.resizable) && !u.value && e.border) {
    const b = C.getBoundingClientRect(), w = document.body.style;
    b.width > 12 && b.right - h.pageX < 8 ? (w.cursor = "col-resize", Vo(C, "is-sortable") && (C.style.cursor = "col-resize"), a.value = g) : u.value || (w.cursor = "", Vo(C, "is-sortable") && (C.style.cursor = "pointer"), a.value = null);
} }, p = () => { At && (document.body.style.cursor = ""); }, v = ({ order: h, sortOrders: g }) => { if (h === "")
    return g[0]; const y = g.indexOf(h || null); return g[y > g.length - 2 ? 0 : y + 1]; }, m = (h, g, y) => { var C; h.stopPropagation(); const b = g.order === y ? null : y || v(g), w = (C = h.target) == null ? void 0 : C.closest("th"); if (w && Vo(w, "noclick")) {
    so(w, "noclick");
    return;
} if (!g.sortable)
    return; const T = e.store.states; let E = T.sortProp.value, x; const I = T.sortingColumn.value; (I !== g || I === g && I.order === null) && (I && (I.order = null), T.sortingColumn.value = g, E = g.property), b ? x = g.order = b : x = g.order = null, T.sortProp.value = E, T.sortOrder.value = x, o == null || o.store.commit("changeSortCondition"); }; return { handleHeaderClick: s, handleHeaderContextMenu: l, handleMouseDown: d, handleMouseMove: f, handleMouseOut: p, handleSortClick: m, handleFilterClick: r }; }
function VG(e) { const t = Ye(ar), n = Ie("table"); return { getHeaderRowStyle: a => { const u = t == null ? void 0 : t.props.headerRowStyle; return typeof u == "function" ? u.call(null, { rowIndex: a }) : u; }, getHeaderRowClass: a => { const u = [], c = t == null ? void 0 : t.props.headerRowClassName; return typeof c == "string" ? u.push(c) : typeof c == "function" && u.push(c.call(null, { rowIndex: a })), u.join(" "); }, getHeaderCellStyle: (a, u, c, d) => { var f; let p = (f = t == null ? void 0 : t.props.headerCellStyle) != null ? f : {}; typeof p == "function" && (p = p.call(null, { rowIndex: a, columnIndex: u, row: c, column: d })); const v = Jh(u, d.fixed, e.store, c); return Vl(v, "left"), Vl(v, "right"), Object.assign({}, p, v); }, getHeaderCellClass: (a, u, c, d) => { const f = Xh(n.b(), u, d.fixed, e.store, c), p = [d.id, d.order, d.headerAlign, d.className, d.labelClassName, ...f]; d.children || p.push("is-leaf"), d.sortable && p.push("is-sortable"); const v = t == null ? void 0 : t.props.headerCellClassName; return typeof v == "string" ? p.push(v) : typeof v == "function" && p.push(v.call(null, { rowIndex: a, columnIndex: u, row: c, column: d })), p.push(n.e("cell")), p.filter(m => !!m).join(" "); } }; }
const G2 = e => { const t = []; return e.forEach(n => { n.children ? (t.push(n), t.push.apply(t, G2(n.children))) : t.push(n); }), t; }, zG = e => { let t = 1; const n = (s, l) => { if (l && (s.level = l.level + 1, t < s.level && (t = s.level)), s.children) {
    let a = 0;
    s.children.forEach(u => { n(u, s), a += u.colSpan; }), s.colSpan = a;
}
else
    s.colSpan = 1; }; e.forEach(s => { s.level = 1, n(s, void 0); }); const o = []; for (let s = 0; s < t; s++)
    o.push([]); return G2(e).forEach(s => { s.children ? (s.rowSpan = 1, s.children.forEach(l => l.isSubColumn = !0)) : s.rowSpan = t - s.level + 1, o[s.level - 1].push(s); }), o; };
function HG(e) { const t = Ye(ar), n = S(() => zG(e.store.states.originColumns.value)); return { isGroup: S(() => { const s = n.value.length > 1; return s && t && (t.state.isGroup.value = !0), s; }), toggleAllSelection: s => { s.stopPropagation(), t == null || t.store.commit("toggleAllSelection"); }, columnRows: n }; }
var KG = ae({ name: "ElTableHeader", components: { ElCheckbox: Ao }, props: { fixed: { type: String, default: "" }, store: { required: !0, type: Object }, border: Boolean, defaultSort: { type: Object, default: () => ({ prop: "", order: "" }) } }, setup(e, { emit: t }) { const n = ht(), o = Ye(ar), r = Ie("table"), s = M({}), { onColumnsChange: l, onScrollableChange: a } = Y2(o); ft(async () => { await Xe(), await Xe(); const { prop: E, order: x } = e.defaultSort; o == null || o.store.commit("sort", { prop: E, order: x, init: !0 }); }); const { handleHeaderClick: u, handleHeaderContextMenu: c, handleMouseDown: d, handleMouseMove: f, handleMouseOut: p, handleSortClick: v, handleFilterClick: m } = FG(e, t), { getHeaderRowStyle: h, getHeaderRowClass: g, getHeaderCellStyle: y, getHeaderCellClass: C } = VG(e), { isGroup: b, toggleAllSelection: w, columnRows: T } = HG(e); return n.state = { onColumnsChange: l, onScrollableChange: a }, n.filterPanels = s, { ns: r, filterPanels: s, onColumnsChange: l, onScrollableChange: a, columnRows: T, getHeaderRowClass: g, getHeaderRowStyle: h, getHeaderCellClass: C, getHeaderCellStyle: y, handleHeaderClick: u, handleHeaderContextMenu: c, handleMouseDown: d, handleMouseMove: f, handleMouseOut: p, handleSortClick: v, handleFilterClick: m, isGroup: b, toggleAllSelection: w }; }, render() { const { ns: e, isGroup: t, columnRows: n, getHeaderCellStyle: o, getHeaderCellClass: r, getHeaderRowClass: s, getHeaderRowStyle: l, handleHeaderClick: a, handleHeaderContextMenu: u, handleMouseDown: c, handleMouseMove: d, handleSortClick: f, handleMouseOut: p, store: v, $parent: m } = this; let h = 1; return nt("thead", { class: { [e.is("group")]: t } }, n.map((g, y) => nt("tr", { class: s(y), key: y, style: l(y) }, g.map((C, b) => (C.rowSpan > h && (h = C.rowSpan), nt("th", { class: r(y, b, g, C), colspan: C.colSpan, key: `${C.id}-thead`, rowspan: C.rowSpan, style: o(y, b, g, C), onClick: w => a(w, C), onContextmenu: w => u(w, C), onMousedown: w => c(w, C), onMousemove: w => d(w, C), onMouseout: p }, [nt("div", { class: ["cell", C.filteredValue && C.filteredValue.length > 0 ? "highlight" : ""] }, [C.renderHeader ? C.renderHeader({ column: C, $index: b, store: v, _self: m }) : C.label, C.sortable && nt("span", { onClick: w => f(w, C), class: "caret-wrapper" }, [nt("i", { onClick: w => f(w, C, "ascending"), class: "sort-caret ascending" }), nt("i", { onClick: w => f(w, C, "descending"), class: "sort-caret descending" })]), C.filterable && nt(BG, { store: v, placement: C.filterPlacement || "bottom-start", column: C, upDataColumn: (w, T) => { C[w] = T; } })])])))))); } });
function jG(e) { const t = Ye(ar), n = M(""), o = M(nt("div")), { nextZIndex: r } = Gl(), s = (m, h, g) => { var y; const C = t, b = Bd(m); let w; const T = (y = C == null ? void 0 : C.vnode.el) == null ? void 0 : y.dataset.prefix; b && (w = J0({ columns: e.store.states.columns.value }, b, T), w && (C == null || C.emit(`cell-${g}`, h, w, b, m))), C == null || C.emit(`row-${g}`, h, w, m); }, l = (m, h) => { s(m, h, "dblclick"); }, a = (m, h) => { e.store.commit("setCurrentRow", h), s(m, h, "click"); }, u = (m, h) => { s(m, h, "contextmenu"); }, c = Xn(m => { e.store.commit("setHoverRow", m); }, 30), d = Xn(() => { e.store.commit("setHoverRow", null); }, 30), f = m => { const h = window.getComputedStyle(m, null), g = Number.parseInt(h.paddingLeft, 10) || 0, y = Number.parseInt(h.paddingRight, 10) || 0, C = Number.parseInt(h.paddingTop, 10) || 0, b = Number.parseInt(h.paddingBottom, 10) || 0; return { left: g, right: y, top: C, bottom: b }; }; return { handleDoubleClick: l, handleClick: a, handleContextMenu: u, handleMouseEnter: c, handleMouseLeave: d, handleCellMouseEnter: (m, h, g) => { var y; const C = t, b = Bd(m), w = (y = C == null ? void 0 : C.vnode.el) == null ? void 0 : y.dataset.prefix; if (b) {
        const te = J0({ columns: e.store.states.columns.value }, b, w), U = C.hoverState = { cell: b, column: te, row: h };
        C == null || C.emit("cell-mouse-enter", U.row, U.column, U.cell, m);
    } if (!g)
        return; const T = m.target.querySelector(".cell"); if (!(Vo(T, `${w}-tooltip`) && T.childNodes.length))
        return; const E = document.createRange(); E.setStart(T, 0), E.setEnd(T, T.childNodes.length); const x = Math.round(E.getBoundingClientRect().width), I = Math.round(E.getBoundingClientRect().height), { top: L, left: B, right: F, bottom: V } = f(T), R = B + F, K = L + V; (x + R > T.offsetWidth || I + K > T.offsetHeight || T.scrollWidth > T.offsetWidth) && SG(t == null ? void 0 : t.refs.tableWrapper, b, b.innerText || b.textContent, r, g); }, handleCellMouseLeave: m => { if (!Bd(m))
        return; const g = t == null ? void 0 : t.hoverState; t == null || t.emit("cell-mouse-leave", g == null ? void 0 : g.row, g == null ? void 0 : g.column, g == null ? void 0 : g.cell, m); }, tooltipContent: n, tooltipTrigger: o }; }
function WG(e) { const t = Ye(ar), n = Ie("table"); return { getRowStyle: (c, d) => { const f = t == null ? void 0 : t.props.rowStyle; return typeof f == "function" ? f.call(null, { row: c, rowIndex: d }) : f || null; }, getRowClass: (c, d) => { const f = [n.e("row")]; t != null && t.props.highlightCurrentRow && c === e.store.states.currentRow.value && f.push("current-row"), e.stripe && d % 2 === 1 && f.push(n.em("row", "striped")); const p = t == null ? void 0 : t.props.rowClassName; return typeof p == "string" ? f.push(p) : typeof p == "function" && f.push(p.call(null, { row: c, rowIndex: d })), f; }, getCellStyle: (c, d, f, p) => { const v = t == null ? void 0 : t.props.cellStyle; let m = v ?? {}; typeof v == "function" && (m = v.call(null, { rowIndex: c, columnIndex: d, row: f, column: p })); const h = Jh(d, e == null ? void 0 : e.fixed, e.store); return Vl(h, "left"), Vl(h, "right"), Object.assign({}, m, h); }, getCellClass: (c, d, f, p, v) => { const m = Xh(n.b(), d, e == null ? void 0 : e.fixed, e.store, void 0, v), h = [p.id, p.align, p.className, ...m], g = t == null ? void 0 : t.props.cellClassName; return typeof g == "string" ? h.push(g) : typeof g == "function" && h.push(g.call(null, { rowIndex: c, columnIndex: d, row: f, column: p })), h.push(n.e("cell")), h.filter(y => !!y).join(" "); }, getSpan: (c, d, f, p) => { let v = 1, m = 1; const h = t == null ? void 0 : t.props.spanMethod; if (typeof h == "function") {
        const g = h({ row: c, column: d, rowIndex: f, columnIndex: p });
        Array.isArray(g) ? (v = g[0], m = g[1]) : typeof g == "object" && (v = g.rowspan, m = g.colspan);
    } return { rowspan: v, colspan: m }; }, getColspanRealWidth: (c, d, f) => { if (d < 1)
        return c[f].realWidth; const p = c.map(({ realWidth: v, width: m }) => v || m).slice(f, f + d); return Number(p.reduce((v, m) => Number(v) + Number(m), -1)); } }; }
function UG(e) { const t = Ye(ar), n = Ie("table"), { handleDoubleClick: o, handleClick: r, handleContextMenu: s, handleMouseEnter: l, handleMouseLeave: a, handleCellMouseEnter: u, handleCellMouseLeave: c, tooltipContent: d, tooltipTrigger: f } = jG(e), { getRowStyle: p, getRowClass: v, getCellStyle: m, getCellClass: h, getSpan: g, getColspanRealWidth: y } = WG(e), C = S(() => e.store.states.columns.value.findIndex(({ type: x }) => x === "default")), b = (x, I) => { const L = t.props.rowKey; return L ? Pn(x, L) : I; }, w = (x, I, L, B = !1) => { const { tooltipEffect: F, tooltipOptions: V, store: R } = e, { indent: K, columns: te } = R.states, U = v(x, I); let D = !0; return L && (U.push(n.em("row", `level-${L.level}`)), D = L.display), nt("tr", { style: [D ? null : { display: "none" }, p(x, I)], class: U, key: b(x, I), onDblclick: A => o(A, x), onClick: A => r(A, x), onContextmenu: A => s(A, x), onMouseenter: () => l(I), onMouseleave: a }, te.value.map((A, G) => { const { rowspan: se, colspan: Z } = g(x, A, I, G); if (!se || !Z)
    return null; const ce = { ...A }; ce.realWidth = y(te.value, Z, G); const ye = { store: e.store, _self: e.context || t, column: ce, row: x, $index: I, cellIndex: G, expanded: B }; G === C.value && L && (ye.treeNode = { indent: L.level * K.value, level: L.level }, typeof L.expanded == "boolean" && (ye.treeNode.expanded = L.expanded, "loading" in L && (ye.treeNode.loading = L.loading), "noLazyChildren" in L && (ye.treeNode.noLazyChildren = L.noLazyChildren))); const Re = `${I},${G}`, me = ce.columnKey || ce.rawColumnKey || "", le = T(G, A, ye), oe = A.showOverflowTooltip && E1({ effect: F }, V, A.showOverflowTooltip); return nt("td", { style: m(I, G, x, A), class: h(I, G, x, A, Z - 1), key: `${me}${Re}`, rowspan: se, colspan: Z, onMouseenter: fe => u(fe, x, oe), onMouseleave: c }, [le]); })); }, T = (x, I, L) => I.renderCell(L); return { wrappedRowRender: (x, I) => { const L = e.store, { isRowExpanded: B, assertRowKey: F } = L, { treeData: V, lazyTreeNodeMap: R, childrenColumnName: K, rowKey: te } = L.states, U = L.states.columns.value; if (U.some(({ type: j }) => j === "expand")) {
        const j = B(x), A = w(x, I, void 0, j), G = t.renderExpanded;
        return j ? G ? [[A, nt("tr", { key: `expanded-row__${A.key}` }, [nt("td", { colspan: U.length, class: `${n.e("cell")} ${n.e("expanded-cell")}` }, [G({ row: x, $index: I, store: L, expanded: j })])])]] : (console.error("[Element Error]renderExpanded is required."), A) : [[A]];
    }
    else if (Object.keys(V.value).length) {
        F();
        const j = Pn(x, te.value);
        let A = V.value[j], G = null;
        A && (G = { expanded: A.expanded, level: A.level, display: !0 }, typeof A.lazy == "boolean" && (typeof A.loaded == "boolean" && A.loaded && (G.noLazyChildren = !(A.children && A.children.length)), G.loading = A.loading));
        const se = [w(x, I, G)];
        if (A) {
            let Z = 0;
            const ce = (Re, me) => { Re && Re.length && me && Re.forEach(le => { const oe = { display: me.display && me.expanded, level: me.level + 1, expanded: !1, noLazyChildren: !1, loading: !1 }, fe = Pn(le, te.value); if (fe == null)
                throw new Error("For nested data item, row-key is required."); if (A = { ...V.value[fe] }, A && (oe.expanded = A.expanded, A.level = A.level || oe.level, A.display = !!(A.expanded && oe.display), typeof A.lazy == "boolean" && (typeof A.loaded == "boolean" && A.loaded && (oe.noLazyChildren = !(A.children && A.children.length)), oe.loading = A.loading)), Z++, se.push(w(le, I + Z, oe)), A) {
                const Ce = R.value[fe] || le[K.value];
                ce(Ce, A);
            } }); };
            A.display = !0;
            const ye = R.value[j] || x[K.value];
            ce(ye, A);
        }
        return se;
    }
    else
        return w(x, I, void 0); }, tooltipContent: d, tooltipTrigger: f }; }
const qG = { store: { required: !0, type: Object }, stripe: Boolean, tooltipEffect: String, tooltipOptions: { type: Object }, context: { default: () => ({}), type: Object }, rowClassName: [String, Function], rowStyle: [Object, Function], fixed: { type: String, default: "" }, highlight: Boolean };
var YG = ae({ name: "ElTableBody", props: qG, setup(e) { const t = ht(), n = Ye(ar), o = Ie("table"), { wrappedRowRender: r, tooltipContent: s, tooltipTrigger: l } = UG(e), { onColumnsChange: a, onScrollableChange: u } = Y2(n); return Oe(e.store.states.hoverRow, (c, d) => { if (!e.store.states.isComplex.value || !At)
        return; let f = window.requestAnimationFrame; f || (f = p => window.setTimeout(p, 16)), f(() => { const p = t == null ? void 0 : t.vnode.el, v = Array.from((p == null ? void 0 : p.children) || []).filter(g => g == null ? void 0 : g.classList.contains(`${o.e("row")}`)), m = v[d], h = v[c]; m && so(m, "hover-row"), h && Jo(h, "hover-row"); }); }), rs(() => { var c; (c = pr) == null || c(); }), { ns: o, onColumnsChange: a, onScrollableChange: u, wrappedRowRender: r, tooltipContent: s, tooltipTrigger: l }; }, render() { const { wrappedRowRender: e, store: t } = this, n = t.states.data.value || []; return nt("tbody", {}, [n.reduce((o, r) => o.concat(e(r, o.length)), [])]); } });
function Zh(e) { const t = e.tableLayout === "auto"; let n = e.columns || []; t && n.every(r => r.width === void 0) && (n = []); const o = r => { const s = { key: `${e.tableLayout}_${r.id}`, style: {}, name: void 0 }; return t ? s.style = { width: `${r.width}px` } : s.name = r.id, s; }; return nt("colgroup", {}, n.map(r => nt("col", o(r)))); }
Zh.props = ["columns", "tableLayout"];
function GG() { const e = Ye(ar), t = e == null ? void 0 : e.store, n = S(() => t.states.fixedLeafColumnsLength.value), o = S(() => t.states.rightFixedColumns.value.length), r = S(() => t.states.columns.value.length), s = S(() => t.states.fixedColumns.value.length), l = S(() => t.states.rightFixedColumns.value.length); return { leftFixedLeafCount: n, rightFixedLeafCount: o, columnsCount: r, leftFixedCount: s, rightFixedCount: l, columns: t.states.columns }; }
function XG(e) { const { columns: t } = GG(), n = Ie("table"); return { getCellClasses: (s, l) => { const a = s[l], u = [n.e("cell"), a.id, a.align, a.labelClassName, ...Xh(n.b(), l, a.fixed, e.store)]; return a.className && u.push(a.className), a.children || u.push(n.is("leaf")), u; }, getCellStyles: (s, l) => { const a = Jh(l, s.fixed, e.store); return Vl(a, "left"), Vl(a, "right"), a; }, columns: t }; }
var JG = ae({ name: "ElTableFooter", props: { fixed: { type: String, default: "" }, store: { required: !0, type: Object }, summaryMethod: Function, sumText: String, border: Boolean, defaultSort: { type: Object, default: () => ({ prop: "", order: "" }) } }, setup(e) { const { getCellClasses: t, getCellStyles: n, columns: o } = XG(e); return { ns: Ie("table"), getCellClasses: t, getCellStyles: n, columns: o }; }, render() { const { columns: e, getCellStyles: t, getCellClasses: n, summaryMethod: o, sumText: r, ns: s } = this, l = this.store.states.data.value; let a = []; return o ? a = o({ columns: e, data: l }) : e.forEach((u, c) => { if (c === 0) {
        a[c] = r;
        return;
    } const d = l.map(m => Number(m[u.property])), f = []; let p = !0; d.forEach(m => { if (!Number.isNaN(+m)) {
        p = !1;
        const h = `${m}`.split(".")[1];
        f.push(h ? h.length : 0);
    } }); const v = Math.max.apply(null, f); p ? a[c] = "" : a[c] = d.reduce((m, h) => { const g = Number(h); return Number.isNaN(+g) ? m : Number.parseFloat((m + h).toFixed(Math.min(v, 20))); }, 0); }), nt("table", { class: s.e("footer"), cellspacing: "0", cellpadding: "0", border: "0" }, [Zh({ columns: e }), nt("tbody", [nt("tr", {}, [...e.map((u, c) => nt("td", { key: c, colspan: u.colSpan, rowspan: u.rowSpan, class: n(e, c), style: t(u, c) }, [nt("div", { class: ["cell", u.labelClassName] }, [a[c]])]))])])]); } });
function ZG(e) { return { setCurrentRow: d => { e.commit("setCurrentRow", d); }, getSelectionRows: () => e.getSelectionRows(), toggleRowSelection: (d, f) => { e.toggleRowSelection(d, f, !1), e.updateAllSelected(); }, clearSelection: () => { e.clearSelection(); }, clearFilter: d => { e.clearFilter(d); }, toggleAllSelection: () => { e.commit("toggleAllSelection"); }, toggleRowExpansion: (d, f) => { e.toggleRowExpansionAdapter(d, f); }, clearSort: () => { e.clearSort(); }, sort: (d, f) => { e.commit("sort", { prop: d, order: f }); } }; }
function QG(e, t, n, o) { const r = M(!1), s = M(null), l = M(!1), a = A => { l.value = A; }, u = M({ width: null, height: null, headerHeight: null }), c = M(!1), d = { display: "inline-block", verticalAlign: "middle" }, f = M(), p = M(0), v = M(0), m = M(0), h = M(0), g = M(0); mo(() => { t.setHeight(e.height); }), mo(() => { t.setMaxHeight(e.maxHeight); }), Oe(() => [e.currentRowKey, n.states.rowKey], ([A, G]) => { !i(G) || !i(A) || n.setCurrentRowKey(`${A}`); }, { immediate: !0 }), Oe(() => e.data, A => { o.store.commit("setData", A); }, { immediate: !0, deep: !0 }), mo(() => { e.expandRowKeys && n.setExpandRowKeysAdapter(e.expandRowKeys); }); const y = () => { o.store.commit("setHoverRow", null), o.hoverState && (o.hoverState = null); }, C = (A, G) => { const { pixelX: se, pixelY: Z } = G; Math.abs(se) >= Math.abs(Z) && (o.refs.bodyWrapper.scrollLeft += G.pixelX / 5); }, b = S(() => e.height || e.maxHeight || n.states.fixedColumns.value.length > 0 || n.states.rightFixedColumns.value.length > 0), w = S(() => ({ width: t.bodyWidth.value ? `${t.bodyWidth.value}px` : "" })), T = () => { b.value && t.updateElsHeight(), t.updateColumnsWidth(), requestAnimationFrame(L); }; ft(async () => { await Xe(), n.updateColumns(), B(), requestAnimationFrame(T); const A = o.vnode.el, G = o.refs.headerWrapper; e.flexible && A && A.parentElement && (A.parentElement.style.minWidth = "0"), u.value = { width: f.value = A.offsetWidth, height: A.offsetHeight, headerHeight: e.showHeader && G ? G.offsetHeight : null }, n.states.columns.value.forEach(se => { se.filteredValue && se.filteredValue.length && o.store.commit("filterChange", { column: se, values: se.filteredValue, silent: !0 }); }), o.$ready = !0; }); const E = (A, G) => { if (!A)
    return; const se = Array.from(A.classList).filter(Z => !Z.startsWith("is-scrolling-")); se.push(t.scrollX.value ? G : "is-scrolling-none"), A.className = se.join(" "); }, x = A => { const { tableWrapper: G } = o.refs; E(G, A); }, I = A => { const { tableWrapper: G } = o.refs; return !!(G && G.classList.contains(A)); }, L = function () { if (!o.refs.scrollBarRef)
    return; if (!t.scrollX.value) {
    const me = "is-scrolling-none";
    I(me) || x(me);
    return;
} const A = o.refs.scrollBarRef.wrapRef; if (!A)
    return; const { scrollLeft: G, offsetWidth: se, scrollWidth: Z } = A, { headerWrapper: ce, footerWrapper: ye } = o.refs; ce && (ce.scrollLeft = G), ye && (ye.scrollLeft = G); const Re = Z - se - 1; G >= Re ? x("is-scrolling-right") : x(G === 0 ? "is-scrolling-left" : "is-scrolling-middle"); }, B = () => { o.refs.scrollBarRef && (o.refs.scrollBarRef.wrapRef && nn(o.refs.scrollBarRef.wrapRef, "scroll", L, { passive: !0 }), e.fit ? Vn(o.vnode.el, F) : nn(window, "resize", F), Vn(o.refs.bodyWrapper, () => { var A, G; F(), (G = (A = o.refs) == null ? void 0 : A.scrollBarRef) == null || G.update(); })); }, F = () => { var A, G, se, Z; const ce = o.vnode.el; if (!o.$ready || !ce)
    return; let ye = !1; const { width: Re, height: me, headerHeight: le } = u.value, oe = f.value = ce.offsetWidth; Re !== oe && (ye = !0); const fe = ce.offsetHeight; (e.height || b.value) && me !== fe && (ye = !0); const Ce = e.tableLayout === "fixed" ? o.refs.headerWrapper : (A = o.refs.tableHeaderRef) == null ? void 0 : A.$el; e.showHeader && (Ce == null ? void 0 : Ce.offsetHeight) !== le && (ye = !0), p.value = ((G = o.refs.tableWrapper) == null ? void 0 : G.scrollHeight) || 0, m.value = (Ce == null ? void 0 : Ce.scrollHeight) || 0, h.value = ((se = o.refs.footerWrapper) == null ? void 0 : se.offsetHeight) || 0, g.value = ((Z = o.refs.appendWrapper) == null ? void 0 : Z.offsetHeight) || 0, v.value = p.value - m.value - h.value - g.value, ye && (u.value = { width: oe, height: fe, headerHeight: e.showHeader && (Ce == null ? void 0 : Ce.offsetHeight) || 0 }, T()); }, V = kn(), R = S(() => { const { bodyWidth: A, scrollY: G, gutterWidth: se } = t; return A.value ? `${A.value - (G.value ? se : 0)}px` : ""; }), K = S(() => e.maxHeight ? "fixed" : e.tableLayout), te = S(() => { if (e.data && e.data.length)
    return null; let A = "100%"; e.height && v.value && (A = `${v.value}px`); const G = f.value; return { width: G ? `${G}px` : "", height: A }; }), U = S(() => e.height ? { height: Number.isNaN(Number(e.height)) ? e.height : `${e.height}px` } : e.maxHeight ? { maxHeight: Number.isNaN(Number(e.maxHeight)) ? e.maxHeight : `${e.maxHeight}px` } : {}), D = S(() => e.height ? { height: "100%" } : e.maxHeight ? Number.isNaN(Number(e.maxHeight)) ? { maxHeight: `calc(${e.maxHeight} - ${m.value + h.value}px)` } : { maxHeight: `${e.maxHeight - m.value - h.value}px` } : {}); return { isHidden: r, renderExpanded: s, setDragVisible: a, isGroup: c, handleMouseLeave: y, handleHeaderFooterMousewheel: C, tableSize: V, emptyBlockStyle: te, handleFixedMousewheel: (A, G) => { const se = o.refs.bodyWrapper; if (Math.abs(G.spinY) > 0) {
        const Z = se.scrollTop;
        G.pixelY < 0 && Z !== 0 && A.preventDefault(), G.pixelY > 0 && se.scrollHeight - se.clientHeight > Z && A.preventDefault(), se.scrollTop += Math.ceil(G.pixelY / 5);
    }
    else
        se.scrollLeft += Math.ceil(G.pixelX / 5); }, resizeProxyVisible: l, bodyWidth: R, resizeState: u, doLayout: T, tableBodyStyles: w, tableLayout: K, scrollbarViewStyle: d, tableInnerStyle: U, scrollbarStyle: D }; }
function eX(e) { const t = M(), n = () => { const r = e.vnode.el.querySelector(".hidden-columns"), s = { childList: !0, subtree: !0 }, l = e.store.states.updateOrderFns; t.value = new MutationObserver(() => { l.forEach(a => a()); }), t.value.observe(r, s); }; ft(() => { n(); }), rs(() => { var o; (o = t.value) == null || o.disconnect(); }); }
var tX = { data: { type: Array, default: () => [] }, size: Bn, width: [String, Number], height: [String, Number], maxHeight: [String, Number], fit: { type: Boolean, default: !0 }, stripe: Boolean, border: Boolean, rowKey: [String, Function], showHeader: { type: Boolean, default: !0 }, showSummary: Boolean, sumText: String, summaryMethod: Function, rowClassName: [String, Function], rowStyle: [Object, Function], cellClassName: [String, Function], cellStyle: [Object, Function], headerRowClassName: [String, Function], headerRowStyle: [Object, Function], headerCellClassName: [String, Function], headerCellStyle: [Object, Function], highlightCurrentRow: Boolean, currentRowKey: [String, Number], emptyText: String, expandRowKeys: Array, defaultExpandAll: Boolean, defaultSort: Object, tooltipEffect: String, tooltipOptions: Object, spanMethod: Function, selectOnIndeterminate: { type: Boolean, default: !0 }, indent: { type: Number, default: 16 }, treeProps: { type: Object, default: () => ({ hasChildren: "hasChildren", children: "children" }) }, lazy: Boolean, load: Function, style: { type: Object, default: () => ({}) }, className: { type: String, default: "" }, tableLayout: { type: String, default: "fixed" }, scrollbarAlwaysOn: { type: Boolean, default: !1 }, flexible: Boolean, showOverflowTooltip: [Boolean, Object] };
const nX = () => { const e = M(), t = (s, l) => { const a = e.value; a && a.scrollTo(s, l); }, n = (s, l) => { const a = e.value; a && lt(l) && ["Top", "Left"].includes(s) && a[`setScroll${s}`](l); }; return { scrollBarRef: e, scrollTo: t, setScrollTop: s => n("Top", s), setScrollLeft: s => n("Left", s) }; };
let oX = 1;
const rX = ae({ name: "ElTable", directives: { Mousewheel: GF }, components: { TableHeader: KG, TableBody: YG, TableFooter: JG, ElScrollbar: Or, hColgroup: Zh }, props: tX, emits: ["select", "select-all", "selection-change", "cell-mouse-enter", "cell-mouse-leave", "cell-contextmenu", "cell-click", "cell-dblclick", "row-click", "row-contextmenu", "row-dblclick", "header-click", "header-contextmenu", "sort-change", "filter-change", "current-change", "header-dragend", "expand-change"], setup(e) { const { t } = Nt(), n = Ie("table"), o = ht(); St(ar, o); const r = IG(o, e); o.store = r; const s = new AG({ store: o.store, table: o, fit: e.fit, showHeader: e.showHeader }); o.layout = s; const l = S(() => (r.states.data.value || []).length === 0), { setCurrentRow: a, getSelectionRows: u, toggleRowSelection: c, clearSelection: d, clearFilter: f, toggleAllSelection: p, toggleRowExpansion: v, clearSort: m, sort: h } = ZG(r), { isHidden: g, renderExpanded: y, setDragVisible: C, isGroup: b, handleMouseLeave: w, handleHeaderFooterMousewheel: T, tableSize: E, emptyBlockStyle: x, handleFixedMousewheel: I, resizeProxyVisible: L, bodyWidth: B, resizeState: F, doLayout: V, tableBodyStyles: R, tableLayout: K, scrollbarViewStyle: te, tableInnerStyle: U, scrollbarStyle: D } = QG(e, s, r, o), { scrollBarRef: j, scrollTo: A, setScrollLeft: G, setScrollTop: se } = nX(), Z = Xn(V, 50), ce = `${n.namespace.value}-table_${oX++}`; o.tableId = ce, o.state = { isGroup: b, resizeState: F, doLayout: V, debouncedUpdateLayout: Z }; const ye = S(() => e.sumText || t("el.table.sumText")), Re = S(() => e.emptyText || t("el.table.emptyText")); return eX(o), { ns: n, layout: s, store: r, handleHeaderFooterMousewheel: T, handleMouseLeave: w, tableId: ce, tableSize: E, isHidden: g, isEmpty: l, renderExpanded: y, resizeProxyVisible: L, resizeState: F, isGroup: b, bodyWidth: B, tableBodyStyles: R, emptyBlockStyle: x, debouncedUpdateLayout: Z, handleFixedMousewheel: I, setCurrentRow: a, getSelectionRows: u, toggleRowSelection: c, clearSelection: d, clearFilter: f, toggleAllSelection: p, toggleRowExpansion: v, clearSort: m, doLayout: V, sort: h, t, setDragVisible: C, context: o, computedSumText: ye, computedEmptyText: Re, tableLayout: K, scrollbarViewStyle: te, tableInnerStyle: U, scrollbarStyle: D, scrollBarRef: j, scrollTo: A, setScrollLeft: G, setScrollTop: se }; } }), sX = ["data-prefix"], lX = { ref: "hiddenColumns", class: "hidden-columns" };
function aX(e, t, n, o, r, s) { const l = ct("hColgroup"), a = ct("table-header"), u = ct("table-body"), c = ct("el-scrollbar"), d = ct("table-footer"), f = Va("mousewheel"); return k(), z("div", { ref: "tableWrapper", class: O([{ [e.ns.m("fit")]: e.fit, [e.ns.m("striped")]: e.stripe, [e.ns.m("border")]: e.border || e.isGroup, [e.ns.m("hidden")]: e.isHidden, [e.ns.m("group")]: e.isGroup, [e.ns.m("fluid-height")]: e.maxHeight, [e.ns.m("scrollable-x")]: e.layout.scrollX.value, [e.ns.m("scrollable-y")]: e.layout.scrollY.value, [e.ns.m("enable-row-hover")]: !e.store.states.isComplex.value, [e.ns.m("enable-row-transition")]: (e.store.states.data.value || []).length !== 0 && (e.store.states.data.value || []).length < 100, "has-footer": e.showSummary }, e.ns.m(e.tableSize), e.className, e.ns.b(), e.ns.m(`layout-${e.tableLayout}`)]), style: et(e.style), "data-prefix": e.ns.namespace.value, onMouseleave: t[0] || (t[0] = (...p) => e.handleMouseLeave && e.handleMouseLeave(...p)) }, [Q("div", { class: O(e.ns.e("inner-wrapper")), style: et(e.tableInnerStyle) }, [Q("div", lX, [ke(e.$slots, "default")], 512), e.showHeader && e.tableLayout === "fixed" ? dt((k(), z("div", { key: 0, ref: "headerWrapper", class: O(e.ns.e("header-wrapper")) }, [Q("table", { ref: "tableHeader", class: O(e.ns.e("header")), style: et(e.tableBodyStyles), border: "0", cellpadding: "0", cellspacing: "0" }, [ee(l, { columns: e.store.states.columns.value, "table-layout": e.tableLayout }, null, 8, ["columns", "table-layout"]), ee(a, { ref: "tableHeaderRef", border: e.border, "default-sort": e.defaultSort, store: e.store, onSetDragVisible: e.setDragVisible }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])], 6)], 2)), [[f, e.handleHeaderFooterMousewheel]]) : pe("v-if", !0), Q("div", { ref: "bodyWrapper", class: O(e.ns.e("body-wrapper")) }, [ee(c, { ref: "scrollBarRef", "view-style": e.scrollbarViewStyle, "wrap-style": e.scrollbarStyle, always: e.scrollbarAlwaysOn }, { default: ie(() => [Q("table", { ref: "tableBody", class: O(e.ns.e("body")), cellspacing: "0", cellpadding: "0", border: "0", style: et({ width: e.bodyWidth, tableLayout: e.tableLayout }) }, [ee(l, { columns: e.store.states.columns.value, "table-layout": e.tableLayout }, null, 8, ["columns", "table-layout"]), e.showHeader && e.tableLayout === "auto" ? (k(), ge(a, { key: 0, ref: "tableHeaderRef", border: e.border, "default-sort": e.defaultSort, store: e.store, onSetDragVisible: e.setDragVisible }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])) : pe("v-if", !0), ee(u, { context: e.context, highlight: e.highlightCurrentRow, "row-class-name": e.rowClassName, "tooltip-effect": e.tooltipEffect, "tooltip-options": e.tooltipOptions, "row-style": e.rowStyle, store: e.store, stripe: e.stripe }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"])], 6), e.isEmpty ? (k(), z("div", { key: 0, ref: "emptyBlock", style: et(e.emptyBlockStyle), class: O(e.ns.e("empty-block")) }, [Q("span", { class: O(e.ns.e("empty-text")) }, [ke(e.$slots, "empty", {}, () => [Ot(Be(e.computedEmptyText), 1)])], 2)], 6)) : pe("v-if", !0), e.$slots.append ? (k(), z("div", { key: 1, ref: "appendWrapper", class: O(e.ns.e("append-wrapper")) }, [ke(e.$slots, "append")], 2)) : pe("v-if", !0)]), _: 3 }, 8, ["view-style", "wrap-style", "always"])], 2), e.showSummary ? dt((k(), z("div", { key: 1, ref: "footerWrapper", class: O(e.ns.e("footer-wrapper")) }, [ee(d, { border: e.border, "default-sort": e.defaultSort, store: e.store, style: et(e.tableBodyStyles), "sum-text": e.computedSumText, "summary-method": e.summaryMethod }, null, 8, ["border", "default-sort", "store", "style", "sum-text", "summary-method"])], 2)), [[Pt, !e.isEmpty], [f, e.handleHeaderFooterMousewheel]]) : pe("v-if", !0), e.border || e.isGroup ? (k(), z("div", { key: 2, class: O(e.ns.e("border-left-patch")) }, null, 2)) : pe("v-if", !0)], 6), dt(Q("div", { ref: "resizeProxy", class: O(e.ns.e("column-resize-proxy")) }, null, 2), [[Pt, e.resizeProxyVisible]])], 46, sX); }
var iX = Fe(rX, [["render", aX], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/table.vue"]]);
const uX = { selection: "table-column--selection", expand: "table__expand-column" }, cX = { default: { order: "" }, selection: { width: 48, minWidth: 48, realWidth: 48, order: "" }, expand: { width: 48, minWidth: 48, realWidth: 48, order: "" }, index: { width: 48, minWidth: 48, realWidth: 48, order: "" } }, dX = e => uX[e] || "", fX = { selection: { renderHeader({ store: e }) { function t() { return e.states.data.value && e.states.data.value.length === 0; } return nt(Ao, { disabled: t(), size: e.states.tableSize.value, indeterminate: e.states.selection.value.length > 0 && !e.states.isAllSelected.value, "onUpdate:modelValue": e.toggleAllSelection, modelValue: e.states.isAllSelected.value }); }, renderCell({ row: e, column: t, store: n, $index: o }) { return nt(Ao, { disabled: t.selectable ? !t.selectable.call(null, e, o) : !1, size: n.states.tableSize.value, onChange: () => { n.commit("rowSelectedChanged", e); }, onClick: r => r.stopPropagation(), modelValue: n.isSelected(e) }); }, sortable: !1, resizable: !1 }, index: { renderHeader({ column: e }) { return e.label || "#"; }, renderCell({ column: e, $index: t }) { let n = t + 1; const o = e.index; return typeof o == "number" ? n = t + o : typeof o == "function" && (n = o(t)), nt("div", {}, [n]); }, sortable: !1 }, expand: { renderHeader({ column: e }) { return e.label || ""; }, renderCell({ row: e, store: t, expanded: n }) { const { ns: o } = t, r = [o.e("expand-icon")]; return n && r.push(o.em("expand-icon", "expanded")), nt("div", { class: r, onClick: function (l) { l.stopPropagation(), t.toggleRowExpansion(e); } }, { default: () => [nt(Je, null, { default: () => [nt(Un)] })] }); }, sortable: !1, resizable: !1 } };
function pX({ row: e, column: t, $index: n }) { var o; const r = t.property, s = r && cu(e, r).value; return t && t.formatter ? t.formatter(e, t, s, n) : ((o = s == null ? void 0 : s.toString) == null ? void 0 : o.call(s)) || ""; }
function hX({ row: e, treeNode: t, store: n }, o = !1) { const { ns: r } = n; if (!t)
    return o ? [nt("span", { class: r.e("placeholder") })] : null; const s = [], l = function (a) { a.stopPropagation(), !t.loading && n.loadOrToggle(e); }; if (t.indent && s.push(nt("span", { class: r.e("indent"), style: { "padding-left": `${t.indent}px` } })), typeof t.expanded == "boolean" && !t.noLazyChildren) {
    const a = [r.e("expand-icon"), t.expanded ? r.em("expand-icon", "expanded") : ""];
    let u = Un;
    t.loading && (u = as), s.push(nt("div", { class: a, onClick: l }, { default: () => [nt(Je, { class: { [r.is("loading")]: t.loading } }, { default: () => [nt(u)] })] }));
}
else
    s.push(nt("span", { class: r.e("placeholder") })); return s; }
function ey(e, t) { return e.reduce((n, o) => (n[o] = o, n), t); }
function vX(e, t) { const n = ht(); return { registerComplexWatchers: () => { const s = ["fixed"], l = { realWidth: "width", realMinWidth: "minWidth" }, a = ey(s, l); Object.keys(a).forEach(u => { const c = l[u]; Tt(t, c) && Oe(() => t[c], d => { let f = d; c === "width" && u === "realWidth" && (f = Gh(d)), c === "minWidth" && u === "realMinWidth" && (f = K2(d)), n.columnConfig.value[c] = f, n.columnConfig.value[u] = f; const p = c === "fixed"; e.value.store.scheduleLayout(p); }); }); }, registerNormalWatchers: () => { const s = ["label", "filters", "filterMultiple", "sortable", "index", "formatter", "className", "labelClassName", "showOverflowTooltip"], l = { property: "prop", align: "realAlign", headerAlign: "realHeaderAlign" }, a = ey(s, l); Object.keys(a).forEach(u => { const c = l[u]; Tt(t, c) && Oe(() => t[c], d => { n.columnConfig.value[u] = d; }); }); } }; }
function mX(e, t, n) { const o = ht(), r = M(""), s = M(!1), l = M(), a = M(), u = Ie("table"); mo(() => { l.value = e.align ? `is-${e.align}` : null, l.value; }), mo(() => { a.value = e.headerAlign ? `is-${e.headerAlign}` : l.value, a.value; }); const c = S(() => { let w = o.vnode.vParent || o.parent; for (; w && !w.tableId && !w.columnId;)
    w = w.vnode.vParent || w.parent; return w; }), d = S(() => { const { store: w } = o.parent; if (!w)
    return !1; const { treeData: T } = w.states, E = T.value; return E && Object.keys(E).length > 0; }), f = M(Gh(e.width)), p = M(K2(e.minWidth)), v = w => (f.value && (w.width = f.value), p.value && (w.minWidth = p.value), !f.value && p.value && (w.width = void 0), w.minWidth || (w.minWidth = 80), w.realWidth = Number(w.width === void 0 ? w.minWidth : w.width), w), m = w => { const T = w.type, E = fX[T] || {}; Object.keys(E).forEach(I => { const L = E[I]; I !== "className" && L !== void 0 && (w[I] = L); }); const x = dX(T); if (x) {
    const I = `${i(u.namespace)}-${x}`;
    w.className = w.className ? `${w.className} ${I}` : I;
} return w; }, h = w => { Array.isArray(w) ? w.forEach(E => T(E)) : T(w); function T(E) { var x; ((x = E == null ? void 0 : E.type) == null ? void 0 : x.name) === "ElTableColumn" && (E.vParent = o); } }; return { columnId: r, realAlign: l, isSubColumn: s, realHeaderAlign: a, columnOrTableParent: c, setColumnWidth: v, setColumnForcedProps: m, setColumnRenders: w => { e.renderHeader || w.type !== "selection" && (w.renderHeader = E => { o.columnConfig.value.label; const x = t.header; return x ? x(E) : w.label; }); let T = w.renderCell; return w.type === "expand" ? (w.renderCell = E => nt("div", { class: "cell" }, [T(E)]), n.value.renderExpanded = E => t.default ? t.default(E) : t.default) : (T = T || pX, w.renderCell = E => { let x = null; if (t.default) {
        const R = t.default(E);
        x = R.some(K => K.type !== Wn) ? R : T(E);
    }
    else
        x = T(E); const { columns: I } = n.value.store.states, L = I.value.findIndex(R => R.type === "default"), B = d.value && E.cellIndex === L, F = hX(E, B), V = { class: "cell", style: {} }; return w.showOverflowTooltip && (V.class = `${V.class} ${i(u.namespace)}-tooltip`, V.style = { width: `${(E.column.realWidth || Number(E.column.width)) - 1}px` }), h(x), nt("div", V, [F, x]); }), w; }, getPropsData: (...w) => w.reduce((T, E) => (Array.isArray(E) && E.forEach(x => { T[x] = e[x]; }), T), {}), getColumnElIndex: (w, T) => Array.prototype.indexOf.call(w, T), updateColumnOrder: () => { n.value.store.commit("updateColumnOrder", o.columnConfig.value); } }; }
var gX = { type: { type: String, default: "default" }, label: String, className: String, labelClassName: String, property: String, prop: String, width: { type: [String, Number], default: "" }, minWidth: { type: [String, Number], default: "" }, renderHeader: Function, sortable: { type: [Boolean, String], default: !1 }, sortMethod: Function, sortBy: [String, Function, Array], resizable: { type: Boolean, default: !0 }, columnKey: String, align: String, headerAlign: String, showOverflowTooltip: { type: [Boolean, Object], default: void 0 }, fixed: [Boolean, String], formatter: Function, selectable: Function, reserveSelection: Boolean, filterMethod: Function, filteredValue: Array, filters: Array, filterPlacement: String, filterMultiple: { type: Boolean, default: !0 }, index: [Number, Function], sortOrders: { type: Array, default: () => ["ascending", "descending", null], validator: e => e.every(t => ["ascending", "descending", null].includes(t)) } };
let yX = 1;
var X2 = ae({ name: "ElTableColumn", components: { ElCheckbox: Ao }, props: gX, setup(e, { slots: t }) { const n = ht(), o = M({}), r = S(() => { let b = n.parent; for (; b && !b.tableId;)
        b = b.parent; return b; }), { registerNormalWatchers: s, registerComplexWatchers: l } = vX(r, e), { columnId: a, isSubColumn: u, realHeaderAlign: c, columnOrTableParent: d, setColumnWidth: f, setColumnForcedProps: p, setColumnRenders: v, getPropsData: m, getColumnElIndex: h, realAlign: g, updateColumnOrder: y } = mX(e, t, r), C = d.value; a.value = `${C.tableId || C.columnId}_column_${yX++}`, mc(() => { u.value = r.value !== C; const b = e.type || "default", w = e.sortable === "" ? !0 : e.sortable, T = En(e.showOverflowTooltip) ? C.props.showOverflowTooltip : e.showOverflowTooltip, E = { ...cX[b], id: a.value, type: b, property: e.prop || e.property, align: g, headerAlign: c, showOverflowTooltip: T, filterable: e.filters || e.filterMethod, filteredValue: [], filterPlacement: "", isColumnGroup: !1, isSubColumn: !1, filterOpened: !1, sortable: w, index: e.index, rawColumnKey: n.vnode.key }; let F = m(["columnKey", "label", "className", "labelClassName", "type", "renderHeader", "formatter", "fixed", "resizable"], ["sortMethod", "sortBy", "sortOrders"], ["selectable", "reserveSelection"], ["filterMethod", "filters", "filterMultiple", "filterOpened", "filteredValue", "filterPlacement"]); F = yG(E, F), F = wG(v, f, p)(F), o.value = F, s(), l(); }), ft(() => { var b; const w = d.value, T = u.value ? w.vnode.el.children : (b = w.refs.hiddenColumns) == null ? void 0 : b.children, E = () => h(T || [], n.vnode.el); o.value.getColumnIndex = E, E() > -1 && r.value.store.commit("insertColumn", o.value, u.value ? w.columnConfig.value : null, y); }), on(() => { r.value.store.commit("removeColumn", o.value, u.value ? C.columnConfig.value : null, y); }), n.columnId = a.value, n.columnConfig = o; }, render() { var e, t, n; try {
        const o = (t = (e = this.$slots).default) == null ? void 0 : t.call(e, { row: {}, column: {}, $index: -1 }), r = [];
        if (Array.isArray(o))
            for (const l of o)
                ((n = l.type) == null ? void 0 : n.name) === "ElTableColumn" || l.shapeFlag & 2 ? r.push(l) : l.type === Qe && Array.isArray(l.children) && l.children.forEach(a => { (a == null ? void 0 : a.patchFlag) !== 1024 && !it(a == null ? void 0 : a.children) && r.push(a); });
        return nt("div", r);
    }
    catch {
        return nt("div", []);
    } } });
const bX = vt(iX, { TableColumn: X2 }), wX = pn(X2);
var ci = (e => (e.ASC = "asc", e.DESC = "desc", e))(ci || {}), di = (e => (e.CENTER = "center", e.RIGHT = "right", e))(di || {}), J2 = (e => (e.LEFT = "left", e.RIGHT = "right", e))(J2 || {});
const tp = { asc: "desc", desc: "asc" }, fi = Symbol("placeholder"), CX = (e, t, n) => { var o; const r = { flexGrow: 0, flexShrink: 0, ...n ? {} : { flexGrow: e.flexGrow || 0, flexShrink: e.flexShrink || 1 } }; n || (r.flexShrink = 1); const s = { ...(o = e.style) != null ? o : {}, ...r, flexBasis: "auto", width: e.width }; return t || (e.maxWidth && (s.maxWidth = e.maxWidth), e.minWidth && (s.minWidth = e.minWidth)), s; };
function SX(e, t, n) { const o = S(() => i(t).filter(h => !h.hidden)), r = S(() => i(o).filter(h => h.fixed === "left" || h.fixed === !0)), s = S(() => i(o).filter(h => h.fixed === "right")), l = S(() => i(o).filter(h => !h.fixed)), a = S(() => { const h = []; return i(r).forEach(g => { h.push({ ...g, placeholderSign: fi }); }), i(l).forEach(g => { h.push(g); }), i(s).forEach(g => { h.push({ ...g, placeholderSign: fi }); }), h; }), u = S(() => i(r).length || i(s).length), c = S(() => i(t).reduce((g, y) => (g[y.key] = CX(y, i(n), e.fixed), g), {})), d = S(() => i(o).reduce((h, g) => h + g.width, 0)), f = h => i(t).find(g => g.key === h), p = h => i(c)[h], v = (h, g) => { h.width = g; }; function m(h) { var g; const { key: y } = h.currentTarget.dataset; if (!y)
    return; const { sortState: C, sortBy: b } = e; let w = ci.ASC; yt(C) ? w = tp[C[y]] : w = tp[b.order], (g = e.onColumnSort) == null || g.call(e, { column: f(y), key: y, order: w }); } return { columns: t, columnsStyles: c, columnsTotalWidth: d, fixedColumnsOnLeft: r, fixedColumnsOnRight: s, hasFixedColumns: u, mainColumns: a, normalColumns: l, visibleColumns: o, getColumn: f, getColumnStyle: p, updateColumnWidth: v, onColumnSorted: m }; }
const _X = (e, { mainTableRef: t, leftTableRef: n, rightTableRef: o, onMaybeEndReached: r }) => { const s = M({ scrollLeft: 0, scrollTop: 0 }); function l(v) { var m, h, g; const { scrollTop: y } = v; (m = t.value) == null || m.scrollTo(v), (h = n.value) == null || h.scrollToTop(y), (g = o.value) == null || g.scrollToTop(y); } function a(v) { s.value = v, l(v); } function u(v) { s.value.scrollTop = v, l(i(s)); } function c(v) { var m, h; s.value.scrollLeft = v, (h = (m = t.value) == null ? void 0 : m.scrollTo) == null || h.call(m, i(s)); } function d(v) { var m; a(v), (m = e.onScroll) == null || m.call(e, v); } function f({ scrollTop: v }) { const { scrollTop: m } = i(s); v !== m && u(v); } function p(v, m = "auto") { var h; (h = t.value) == null || h.scrollToRow(v, m); } return Oe(() => i(s).scrollTop, (v, m) => { v > m && r(); }), { scrollPos: s, scrollTo: a, scrollToLeft: c, scrollToTop: u, scrollToRow: p, onScroll: d, onVerticalScroll: f }; }, kX = (e, { mainTableRef: t, leftTableRef: n, rightTableRef: o }) => { const r = ht(), { emit: s } = r, l = Xt(!1), a = Xt(null), u = M(e.defaultExpandedRowKeys || []), c = M(-1), d = Xt(null), f = M({}), p = M({}), v = Xt({}), m = Xt({}), h = Xt({}), g = S(() => lt(e.estimatedRowHeight)); function y(I) { var L; (L = e.onRowsRendered) == null || L.call(e, I), I.rowCacheEnd > i(c) && (c.value = I.rowCacheEnd); } function C({ hovered: I, rowKey: L }) { a.value = I ? L : null; } function b({ expanded: I, rowData: L, rowIndex: B, rowKey: F }) { var V, R; const K = [...i(u)], te = K.indexOf(F); I ? te === -1 && K.push(F) : te > -1 && K.splice(te, 1), u.value = K, s("update:expandedRowKeys", K), (V = e.onRowExpand) == null || V.call(e, { expanded: I, rowData: L, rowIndex: B, rowKey: F }), (R = e.onExpandedRowsChange) == null || R.call(e, K); } const w = Xn(() => { var I, L, B, F; l.value = !0, f.value = { ...i(f), ...i(p) }, T(i(d), !1), p.value = {}, d.value = null, (I = t.value) == null || I.forceUpdate(), (L = n.value) == null || L.forceUpdate(), (B = o.value) == null || B.forceUpdate(), (F = r.proxy) == null || F.$forceUpdate(), l.value = !1; }, 0); function T(I, L = !1) { i(g) && [t, n, o].forEach(B => { const F = i(B); F && F.resetAfterRowIndex(I, L); }); } function E(I, L, B) { const F = i(d); (F === null || F > B) && (d.value = B), p.value[I] = L; } function x({ rowKey: I, height: L, rowIndex: B }, F) { F ? F === J2.RIGHT ? h.value[I] = L : v.value[I] = L : m.value[I] = L; const V = Math.max(...[v, h, m].map(R => R.value[I] || 0)); i(f)[I] !== V && (E(I, V, B), w()); } return { hoveringRowKey: a, expandedRowKeys: u, lastRenderedRowIndex: c, isDynamic: g, isResetting: l, rowHeights: f, resetAfterIndex: T, onRowExpanded: b, onRowHovered: C, onRowsRendered: y, onRowHeightChange: x }; }, EX = (e, { expandedRowKeys: t, lastRenderedRowIndex: n, resetAfterIndex: o }) => { const r = M({}), s = S(() => { const a = {}, { data: u, rowKey: c } = e, d = i(t); if (!d || !d.length)
    return u; const f = [], p = new Set; d.forEach(m => p.add(m)); let v = u.slice(); for (v.forEach(m => a[m[c]] = 0); v.length > 0;) {
    const m = v.shift();
    f.push(m), p.has(m[c]) && Array.isArray(m.children) && m.children.length > 0 && (v = [...m.children, ...v], m.children.forEach(h => a[h[c]] = a[m[c]] + 1));
} return r.value = a, f; }), l = S(() => { const { data: a, expandColumnKey: u } = e; return u ? i(s) : a; }); return Oe(l, (a, u) => { a !== u && (n.value = -1, o(0, !0)); }), { data: l, depthMap: r }; }, $X = (e, t) => e + t, Eu = e => qe(e) ? e.reduce($X, 0) : e, Ks = (e, t, n = {}) => at(e) ? e(t) : e ?? n, Wr = e => (["width", "maxWidth", "minWidth", "height"].forEach(t => { e[t] = gn(e[t]); }), e), Z2 = e => un(e) ? t => nt(e, t) : e, TX = (e, { columnsTotalWidth: t, data: n, fixedColumnsOnLeft: o, fixedColumnsOnRight: r }) => { const s = S(() => { const { fixed: b, width: w, vScrollbarSize: T } = e, E = w - T; return b ? Math.max(Math.round(i(t)), E) : E; }), l = S(() => i(s) + (e.fixed ? e.vScrollbarSize : 0)), a = S(() => { const { height: b = 0, maxHeight: w = 0, footerHeight: T, hScrollbarSize: E } = e; if (w > 0) {
    const x = i(m), I = i(u), B = i(v) + x + I + E;
    return Math.min(B, w - T);
} return b - T; }), u = S(() => { const { rowHeight: b, estimatedRowHeight: w } = e, T = i(n); return lt(w) ? T.length * w : T.length * b; }), c = S(() => { const { maxHeight: b } = e, w = i(a); if (lt(b) && b > 0)
    return w; const T = i(u) + i(v) + i(m); return Math.min(w, T); }), d = b => b.width, f = S(() => Eu(i(o).map(d))), p = S(() => Eu(i(r).map(d))), v = S(() => Eu(e.headerHeight)), m = S(() => { var b; return (((b = e.fixedData) == null ? void 0 : b.length) || 0) * e.rowHeight; }), h = S(() => i(a) - i(v) - i(m)), g = S(() => { const { style: b = {}, height: w, width: T } = e; return Wr({ ...b, height: w, width: T }); }), y = S(() => Wr({ height: e.footerHeight })), C = S(() => ({ top: gn(i(v)), bottom: gn(e.footerHeight), width: gn(e.width) })); return { bodyWidth: s, fixedTableHeight: c, mainTableHeight: a, leftTableWidth: f, rightTableWidth: p, headerWidth: l, rowsHeight: u, windowHeight: h, footerHeight: y, emptyStyle: C, rootStyle: g, headerHeight: v }; }, OX = e => { const t = M(), n = M(0), o = M(0); let r; return ft(() => { r = Vn(t, ([s]) => { const { width: l, height: a } = s.contentRect, { paddingLeft: u, paddingRight: c, paddingTop: d, paddingBottom: f } = getComputedStyle(s.target), p = Number.parseInt(u) || 0, v = Number.parseInt(c) || 0, m = Number.parseInt(d) || 0, h = Number.parseInt(f) || 0; n.value = l - p - v, o.value = a - m - h; }).stop; }), on(() => { r == null || r(); }), Oe([n, o], ([s, l]) => { var a; (a = e.onResize) == null || a.call(e, { width: s, height: l }); }), { sizer: t, width: n, height: o }; };
function IX(e) { const t = M(), n = M(), o = M(), { columns: r, columnsStyles: s, columnsTotalWidth: l, fixedColumnsOnLeft: a, fixedColumnsOnRight: u, hasFixedColumns: c, mainColumns: d, onColumnSorted: f } = SX(e, an(e, "columns"), an(e, "fixed")), { scrollTo: p, scrollToLeft: v, scrollToTop: m, scrollToRow: h, onScroll: g, onVerticalScroll: y, scrollPos: C } = _X(e, { mainTableRef: t, leftTableRef: n, rightTableRef: o, onMaybeEndReached: q }), { expandedRowKeys: b, hoveringRowKey: w, lastRenderedRowIndex: T, isDynamic: E, isResetting: x, rowHeights: I, resetAfterIndex: L, onRowExpanded: B, onRowHeightChange: F, onRowHovered: V, onRowsRendered: R } = kX(e, { mainTableRef: t, leftTableRef: n, rightTableRef: o }), { data: K, depthMap: te } = EX(e, { expandedRowKeys: b, lastRenderedRowIndex: T, resetAfterIndex: L }), { bodyWidth: U, fixedTableHeight: D, mainTableHeight: j, leftTableWidth: A, rightTableWidth: G, headerWidth: se, rowsHeight: Z, windowHeight: ce, footerHeight: ye, emptyStyle: Re, rootStyle: me, headerHeight: le } = TX(e, { columnsTotalWidth: l, data: K, fixedColumnsOnLeft: a, fixedColumnsOnRight: u }), oe = Xt(!1), fe = M(), Ce = S(() => { const re = i(K).length === 0; return qe(e.fixedData) ? e.fixedData.length === 0 && re : re; }); function Ae(re) { const { estimatedRowHeight: he, rowHeight: Ee, rowKey: Ne } = e; return he ? i(I)[i(K)[re][Ne]] || he : Ee; } function q() { const { onEndReached: re } = e; if (!re)
    return; const { scrollTop: he } = i(C), Ee = i(Z), Ne = i(ce), Se = Ee - (he + Ne) + e.hScrollbarSize; i(T) >= 0 && Ee === he + i(j) - i(le) && re(Se); } return Oe(() => e.expandedRowKeys, re => b.value = re, { deep: !0 }), { columns: r, containerRef: fe, mainTableRef: t, leftTableRef: n, rightTableRef: o, isDynamic: E, isResetting: x, isScrolling: oe, hoveringRowKey: w, hasFixedColumns: c, columnsStyles: s, columnsTotalWidth: l, data: K, expandedRowKeys: b, depthMap: te, fixedColumnsOnLeft: a, fixedColumnsOnRight: u, mainColumns: d, bodyWidth: U, emptyStyle: Re, rootStyle: me, headerWidth: se, footerHeight: ye, mainTableHeight: j, fixedTableHeight: D, leftTableWidth: A, rightTableWidth: G, showEmpty: Ce, getRowHeight: Ae, onColumnSorted: f, onRowHovered: V, onRowExpanded: B, onRowsRendered: R, onRowHeightChange: F, scrollTo: p, scrollToLeft: v, scrollToTop: m, scrollToRow: h, onScroll: g, onVerticalScroll: y }; }
const Qh = Symbol("tableV2"), Q2 = String, Oi = { type: ve(Array), required: !0 }, ev = { type: ve(Array) }, eS = { ...ev, required: !0 }, xX = String, ty = { type: ve(Array), default: () => ln([]) }, ks = { type: Number, required: !0 }, tS = { type: ve([String, Number, Symbol]), default: "id" }, ny = { type: ve(Object) }, As = Ve({ class: String, columns: Oi, columnsStyles: { type: ve(Object), required: !0 }, depth: Number, expandColumnKey: xX, estimatedRowHeight: { ...Ds.estimatedRowHeight, default: void 0 }, isScrolling: Boolean, onRowExpand: { type: ve(Function) }, onRowHover: { type: ve(Function) }, onRowHeightChange: { type: ve(Function) }, rowData: { type: ve(Object), required: !0 }, rowEventHandlers: { type: ve(Object) }, rowIndex: { type: Number, required: !0 }, rowKey: tS, style: { type: ve(Object) } }), Fd = { type: Number, required: !0 }, tv = Ve({ class: String, columns: Oi, fixedHeaderData: { type: ve(Array) }, headerData: { type: ve(Array), required: !0 }, headerHeight: { type: ve([Number, Array]), default: 50 }, rowWidth: Fd, rowHeight: { type: Number, default: 50 }, height: Fd, width: Fd }), $u = Ve({ columns: Oi, data: eS, fixedData: ev, estimatedRowHeight: As.estimatedRowHeight, width: ks, height: ks, headerWidth: ks, headerHeight: tv.headerHeight, bodyWidth: ks, rowHeight: ks, cache: E2.cache, useIsScrolling: Boolean, scrollbarAlwaysOn: Ds.scrollbarAlwaysOn, scrollbarStartGap: Ds.scrollbarStartGap, scrollbarEndGap: Ds.scrollbarEndGap, class: Q2, style: ny, containerStyle: ny, getRowHeight: { type: ve(Function), required: !0 }, rowKey: As.rowKey, onRowsRendered: { type: ve(Function) }, onScroll: { type: ve(Function) } }), AX = Ve({ cache: $u.cache, estimatedRowHeight: As.estimatedRowHeight, rowKey: tS, headerClass: { type: ve([String, Function]) }, headerProps: { type: ve([Object, Function]) }, headerCellProps: { type: ve([Object, Function]) }, headerHeight: tv.headerHeight, footerHeight: { type: Number, default: 0 }, rowClass: { type: ve([String, Function]) }, rowProps: { type: ve([Object, Function]) }, rowHeight: { type: Number, default: 50 }, cellProps: { type: ve([Object, Function]) }, columns: Oi, data: eS, dataGetter: { type: ve(Function) }, fixedData: ev, expandColumnKey: As.expandColumnKey, expandedRowKeys: ty, defaultExpandedRowKeys: ty, class: Q2, fixed: Boolean, style: { type: ve(Object) }, width: ks, height: ks, maxHeight: Number, useIsScrolling: Boolean, indentSize: { type: Number, default: 12 }, iconSize: { type: Number, default: 12 }, hScrollbarSize: Ds.hScrollbarSize, vScrollbarSize: Ds.vScrollbarSize, scrollbarAlwaysOn: O2.alwaysOn, sortBy: { type: ve(Object), default: () => ({}) }, sortState: { type: ve(Object), default: void 0 }, onColumnSort: { type: ve(Function) }, onExpandedRowsChange: { type: ve(Function) }, onEndReached: { type: ve(Function) }, onRowExpand: As.onRowExpand, onScroll: $u.onScroll, onRowsRendered: $u.onRowsRendered, rowEventHandlers: As.rowEventHandlers }), nv = (e, { slots: t }) => { var n; const { cellData: o, style: r } = e, s = ((n = o == null ? void 0 : o.toString) == null ? void 0 : n.call(o)) || ""; return ee("div", { class: e.class, title: s, style: r }, [t.default ? t.default(e) : s]); };
nv.displayName = "ElTableV2Cell";
nv.inheritAttrs = !1;
const ov = (e, { slots: t }) => { var n, o; return t.default ? t.default(e) : ee("div", { class: e.class, title: (n = e.column) == null ? void 0 : n.title }, [(o = e.column) == null ? void 0 : o.title]); };
ov.displayName = "ElTableV2HeaderCell";
ov.inheritAttrs = !1;
const MX = Ve({ class: String, columns: Oi, columnsStyles: { type: ve(Object), required: !0 }, headerIndex: Number, style: { type: ve(Object) } }), NX = ae({ name: "ElTableV2HeaderRow", props: MX, setup(e, { slots: t }) { return () => { const { columns: n, columnsStyles: o, headerIndex: r, style: s } = e; let l = n.map((a, u) => t.cell({ columns: n, column: a, columnIndex: u, headerIndex: r, style: o[a.key] })); return t.header && (l = t.header({ cells: l.map(a => qe(a) && a.length === 1 ? a[0] : a), columns: n, headerIndex: r })), ee("div", { class: e.class, style: s, role: "row" }, [l]); }; } }), PX = "ElTableV2Header", RX = ae({ name: PX, props: tv, setup(e, { slots: t, expose: n }) { const o = Ie("table-v2"), r = M(), s = S(() => Wr({ width: e.width, height: e.height })), l = S(() => Wr({ width: e.rowWidth, height: e.height })), a = S(() => xl(i(e.headerHeight))), u = f => { const p = i(r); Xe(() => { p != null && p.scroll && p.scroll({ left: f }); }); }, c = () => { const f = o.e("fixed-header-row"), { columns: p, fixedHeaderData: v, rowHeight: m } = e; return v == null ? void 0 : v.map((h, g) => { var y; const C = Wr({ height: m, width: "100%" }); return (y = t.fixed) == null ? void 0 : y.call(t, { class: f, columns: p, rowData: h, rowIndex: -(g + 1), style: C }); }); }, d = () => { const f = o.e("dynamic-header-row"), { columns: p } = e; return i(a).map((v, m) => { var h; const g = Wr({ width: "100%", height: v }); return (h = t.dynamic) == null ? void 0 : h.call(t, { class: f, columns: p, headerIndex: m, style: g }); }); }; return n({ scrollToLeft: u }), () => { if (!(e.height <= 0))
        return ee("div", { ref: r, class: e.class, style: i(s), role: "rowgroup" }, [ee("div", { style: i(l), class: o.e("header") }, [d(), c()])]); }; } }), LX = e => { const { isScrolling: t } = Ye(Qh), n = M(!1), o = M(), r = S(() => lt(e.estimatedRowHeight) && e.rowIndex >= 0), s = (u = !1) => { const c = i(o); if (!c)
    return; const { columns: d, onRowHeightChange: f, rowKey: p, rowIndex: v, style: m } = e, { height: h } = c.getBoundingClientRect(); n.value = !0, Xe(() => { if (u || h !== Number.parseInt(m.height)) {
    const g = d[0], y = (g == null ? void 0 : g.placeholderSign) === fi;
    f == null || f({ rowKey: p, height: h, rowIndex: v }, g && !y && g.fixed);
} }); }, l = S(() => { const { rowData: u, rowIndex: c, rowKey: d, onRowHover: f } = e, p = e.rowEventHandlers || {}, v = {}; return Object.entries(p).forEach(([m, h]) => { at(h) && (v[m] = g => { h({ event: g, rowData: u, rowIndex: c, rowKey: d }); }); }), f && [{ name: "onMouseleave", hovered: !1 }, { name: "onMouseenter", hovered: !0 }].forEach(({ name: m, hovered: h }) => { const g = v[m]; v[m] = y => { f({ event: y, hovered: h, rowData: u, rowIndex: c, rowKey: d }), g == null || g(y); }; }), v; }), a = u => { const { onRowExpand: c, rowData: d, rowIndex: f, rowKey: p } = e; c == null || c({ expanded: u, rowData: d, rowIndex: f, rowKey: p }); }; return ft(() => { i(r) && s(!0); }), { isScrolling: t, measurable: r, measured: n, rowRef: o, eventHandlers: l, onExpand: a }; }, DX = "ElTableV2TableRow", BX = ae({ name: DX, props: As, setup(e, { expose: t, slots: n, attrs: o }) { const { eventHandlers: r, isScrolling: s, measurable: l, measured: a, rowRef: u, onExpand: c } = LX(e); return t({ onExpand: c }), () => { const { columns: d, columnsStyles: f, expandColumnKey: p, depth: v, rowData: m, rowIndex: h, style: g } = e; let y = d.map((C, b) => { const w = qe(m.children) && m.children.length > 0 && C.key === p; return n.cell({ column: C, columns: d, columnIndex: b, depth: v, style: f[C.key], rowData: m, rowIndex: h, isScrolling: i(s), expandIconProps: w ? { rowData: m, rowIndex: h, onExpand: c } : void 0 }); }); if (n.row && (y = n.row({ cells: y.map(C => qe(C) && C.length === 1 ? C[0] : C), style: g, columns: d, depth: v, rowData: m, rowIndex: h, isScrolling: i(s) })), i(l)) {
        const { height: C, ...b } = g || {}, w = i(a);
        return ee("div", Ct({ ref: u, class: e.class, style: w ? g : b, role: "row" }, o, i(r)), [y]);
    } return ee("div", Ct(o, { ref: u, class: e.class, style: g, role: "row" }, i(r)), [y]); }; } }), FX = e => { const { sortOrder: t } = e; return ee(Je, { size: 14, class: e.class }, { default: () => [t === ci.ASC ? ee(aR, null, null) : ee(tR, null, null)] }); }, VX = e => { const { expanded: t, expandable: n, onExpand: o, style: r, size: s } = e, l = { onClick: n ? () => o(!t) : void 0, class: e.class }; return ee(Je, Ct(l, { size: s, style: r }), { default: () => [ee(Un, null, null)] }); }, zX = "ElTableV2Grid", HX = e => { const t = M(), n = M(), o = S(() => { const { data: h, rowHeight: g, estimatedRowHeight: y } = e; if (!y)
    return h.length * g; }), r = S(() => { const { fixedData: h, rowHeight: g } = e; return ((h == null ? void 0 : h.length) || 0) * g; }), s = S(() => Eu(e.headerHeight)), l = S(() => { const { height: h } = e; return Math.max(0, h - i(s) - i(r)); }), a = S(() => i(s) + i(r) > 0), u = ({ data: h, rowIndex: g }) => h[g][e.rowKey]; function c({ rowCacheStart: h, rowCacheEnd: g, rowVisibleStart: y, rowVisibleEnd: C }) { var b; (b = e.onRowsRendered) == null || b.call(e, { rowCacheStart: h, rowCacheEnd: g, rowVisibleStart: y, rowVisibleEnd: C }); } function d(h, g) { var y; (y = n.value) == null || y.resetAfterRowIndex(h, g); } function f(h, g) { const y = i(t), C = i(n); !y || !C || (yt(h) ? (y.scrollToLeft(h.scrollLeft), C.scrollTo(h)) : (y.scrollToLeft(h), C.scrollTo({ scrollLeft: h, scrollTop: g }))); } function p(h) { var g; (g = i(n)) == null || g.scrollTo({ scrollTop: h }); } function v(h, g) { var y; (y = i(n)) == null || y.scrollToItem(h, 1, g); } function m() { var h, g; (h = i(n)) == null || h.$forceUpdate(), (g = i(t)) == null || g.$forceUpdate(); } return { bodyRef: n, forceUpdate: m, fixedRowHeight: r, gridHeight: l, hasHeader: a, headerHeight: s, headerRef: t, totalHeight: o, itemKey: u, onItemRendered: c, resetAfterRowIndex: d, scrollTo: f, scrollToTop: p, scrollToRow: v }; }, rv = ae({ name: zX, props: $u, setup(e, { slots: t, expose: n }) { const { ns: o } = Ye(Qh), { bodyRef: r, fixedRowHeight: s, gridHeight: l, hasHeader: a, headerRef: u, headerHeight: c, totalHeight: d, forceUpdate: f, itemKey: p, onItemRendered: v, resetAfterRowIndex: m, scrollTo: h, scrollToTop: g, scrollToRow: y } = HX(e); n({ forceUpdate: f, totalHeight: d, scrollTo: h, scrollToTop: g, scrollToRow: y, resetAfterRowIndex: m }); const C = () => e.bodyWidth; return () => { const { cache: b, columns: w, data: T, fixedData: E, useIsScrolling: x, scrollbarAlwaysOn: I, scrollbarEndGap: L, scrollbarStartGap: B, style: F, rowHeight: V, bodyWidth: R, estimatedRowHeight: K, headerWidth: te, height: U, width: D, getRowHeight: j, onScroll: A } = e, G = lt(K), se = G ? yq : hq, Z = i(c); return ee("div", { role: "table", class: [o.e("table"), e.class], style: F }, [ee(se, { ref: r, data: T, useIsScrolling: x, itemKey: p, columnCache: 0, columnWidth: G ? C : R, totalColumn: 1, totalRow: T.length, rowCache: b, rowHeight: G ? j : V, width: D, height: i(l), class: o.e("body"), role: "rowgroup", scrollbarStartGap: B, scrollbarEndGap: L, scrollbarAlwaysOn: I, onScroll: A, onItemRendered: v, perfMode: !1 }, { default: ce => { var ye; const Re = T[ce.rowIndex]; return (ye = t.row) == null ? void 0 : ye.call(t, { ...ce, columns: w, rowData: Re }); } }), i(a) && ee(RX, { ref: u, class: o.e("header-wrapper"), columns: w, headerData: T, headerHeight: e.headerHeight, fixedHeaderData: E, rowWidth: te, rowHeight: V, width: D, height: Math.min(Z + i(s), U) }, { dynamic: t.header, fixed: t.row })]); }; } });
function KX(e) { return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !un(e); }
const jX = (e, { slots: t }) => { const { mainTableRef: n, ...o } = e; return ee(rv, Ct({ ref: n }, o), KX(t) ? t : { default: () => [t] }); };
function WX(e) { return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !un(e); }
const UX = (e, { slots: t }) => { if (!e.columns.length)
    return; const { leftTableRef: n, ...o } = e; return ee(rv, Ct({ ref: n }, o), WX(t) ? t : { default: () => [t] }); };
function qX(e) { return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !un(e); }
const YX = (e, { slots: t }) => { if (!e.columns.length)
    return; const { rightTableRef: n, ...o } = e; return ee(rv, Ct({ ref: n }, o), qX(t) ? t : { default: () => [t] }); };
function GX(e) { return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !un(e); }
const XX = (e, { slots: t }) => { const { columns: n, columnsStyles: o, depthMap: r, expandColumnKey: s, expandedRowKeys: l, estimatedRowHeight: a, hasFixedColumns: u, hoveringRowKey: c, rowData: d, rowIndex: f, style: p, isScrolling: v, rowProps: m, rowClass: h, rowKey: g, rowEventHandlers: y, ns: C, onRowHovered: b, onRowExpanded: w } = e, T = Ks(h, { columns: n, rowData: d, rowIndex: f }, ""), E = Ks(m, { columns: n, rowData: d, rowIndex: f }), x = d[g], I = r[x] || 0, L = !!s, B = f < 0, F = [C.e("row"), T, { [C.e(`row-depth-${I}`)]: L && f >= 0, [C.is("expanded")]: L && l.includes(x), [C.is("hovered")]: !v && x === c, [C.is("fixed")]: !I && B, [C.is("customized")]: !!t.row }], V = u ? b : void 0, R = { ...E, columns: n, columnsStyles: o, class: F, depth: I, expandColumnKey: s, estimatedRowHeight: B ? void 0 : a, isScrolling: v, rowIndex: f, rowData: d, rowKey: x, rowEventHandlers: y, style: p }; return ee(BX, Ct(R, { onRowHover: V, onRowExpand: w }), GX(t) ? t : { default: () => [t] }); }, np = ({ columns: e, column: t, columnIndex: n, depth: o, expandIconProps: r, isScrolling: s, rowData: l, rowIndex: a, style: u, expandedRowKeys: c, ns: d, cellProps: f, expandColumnKey: p, indentSize: v, iconSize: m, rowKey: h }, { slots: g }) => { const y = Wr(u); if (t.placeholderSign === fi)
    return ee("div", { class: d.em("row-cell", "placeholder"), style: y }, null); const { cellRenderer: C, dataKey: b, dataGetter: w } = t, E = Z2(C) || g.default || (U => ee(nv, U, null)), x = at(w) ? w({ columns: e, column: t, columnIndex: n, rowData: l, rowIndex: a }) : sn(l, b ?? ""), I = Ks(f, { cellData: x, columns: e, column: t, columnIndex: n, rowIndex: a, rowData: l }), L = { class: d.e("cell-text"), columns: e, column: t, columnIndex: n, cellData: x, isScrolling: s, rowData: l, rowIndex: a }, B = E(L), F = [d.e("row-cell"), t.class, t.align === di.CENTER && d.is("align-center"), t.align === di.RIGHT && d.is("align-right")], V = a >= 0 && p && t.key === p, R = a >= 0 && c.includes(l[h]); let K; const te = `margin-inline-start: ${o * v}px;`; return V && (yt(r) ? K = ee(VX, Ct(r, { class: [d.e("expand-icon"), d.is("expanded", R)], size: m, expanded: R, style: te, expandable: !0 }), null) : K = ee("div", { style: [te, `width: ${m}px; height: ${m}px;`].join(" ") }, null)), ee("div", Ct({ class: F, style: y }, I, { role: "cell" }), [K, B]); };
np.inheritAttrs = !1;
function JX(e) { return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !un(e); }
const ZX = ({ columns: e, columnsStyles: t, headerIndex: n, style: o, headerClass: r, headerProps: s, ns: l }, { slots: a }) => { const u = { columns: e, headerIndex: n }, c = [l.e("header-row"), Ks(r, u, ""), { [l.is("customized")]: !!a.header }], d = { ...Ks(s, u), columnsStyles: t, class: c, columns: e, headerIndex: n, style: o }; return ee(NX, d, JX(a) ? a : { default: () => [a] }); }, oy = (e, { slots: t }) => { const { column: n, ns: o, style: r, onColumnSorted: s } = e, l = Wr(r); if (n.placeholderSign === fi)
    return ee("div", { class: o.em("header-row-cell", "placeholder"), style: l }, null); const { headerCellRenderer: a, headerClass: u, sortable: c } = n, d = { ...e, class: o.e("header-cell-text") }, p = (Z2(a) || t.default || (w => ee(ov, w, null)))(d), { sortBy: v, sortState: m, headerCellProps: h } = e; let g, y; if (m) {
    const w = m[n.key];
    g = !!tp[w], y = g ? w : ci.ASC;
}
else
    g = n.key === v.key, y = g ? v.order : ci.ASC; const C = [o.e("header-cell"), Ks(u, e, ""), n.align === di.CENTER && o.is("align-center"), n.align === di.RIGHT && o.is("align-right"), c && o.is("sortable")], b = { ...Ks(h, e), onClick: n.sortable ? s : void 0, class: C, style: l, "data-key": n.key }; return ee("div", Ct(b, { role: "columnheader" }), [p, c && ee(FX, { class: [o.e("sort-icon"), g && o.is("sorting")], sortOrder: y }, null)]); }, nS = (e, { slots: t }) => { var n; return ee("div", { class: e.class, style: e.style }, [(n = t.default) == null ? void 0 : n.call(t)]); };
nS.displayName = "ElTableV2Footer";
const oS = (e, { slots: t }) => ee("div", { class: e.class, style: e.style }, [t.default ? t.default() : ee(c2, null, null)]);
oS.displayName = "ElTableV2Empty";
const rS = (e, { slots: t }) => { var n; return ee("div", { class: e.class, style: e.style }, [(n = t.default) == null ? void 0 : n.call(t)]); };
rS.displayName = "ElTableV2Overlay";
function da(e) { return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !un(e); }
const QX = "ElTableV2", eJ = ae({ name: QX, props: AX, setup(e, { slots: t, expose: n }) { const o = Ie("table-v2"), { columnsStyles: r, fixedColumnsOnLeft: s, fixedColumnsOnRight: l, mainColumns: a, mainTableHeight: u, fixedTableHeight: c, leftTableWidth: d, rightTableWidth: f, data: p, depthMap: v, expandedRowKeys: m, hasFixedColumns: h, hoveringRowKey: g, mainTableRef: y, leftTableRef: C, rightTableRef: b, isDynamic: w, isResetting: T, isScrolling: E, bodyWidth: x, emptyStyle: I, rootStyle: L, headerWidth: B, footerHeight: F, showEmpty: V, scrollTo: R, scrollToLeft: K, scrollToTop: te, scrollToRow: U, getRowHeight: D, onColumnSorted: j, onRowHeightChange: A, onRowHovered: G, onRowExpanded: se, onRowsRendered: Z, onScroll: ce, onVerticalScroll: ye } = IX(e); return n({ scrollTo: R, scrollToLeft: K, scrollToTop: te, scrollToRow: U }), St(Qh, { ns: o, isResetting: T, hoveringRowKey: g, isScrolling: E }), () => { const { cache: Re, cellProps: me, estimatedRowHeight: le, expandColumnKey: oe, fixedData: fe, headerHeight: Ce, headerClass: Ae, headerProps: q, headerCellProps: re, sortBy: he, sortState: Ee, rowHeight: Ne, rowClass: Se, rowEventHandlers: De, rowKey: Me, rowProps: $e, scrollbarAlwaysOn: Pe, indentSize: He, iconSize: je, useIsScrolling: Ue, vScrollbarSize: Te, width: Ge } = e, W = i(p), X = { cache: Re, class: o.e("main"), columns: i(a), data: W, fixedData: fe, estimatedRowHeight: le, bodyWidth: i(x), headerHeight: Ce, headerWidth: i(B), height: i(u), mainTableRef: y, rowKey: Me, rowHeight: Ne, scrollbarAlwaysOn: Pe, scrollbarStartGap: 2, scrollbarEndGap: Te, useIsScrolling: Ue, width: Ge, getRowHeight: D, onRowsRendered: Z, onScroll: ce }, $ = i(d), Y = i(c), H = { cache: Re, class: o.e("left"), columns: i(s), data: W, estimatedRowHeight: le, leftTableRef: C, rowHeight: Ne, bodyWidth: $, headerWidth: $, headerHeight: Ce, height: Y, rowKey: Me, scrollbarAlwaysOn: Pe, scrollbarStartGap: 2, scrollbarEndGap: Te, useIsScrolling: Ue, width: $, getRowHeight: D, onScroll: ye }, de = i(f) + Te, be = { cache: Re, class: o.e("right"), columns: i(l), data: W, estimatedRowHeight: le, rightTableRef: b, rowHeight: Ne, bodyWidth: de, headerWidth: de, headerHeight: Ce, height: Y, rowKey: Me, scrollbarAlwaysOn: Pe, scrollbarStartGap: 2, scrollbarEndGap: Te, width: de, style: `--${i(o.namespace)}-table-scrollbar-size: ${Te}px`, useIsScrolling: Ue, getRowHeight: D, onScroll: ye }, J = i(r), we = { ns: o, depthMap: i(v), columnsStyles: J, expandColumnKey: oe, expandedRowKeys: i(m), estimatedRowHeight: le, hasFixedColumns: i(h), hoveringRowKey: i(g), rowProps: $e, rowClass: Se, rowKey: Me, rowEventHandlers: De, onRowHovered: G, onRowExpanded: se, onRowHeightChange: A }, Ke = { cellProps: me, expandColumnKey: oe, indentSize: He, iconSize: je, rowKey: Me, expandedRowKeys: i(m), ns: o }, rt = { ns: o, headerClass: Ae, headerProps: q, columnsStyles: J }, _e = { ns: o, sortBy: he, sortState: Ee, headerCellProps: re, onColumnSorted: j }, ze = { row: rn => ee(XX, Ct(rn, we), { row: t.row, cell: Rt => { let Le; return t.cell ? ee(np, Ct(Rt, Ke, { style: J[Rt.column.key] }), da(Le = t.cell(Rt)) ? Le : { default: () => [Le] }) : ee(np, Ct(Rt, Ke, { style: J[Rt.column.key] }), null); } }), header: rn => ee(ZX, Ct(rn, rt), { header: t.header, cell: Rt => { let Le; return t["header-cell"] ? ee(oy, Ct(Rt, _e, { style: J[Rt.column.key] }), da(Le = t["header-cell"](Rt)) ? Le : { default: () => [Le] }) : ee(oy, Ct(Rt, _e, { style: J[Rt.column.key] }), null); } }) }, We = [e.class, o.b(), o.e("root"), { [o.is("dynamic")]: i(w) }], ut = { class: o.e("footer"), style: i(F) }; return ee("div", { class: We, style: i(L) }, [ee(jX, X, da(ze) ? ze : { default: () => [ze] }), ee(UX, H, da(ze) ? ze : { default: () => [ze] }), ee(YX, be, da(ze) ? ze : { default: () => [ze] }), t.footer && ee(nS, ut, { default: t.footer }), i(V) && ee(oS, { class: o.e("empty"), style: i(I) }, { default: t.empty }), t.overlay && ee(rS, { class: o.e("overlay") }, { default: t.overlay })]); }; } }), tJ = Ve({ disableWidth: Boolean, disableHeight: Boolean, onResize: { type: ve(Function) } }), nJ = ae({ name: "ElAutoResizer", props: tJ, setup(e, { slots: t }) { const n = Ie("auto-resizer"), { height: o, width: r, sizer: s } = OX(e), l = { width: "100%", height: "100%" }; return () => { var a; return ee("div", { ref: s, class: n.b(), style: l }, [(a = t.default) == null ? void 0 : a.call(t, { height: o.value, width: r.value })]); }; } }), oJ = vt(eJ), rJ = vt(nJ), qc = Symbol("tabsRootContextKey"), sJ = Ve({ tabs: { type: ve(Array), default: () => ln([]) } }), sS = "ElTabBar", lJ = ae({ name: sS }), aJ = ae({ ...lJ, props: sJ, setup(e, { expose: t }) { const n = e, o = ht(), r = Ye(qc); r || _n(sS, "<el-tabs><el-tab-bar /></el-tabs>"); const s = Ie("tabs"), l = M(), a = M(), u = () => { let d = 0, f = 0; const p = ["top", "bottom"].includes(r.props.tabPosition) ? "width" : "height", v = p === "width" ? "x" : "y", m = v === "x" ? "left" : "top"; return n.tabs.every(h => { var g, y; const C = (y = (g = o.parent) == null ? void 0 : g.refs) == null ? void 0 : y[`tab-${h.uid}`]; if (!C)
        return !1; if (!h.active)
        return !0; d = C[`offset${Xo(m)}`], f = C[`client${Xo(p)}`]; const b = window.getComputedStyle(C); return p === "width" && (n.tabs.length > 1 && (f -= Number.parseFloat(b.paddingLeft) + Number.parseFloat(b.paddingRight)), d += Number.parseFloat(b.paddingLeft)), !1; }), { [p]: `${f}px`, transform: `translate${Xo(v)}(${d}px)` }; }, c = () => a.value = u(); return Oe(() => n.tabs, async () => { await Xe(), c(); }, { immediate: !0 }), Vn(l, () => c()), t({ ref: l, update: c }), (d, f) => (k(), z("div", { ref_key: "barRef", ref: l, class: O([i(s).e("active-bar"), i(s).is(i(r).props.tabPosition)]), style: et(a.value) }, null, 6)); } });
var iJ = Fe(aJ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-bar.vue"]]);
const uJ = Ve({ panes: { type: ve(Array), default: () => ln([]) }, currentName: { type: [String, Number], default: "" }, editable: Boolean, type: { type: String, values: ["card", "border-card", ""], default: "" }, stretch: Boolean }), cJ = { tabClick: (e, t, n) => n instanceof Event, tabRemove: (e, t) => t instanceof Event }, ry = "ElTabNav", dJ = ae({ name: ry, props: uJ, emits: cJ, setup(e, { expose: t, emit: n }) { const o = ht(), r = Ye(qc); r || _n(ry, "<el-tabs><tab-nav /></el-tabs>"); const s = Ie("tabs"), l = oT(), a = pT(), u = M(), c = M(), d = M(), f = M(), p = M(!1), v = M(0), m = M(!1), h = M(!0), g = S(() => ["top", "bottom"].includes(r.props.tabPosition) ? "width" : "height"), y = S(() => ({ transform: `translate${g.value === "width" ? "X" : "Y"}(-${v.value}px)` })), C = () => { if (!u.value)
        return; const L = u.value[`offset${Xo(g.value)}`], B = v.value; if (!B)
        return; const F = B > L ? B - L : 0; v.value = F; }, b = () => { if (!u.value || !c.value)
        return; const L = c.value[`offset${Xo(g.value)}`], B = u.value[`offset${Xo(g.value)}`], F = v.value; if (L - F <= B)
        return; const V = L - F > B * 2 ? F + B : L - B; v.value = V; }, w = async () => { const L = c.value; if (!p.value || !d.value || !u.value || !L)
        return; await Xe(); const B = d.value.querySelector(".is-active"); if (!B)
        return; const F = u.value, V = ["top", "bottom"].includes(r.props.tabPosition), R = B.getBoundingClientRect(), K = F.getBoundingClientRect(), te = V ? L.offsetWidth - K.width : L.offsetHeight - K.height, U = v.value; let D = U; V ? (R.left < K.left && (D = U - (K.left - R.left)), R.right > K.right && (D = U + R.right - K.right)) : (R.top < K.top && (D = U - (K.top - R.top)), R.bottom > K.bottom && (D = U + (R.bottom - K.bottom))), D = Math.max(D, 0), v.value = Math.min(D, te); }, T = () => { var L; if (!c.value || !u.value)
        return; e.stretch && ((L = f.value) == null || L.update()); const B = c.value[`offset${Xo(g.value)}`], F = u.value[`offset${Xo(g.value)}`], V = v.value; F < B ? (p.value = p.value || {}, p.value.prev = V, p.value.next = V + F < B, B - V < F && (v.value = B - F)) : (p.value = !1, V > 0 && (v.value = 0)); }, E = L => { const B = L.code, { up: F, down: V, left: R, right: K } = tt; if (![F, V, R, K].includes(B))
        return; const te = Array.from(L.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)")), U = te.indexOf(L.target); let D; B === R || B === F ? U === 0 ? D = te.length - 1 : D = U - 1 : U < te.length - 1 ? D = U + 1 : D = 0, te[D].focus({ preventScroll: !0 }), te[D].click(), x(); }, x = () => { h.value && (m.value = !0); }, I = () => m.value = !1; return Oe(l, L => { L === "hidden" ? h.value = !1 : L === "visible" && setTimeout(() => h.value = !0, 50); }), Oe(a, L => { L ? setTimeout(() => h.value = !0, 50) : h.value = !1; }), Vn(d, T), ft(() => setTimeout(() => w(), 0)), Er(() => T()), t({ scrollToActiveTab: w, removeFocus: I }), Oe(() => e.panes, () => o.update(), { flush: "post", deep: !0 }), () => { const L = p.value ? [ee("span", { class: [s.e("nav-prev"), s.is("disabled", !p.value.prev)], onClick: C }, [ee(Je, null, { default: () => [ee(Zr, null, null)] })]), ee("span", { class: [s.e("nav-next"), s.is("disabled", !p.value.next)], onClick: b }, [ee(Je, null, { default: () => [ee(Un, null, null)] })])] : null, B = e.panes.map((F, V) => { var R, K, te, U; const D = F.uid, j = F.props.disabled, A = (K = (R = F.props.name) != null ? R : F.index) != null ? K : `${V}`, G = !j && (F.isClosable || e.editable); F.index = `${V}`; const se = G ? ee(Je, { class: "is-icon-close", onClick: ye => n("tabRemove", F, ye) }, { default: () => [ee(Ho, null, null)] }) : null, Z = ((U = (te = F.slots).label) == null ? void 0 : U.call(te)) || F.props.label, ce = !j && F.active ? 0 : -1; return ee("div", { ref: `tab-${D}`, class: [s.e("item"), s.is(r.props.tabPosition), s.is("active", F.active), s.is("disabled", j), s.is("closable", G), s.is("focus", m.value)], id: `tab-${A}`, key: `tab-${D}`, "aria-controls": `pane-${A}`, role: "tab", "aria-selected": F.active, tabindex: ce, onFocus: () => x(), onBlur: () => I(), onClick: ye => { I(), n("tabClick", F, A, ye); }, onKeydown: ye => { G && (ye.code === tt.delete || ye.code === tt.backspace) && n("tabRemove", F, ye); } }, [Z, se]); }); return ee("div", { ref: d, class: [s.e("nav-wrap"), s.is("scrollable", !!p.value), s.is(r.props.tabPosition)] }, [L, ee("div", { class: s.e("nav-scroll"), ref: u }, [ee("div", { class: [s.e("nav"), s.is(r.props.tabPosition), s.is("stretch", e.stretch && ["top", "bottom"].includes(r.props.tabPosition))], ref: c, style: y.value, role: "tablist", onKeydown: E }, [e.type ? null : ee(iJ, { ref: f, tabs: [...e.panes] }, null), B])])]); }; } }), fJ = Ve({ type: { type: String, values: ["card", "border-card", ""], default: "" }, activeName: { type: [String, Number] }, closable: Boolean, addable: Boolean, modelValue: { type: [String, Number] }, editable: Boolean, tabPosition: { type: String, values: ["top", "right", "bottom", "left"], default: "top" }, beforeLeave: { type: ve(Function), default: () => !0 }, stretch: Boolean }), Vd = e => it(e) || lt(e), pJ = { [gt]: e => Vd(e), tabClick: (e, t) => t instanceof Event, tabChange: e => Vd(e), edit: (e, t) => ["remove", "add"].includes(t), tabRemove: e => Vd(e), tabAdd: () => !0 };
var hJ = ae({ name: "ElTabs", props: fJ, emits: pJ, setup(e, { emit: t, slots: n, expose: o }) { var r, s; const l = Ie("tabs"), { children: a, addChild: u, removeChild: c } = $h(ht(), "ElTabPane"), d = M(), f = M((s = (r = e.modelValue) != null ? r : e.activeName) != null ? s : "0"), p = y => { f.value = y, t(gt, y), t("tabChange", y); }, v = async (y) => { var C, b, w; if (!(f.value === y || En(y)))
        try {
            await ((C = e.beforeLeave) == null ? void 0 : C.call(e, y, f.value)) !== !1 && (p(y), (w = (b = d.value) == null ? void 0 : b.removeFocus) == null || w.call(b));
        }
        catch { } }, m = (y, C, b) => { y.props.disabled || (v(C), t("tabClick", y, b)); }, h = (y, C) => { y.props.disabled || En(y.props.name) || (C.stopPropagation(), t("edit", y.props.name, "remove"), t("tabRemove", y.props.name)); }, g = () => { t("edit", void 0, "add"), t("tabAdd"); }; return tr({ from: '"activeName"', replacement: '"model-value" or "v-model"', scope: "ElTabs", version: "2.3.0", ref: "https://element-plus.org/en-US/component/tabs.html#attributes", type: "Attribute" }, S(() => !!e.activeName)), Oe(() => e.activeName, y => v(y)), Oe(() => e.modelValue, y => v(y)), Oe(f, async () => { var y; await Xe(), (y = d.value) == null || y.scrollToActiveTab(); }), St(qc, { props: e, currentName: f, registerPane: u, unregisterPane: c }), o({ currentName: f }), () => { const y = e.editable || e.addable ? ee("span", { class: l.e("new-tab"), tabindex: "0", onClick: g, onKeydown: w => { w.code === tt.enter && g(); } }, [ee(Je, { class: l.is("icon-plus") }, { default: () => [ee(N1, null, null)] })]) : null, C = ee("div", { class: [l.e("header"), l.is(e.tabPosition)] }, [y, ee(dJ, { ref: d, currentName: f.value, editable: e.editable, type: e.type, panes: a.value, stretch: e.stretch, onTabClick: m, onTabRemove: h }, null)]), b = ee("div", { class: l.e("content") }, [ke(n, "default")]); return ee("div", { class: [l.b(), l.m(e.tabPosition), { [l.m("card")]: e.type === "card", [l.m("border-card")]: e.type === "border-card" }] }, [...e.tabPosition !== "bottom" ? [C, b] : [b, C]]); }; } });
const vJ = Ve({ label: { type: String, default: "" }, name: { type: [String, Number] }, closable: Boolean, disabled: Boolean, lazy: Boolean }), mJ = ["id", "aria-hidden", "aria-labelledby"], lS = "ElTabPane", gJ = ae({ name: lS }), yJ = ae({ ...gJ, props: vJ, setup(e) { const t = e, n = ht(), o = An(), r = Ye(qc); r || _n(lS, "usage: <el-tabs><el-tab-pane /></el-tabs/>"); const s = Ie("tab-pane"), l = M(), a = S(() => t.closable || r.props.closable), u = Rm(() => { var v; return r.currentName.value === ((v = t.name) != null ? v : l.value); }), c = M(u.value), d = S(() => { var v; return (v = t.name) != null ? v : l.value; }), f = Rm(() => !t.lazy || c.value || u.value); Oe(u, v => { v && (c.value = !0); }); const p = Lt({ uid: n.uid, slots: o, props: t, paneName: d, active: u, index: l, isClosable: a }); return ft(() => { r.registerPane(p); }), rs(() => { r.unregisterPane(p.uid); }), (v, m) => i(f) ? dt((k(), z("div", { key: 0, id: `pane-${i(d)}`, class: O(i(s).b()), role: "tabpanel", "aria-hidden": !i(u), "aria-labelledby": `tab-${i(d)}` }, [ke(v.$slots, "default")], 10, mJ)), [[Pt, i(u)]]) : pe("v-if", !0); } });
var aS = Fe(yJ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-pane.vue"]]);
const bJ = vt(hJ, { TabPane: aS }), wJ = pn(aS), CJ = Ve({ type: { type: String, values: ["primary", "success", "info", "warning", "danger", ""], default: "" }, size: { type: String, values: sr, default: "" }, truncated: { type: Boolean }, tag: { type: String, default: "span" } }), SJ = ae({ name: "ElText" }), _J = ae({ ...SJ, props: CJ, setup(e) { const t = e, n = kn(), o = Ie("text"), r = S(() => [o.b(), o.m(t.type), o.m(n.value), o.is("truncated", t.truncated)]); return (s, l) => (k(), ge(kt(s.tag), { class: O(i(r)) }, { default: ie(() => [ke(s.$slots, "default")]), _: 3 }, 8, ["class"])); } });
var kJ = Fe(_J, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/text/src/text.vue"]]);
const EJ = vt(kJ), $J = Ve({ format: { type: String, default: "HH:mm" }, modelValue: String, disabled: Boolean, editable: { type: Boolean, default: !0 }, effect: { type: String, default: "light" }, clearable: { type: Boolean, default: !0 }, size: Bn, placeholder: String, start: { type: String, default: "09:00" }, end: { type: String, default: "18:00" }, step: { type: String, default: "00:30" }, minTime: String, maxTime: String, name: String, prefixIcon: { type: ve([String, Object]), default: () => M1 }, clearIcon: { type: ve([String, Object]), default: () => ls } }), mr = e => { const t = (e || "").split(":"); if (t.length >= 2) {
    let n = Number.parseInt(t[0], 10);
    const o = Number.parseInt(t[1], 10), r = e.toUpperCase();
    return r.includes("AM") && n === 12 ? n = 0 : r.includes("PM") && n !== 12 && (n += 12), { hours: n, minutes: o };
} return null; }, zd = (e, t) => { const n = mr(e); if (!n)
    return -1; const o = mr(t); if (!o)
    return -1; const r = n.minutes + n.hours * 60, s = o.minutes + o.hours * 60; return r === s ? 0 : r > s ? 1 : -1; }, sy = e => `${e}`.padStart(2, "0"), sl = e => `${sy(e.hours)}:${sy(e.minutes)}`, TJ = (e, t) => { const n = mr(e); if (!n)
    return ""; const o = mr(t); if (!o)
    return ""; const r = { hours: n.hours, minutes: n.minutes }; return r.minutes += o.minutes, r.hours += o.hours, r.hours += Math.floor(r.minutes / 60), r.minutes = r.minutes % 60, sl(r); }, OJ = ae({ name: "ElTimeSelect" }), IJ = ae({ ...OJ, props: $J, emits: ["change", "blur", "focus", "update:modelValue"], setup(e, { expose: t }) { const n = e; pt.extend(Mh); const { Option: o } = Hs, r = Ie("input"), s = M(), l = uo(), a = S(() => n.modelValue), u = S(() => { const g = mr(n.start); return g ? sl(g) : null; }), c = S(() => { const g = mr(n.end); return g ? sl(g) : null; }), d = S(() => { const g = mr(n.step); return g ? sl(g) : null; }), f = S(() => { const g = mr(n.minTime || ""); return g ? sl(g) : null; }), p = S(() => { const g = mr(n.maxTime || ""); return g ? sl(g) : null; }), v = S(() => { const g = []; if (n.start && n.end && n.step) {
        let y = u.value, C;
        for (; y && c.value && zd(y, c.value) <= 0;)
            C = pt(y, "HH:mm").format(n.format), g.push({ value: C, disabled: zd(y, f.value || "-1:-1") <= 0 || zd(y, p.value || "100:100") >= 0 }), y = TJ(y, d.value);
    } return g; }); return t({ blur: () => { var g, y; (y = (g = s.value) == null ? void 0 : g.blur) == null || y.call(g); }, focus: () => { var g, y; (y = (g = s.value) == null ? void 0 : g.focus) == null || y.call(g); } }), (g, y) => (k(), ge(i(Hs), { ref_key: "select", ref: s, "model-value": i(a), disabled: i(l), clearable: g.clearable, "clear-icon": g.clearIcon, size: g.size, effect: g.effect, placeholder: g.placeholder, "default-first-option": "", filterable: g.editable, "onUpdate:modelValue": y[0] || (y[0] = C => g.$emit("update:modelValue", C)), onChange: y[1] || (y[1] = C => g.$emit("change", C)), onBlur: y[2] || (y[2] = C => g.$emit("blur", C)), onFocus: y[3] || (y[3] = C => g.$emit("focus", C)) }, { prefix: ie(() => [g.prefixIcon ? (k(), ge(i(Je), { key: 0, class: O(i(r).e("prefix-icon")) }, { default: ie(() => [(k(), ge(kt(g.prefixIcon)))]), _: 1 }, 8, ["class"])) : pe("v-if", !0)]), default: ie(() => [(k(!0), z(Qe, null, Et(i(v), C => (k(), ge(i(o), { key: C.value, label: C.value, value: C.value, disabled: C.disabled }, null, 8, ["label", "value", "disabled"]))), 128))]), _: 1 }, 8, ["model-value", "disabled", "clearable", "clear-icon", "size", "effect", "placeholder", "filterable"])); } });
var Tu = Fe(IJ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-select/src/time-select.vue"]]);
Tu.install = e => { e.component(Tu.name, Tu); };
const xJ = Tu, AJ = xJ, MJ = ae({ name: "ElTimeline", setup(e, { slots: t }) { const n = Ie("timeline"); return St("timeline", t), () => nt("ul", { class: [n.b()] }, [ke(t, "default")]); } }), NJ = Ve({ timestamp: { type: String, default: "" }, hideTimestamp: { type: Boolean, default: !1 }, center: { type: Boolean, default: !1 }, placement: { type: String, values: ["top", "bottom"], default: "bottom" }, type: { type: String, values: ["primary", "success", "warning", "danger", "info"], default: "" }, color: { type: String, default: "" }, size: { type: String, values: ["normal", "large"], default: "normal" }, icon: { type: Zt }, hollow: { type: Boolean, default: !1 } }), PJ = ae({ name: "ElTimelineItem" }), RJ = ae({ ...PJ, props: NJ, setup(e) { const t = e, n = Ie("timeline-item"), o = S(() => [n.e("node"), n.em("node", t.size || ""), n.em("node", t.type || ""), n.is("hollow", t.hollow)]); return (r, s) => (k(), z("li", { class: O([i(n).b(), { [i(n).e("center")]: r.center }]) }, [Q("div", { class: O(i(n).e("tail")) }, null, 2), r.$slots.dot ? pe("v-if", !0) : (k(), z("div", { key: 0, class: O(i(o)), style: et({ backgroundColor: r.color }) }, [r.icon ? (k(), ge(i(Je), { key: 0, class: O(i(n).e("icon")) }, { default: ie(() => [(k(), ge(kt(r.icon)))]), _: 1 }, 8, ["class"])) : pe("v-if", !0)], 6)), r.$slots.dot ? (k(), z("div", { key: 1, class: O(i(n).e("dot")) }, [ke(r.$slots, "dot")], 2)) : pe("v-if", !0), Q("div", { class: O(i(n).e("wrapper")) }, [!r.hideTimestamp && r.placement === "top" ? (k(), z("div", { key: 0, class: O([i(n).e("timestamp"), i(n).is("top")]) }, Be(r.timestamp), 3)) : pe("v-if", !0), Q("div", { class: O(i(n).e("content")) }, [ke(r.$slots, "default")], 2), !r.hideTimestamp && r.placement === "bottom" ? (k(), z("div", { key: 1, class: O([i(n).e("timestamp"), i(n).is("bottom")]) }, Be(r.timestamp), 3)) : pe("v-if", !0)], 2)], 2)); } });
var iS = Fe(RJ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/timeline/src/timeline-item.vue"]]);
const LJ = vt(MJ, { TimelineItem: iS }), DJ = pn(iS), uS = Ve({ nowrap: Boolean });
var cS = (e => (e.top = "top", e.bottom = "bottom", e.left = "left", e.right = "right", e))(cS || {});
const BJ = Object.values(cS), sv = Ve({ width: { type: Number, default: 10 }, height: { type: Number, default: 10 }, style: { type: ve(Object), default: null } }), FJ = Ve({ side: { type: ve(String), values: BJ, required: !0 } }), VJ = ["absolute", "fixed"], zJ = ["top-start", "top-end", "top", "bottom-start", "bottom-end", "bottom", "left-start", "left-end", "left", "right-start", "right-end", "right"], lv = Ve({ ariaLabel: String, arrowPadding: { type: ve(Number), default: 5 }, effect: { type: String, default: "" }, contentClass: String, placement: { type: ve(String), values: zJ, default: "bottom" }, reference: { type: ve(Object), default: null }, offset: { type: Number, default: 8 }, strategy: { type: ve(String), values: VJ, default: "absolute" }, showArrow: { type: Boolean, default: !1 } }), av = Ve({ delayDuration: { type: Number, default: 300 }, defaultOpen: Boolean, open: { type: Boolean, default: void 0 }, onOpenChange: { type: ve(Function) }, "onUpdate:open": { type: ve(Function) } }), tl = { type: ve(Function) }, iv = Ve({ onBlur: tl, onClick: tl, onFocus: tl, onMouseDown: tl, onMouseEnter: tl, onMouseLeave: tl }), HJ = Ve({ ...av, ...sv, ...iv, ...lv, alwaysOn: Boolean, fullTransition: Boolean, transitionProps: { type: ve(Object), default: null }, teleported: Boolean, to: { type: ve(String), default: "body" } }), Yc = Symbol("tooltipV2"), dS = Symbol("tooltipV2Content"), Hd = "tooltip_v2.open", KJ = ae({ name: "ElTooltipV2Root" }), jJ = ae({ ...KJ, props: av, setup(e, { expose: t }) { const n = e, o = M(n.defaultOpen), r = M(null), s = S({ get: () => wM(n.open) ? o.value : n.open, set: g => { var y; o.value = g, (y = n["onUpdate:open"]) == null || y.call(n, g); } }), l = S(() => lt(n.delayDuration) && n.delayDuration > 0), { start: a, stop: u } = Vs(() => { s.value = !0; }, S(() => n.delayDuration), { immediate: !1 }), c = Ie("tooltip-v2"), d = xo(), f = () => { u(), s.value = !0; }, p = () => { i(l) ? a() : f(); }, v = f, m = () => { u(), s.value = !1; }; return Oe(s, g => { var y; g && (document.dispatchEvent(new CustomEvent(Hd)), v()), (y = n.onOpenChange) == null || y.call(n, g); }), ft(() => { document.addEventListener(Hd, m); }), on(() => { u(), document.removeEventListener(Hd, m); }), St(Yc, { contentId: d, triggerRef: r, ns: c, onClose: m, onDelayOpen: p, onOpen: v }), t({ onOpen: v, onClose: m }), (g, y) => ke(g.$slots, "default", { open: i(s) }); } });
var WJ = Fe(jJ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/root.vue"]]);
const UJ = ae({ name: "ElTooltipV2Arrow" }), qJ = ae({ ...UJ, props: { ...sv, ...FJ }, setup(e) { const t = e, { ns: n } = Ye(Yc), { arrowRef: o } = Ye(dS), r = S(() => { const { style: s, width: l, height: a } = t, u = n.namespace.value; return { [`--${u}-tooltip-v2-arrow-width`]: `${l}px`, [`--${u}-tooltip-v2-arrow-height`]: `${a}px`, [`--${u}-tooltip-v2-arrow-border-width`]: `${l / 2}px`, [`--${u}-tooltip-v2-arrow-cover-width`]: l / 2 - 1, ...s || {} }; }); return (s, l) => (k(), z("span", { ref_key: "arrowRef", ref: o, style: et(i(r)), class: O(i(n).e("arrow")) }, null, 6)); } });
var ly = Fe(qJ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/arrow.vue"]]);
const YJ = Ve({ style: { type: ve([String, Object, Array]), default: () => ({}) } }), GJ = ae({ name: "ElVisuallyHidden" }), XJ = ae({ ...GJ, props: YJ, setup(e) { const t = e, n = S(() => [t.style, { position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal" }]); return (o, r) => (k(), z("span", Ct(o.$attrs, { style: i(n) }), [ke(o.$slots, "default")], 16)); } });
var JJ = Fe(XJ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/visual-hidden/src/visual-hidden.vue"]]);
const ZJ = ["data-side"], QJ = ae({ name: "ElTooltipV2Content" }), eZ = ae({ ...QJ, props: { ...lv, ...uS }, setup(e) { const t = e, { triggerRef: n, contentId: o } = Ye(Yc), r = M(t.placement), s = M(t.strategy), l = M(null), { referenceRef: a, contentRef: u, middlewareData: c, x: d, y: f, update: p } = R6({ placement: r, strategy: s, middleware: S(() => { const b = [O6(t.offset)]; return t.showArrow && b.push(L6({ arrowRef: l })), b; }) }), v = Gl().nextZIndex(), m = Ie("tooltip-v2"), h = S(() => r.value.split("-")[0]), g = S(() => ({ position: i(s), top: `${i(f) || 0}px`, left: `${i(d) || 0}px`, zIndex: v })), y = S(() => { if (!t.showArrow)
        return {}; const { arrow: b } = i(c); return { [`--${m.namespace.value}-tooltip-v2-arrow-x`]: `${b == null ? void 0 : b.x}px` || "", [`--${m.namespace.value}-tooltip-v2-arrow-y`]: `${b == null ? void 0 : b.y}px` || "" }; }), C = S(() => [m.e("content"), m.is("dark", t.effect === "dark"), m.is(i(s)), t.contentClass]); return Oe(l, () => p()), Oe(() => t.placement, b => r.value = b), ft(() => { Oe(() => t.reference || n.value, b => { a.value = b || void 0; }, { immediate: !0 }); }), St(dS, { arrowRef: l }), (b, w) => (k(), z("div", { ref_key: "contentRef", ref: u, style: et(i(g)), "data-tooltip-v2-root": "" }, [b.nowrap ? pe("v-if", !0) : (k(), z("div", { key: 0, "data-side": i(h), class: O(i(C)) }, [ke(b.$slots, "default", { contentStyle: i(g), contentClass: i(C) }), ee(i(JJ), { id: i(o), role: "tooltip" }, { default: ie(() => [b.ariaLabel ? (k(), z(Qe, { key: 0 }, [Ot(Be(b.ariaLabel), 1)], 64)) : ke(b.$slots, "default", { key: 1 })]), _: 3 }, 8, ["id"]), ke(b.$slots, "arrow", { style: et(i(y)), side: i(h) })], 10, ZJ))], 4)); } });
var ay = Fe(eZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/content.vue"]]);
const tZ = Ve({ setRef: { type: ve(Function), required: !0 }, onlyChild: Boolean });
var nZ = ae({ props: tZ, setup(e, { slots: t }) { const n = M(), o = Ac(n, r => { r ? e.setRef(r.nextElementSibling) : e.setRef(null); }); return () => { var r; const [s] = ((r = t.default) == null ? void 0 : r.call(t)) || [], l = e.onlyChild ? e8(s.children) : s.children; return ee(Qe, { ref: o }, [l]); }; } });
const oZ = ae({ name: "ElTooltipV2Trigger" }), rZ = ae({ ...oZ, props: { ...uS, ...iv }, setup(e) { const t = e, { onClose: n, onOpen: o, onDelayOpen: r, triggerRef: s, contentId: l } = Ye(Yc); let a = !1; const u = C => { s.value = C; }, c = () => { a = !1; }, d = fn(t.onMouseEnter, r), f = fn(t.onMouseLeave, n), p = fn(t.onMouseDown, () => { n(), a = !0, document.addEventListener("mouseup", c, { once: !0 }); }), v = fn(t.onFocus, () => { a || o(); }), m = fn(t.onBlur, n), h = fn(t.onClick, C => { C.detail === 0 && n(); }), g = { blur: m, click: h, focus: v, mousedown: p, mouseenter: d, mouseleave: f }, y = (C, b, w) => { C && Object.entries(b).forEach(([T, E]) => { C[w](T, E); }); }; return Oe(s, (C, b) => { y(C, g, "addEventListener"), y(b, g, "removeEventListener"), C && C.setAttribute("aria-describedby", l.value); }), on(() => { y(s.value, g, "removeEventListener"), document.removeEventListener("mouseup", c); }), (C, b) => C.nowrap ? (k(), ge(i(nZ), { key: 0, "set-ref": u, "only-child": "" }, { default: ie(() => [ke(C.$slots, "default")]), _: 3 })) : (k(), z("button", Ct({ key: 1, ref_key: "triggerRef", ref: s }, C.$attrs), [ke(C.$slots, "default")], 16)); } });
var sZ = Fe(rZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/trigger.vue"]]);
const lZ = ae({ name: "ElTooltipV2" }), aZ = ae({ ...lZ, props: HJ, setup(e) { const n = Sn(e), o = Lt(gr(n, Object.keys(sv))), r = Lt(gr(n, Object.keys(lv))), s = Lt(gr(n, Object.keys(av))), l = Lt(gr(n, Object.keys(iv))); return (a, u) => (k(), ge(WJ, Lo(yc(s)), { default: ie(({ open: c }) => [ee(sZ, Ct(l, { nowrap: "" }), { default: ie(() => [ke(a.$slots, "trigger")]), _: 3 }, 16), (k(), ge(mi, { to: a.to, disabled: !a.teleported }, [a.fullTransition ? (k(), ge(yn, Lo(Ct({ key: 0 }, a.transitionProps)), { default: ie(() => [a.alwaysOn || c ? (k(), ge(ay, Lo(Ct({ key: 0 }, r)), { arrow: ie(({ style: d, side: f }) => [a.showArrow ? (k(), ge(ly, Ct({ key: 0 }, o, { style: d, side: f }), null, 16, ["style", "side"])) : pe("v-if", !0)]), default: ie(() => [ke(a.$slots, "default")]), _: 3 }, 16)) : pe("v-if", !0)]), _: 2 }, 1040)) : (k(), z(Qe, { key: 1 }, [a.alwaysOn || c ? (k(), ge(ay, Lo(Ct({ key: 0 }, r)), { arrow: ie(({ style: d, side: f }) => [a.showArrow ? (k(), ge(ly, Ct({ key: 0 }, o, { style: d, side: f }), null, 16, ["style", "side"])) : pe("v-if", !0)]), default: ie(() => [ke(a.$slots, "default")]), _: 3 }, 16)) : pe("v-if", !0)], 64))], 8, ["to", "disabled"]))]), _: 3 }, 16)); } });
var iZ = Fe(aZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/tooltip.vue"]]);
const uZ = vt(iZ), fS = "left-check-change", pS = "right-check-change", ll = Ve({ data: { type: ve(Array), default: () => [] }, titles: { type: ve(Array), default: () => [] }, buttonTexts: { type: ve(Array), default: () => [] }, filterPlaceholder: String, filterMethod: { type: ve(Function) }, leftDefaultChecked: { type: ve(Array), default: () => [] }, rightDefaultChecked: { type: ve(Array), default: () => [] }, renderContent: { type: ve(Function) }, modelValue: { type: ve(Array), default: () => [] }, format: { type: ve(Object), default: () => ({}) }, filterable: Boolean, props: { type: ve(Object), default: () => ln({ label: "label", key: "key", disabled: "disabled" }) }, targetOrder: { type: String, values: ["original", "push", "unshift"], default: "original" }, validateEvent: { type: Boolean, default: !0 } }), op = (e, t) => [e, t].every(qe) || qe(e) && bn(t), cZ = { [en]: (e, t, n) => [e, n].every(qe) && ["left", "right"].includes(t), [gt]: e => qe(e), [fS]: op, [pS]: op }, rp = "checked-change", dZ = Ve({ data: ll.data, optionRender: { type: ve(Function) }, placeholder: String, title: String, filterable: Boolean, format: ll.format, filterMethod: ll.filterMethod, defaultChecked: ll.leftDefaultChecked, props: ll.props }), fZ = { [rp]: op }, Ii = e => { const t = { label: "label", key: "key", disabled: "disabled" }; return S(() => ({ ...t, ...e.props })); }, pZ = (e, t, n) => { const o = Ii(e), r = S(() => e.data.filter(d => at(e.filterMethod) ? e.filterMethod(t.query, d) : String(d[o.value.label] || d[o.value.key]).toLowerCase().includes(t.query.toLowerCase()))), s = S(() => r.value.filter(d => !d[o.value.disabled])), l = S(() => { const d = t.checked.length, f = e.data.length, { noChecked: p, hasChecked: v } = e.format; return p && v ? d > 0 ? v.replace(/\${checked}/g, d.toString()).replace(/\${total}/g, f.toString()) : p.replace(/\${total}/g, f.toString()) : `${d}/${f}`; }), a = S(() => { const d = t.checked.length; return d > 0 && d < s.value.length; }), u = () => { const d = s.value.map(f => f[o.value.key]); t.allChecked = d.length > 0 && d.every(f => t.checked.includes(f)); }, c = d => { t.checked = d ? s.value.map(f => f[o.value.key]) : []; }; return Oe(() => t.checked, (d, f) => { if (u(), t.checkChangeByUser) {
    const p = d.concat(f).filter(v => !d.includes(v) || !f.includes(v));
    n(rp, d, p);
}
else
    n(rp, d), t.checkChangeByUser = !0; }), Oe(s, () => { u(); }), Oe(() => e.data, () => { const d = [], f = r.value.map(p => p[o.value.key]); t.checked.forEach(p => { f.includes(p) && d.push(p); }), t.checkChangeByUser = !1, t.checked = d; }), Oe(() => e.defaultChecked, (d, f) => { if (f && d.length === f.length && d.every(m => f.includes(m)))
    return; const p = [], v = s.value.map(m => m[o.value.key]); d.forEach(m => { v.includes(m) && p.push(m); }), t.checkChangeByUser = !1, t.checked = p; }, { immediate: !0 }), { filteredData: r, checkableData: s, checkedSummary: l, isIndeterminate: a, updateAllChecked: u, handleAllCheckedChange: c }; }, hZ = (e, t) => ({ onSourceCheckedChange: (r, s) => { e.leftChecked = r, s && t(fS, r, s); }, onTargetCheckedChange: (r, s) => { e.rightChecked = r, s && t(pS, r, s); } }), vZ = e => { const t = Ii(e), n = S(() => e.data.reduce((s, l) => (s[l[t.value.key]] = l) && s, {})), o = S(() => e.data.filter(s => !e.modelValue.includes(s[t.value.key]))), r = S(() => e.targetOrder === "original" ? e.data.filter(s => e.modelValue.includes(s[t.value.key])) : e.modelValue.reduce((s, l) => { const a = n.value[l]; return a && s.push(a), s; }, [])); return { sourceData: o, targetData: r }; }, mZ = (e, t, n) => { const o = Ii(e), r = (a, u, c) => { n(gt, a), n(en, a, u, c); }; return { addToLeft: () => { const a = e.modelValue.slice(); t.rightChecked.forEach(u => { const c = a.indexOf(u); c > -1 && a.splice(c, 1); }), r(a, "left", t.rightChecked); }, addToRight: () => { let a = e.modelValue.slice(); const u = e.data.filter(c => { const d = c[o.value.key]; return t.leftChecked.includes(d) && !e.modelValue.includes(d); }).map(c => c[o.value.key]); a = e.targetOrder === "unshift" ? u.concat(a) : a.concat(u), e.targetOrder === "original" && (a = e.data.filter(c => a.includes(c[o.value.key])).map(c => c[o.value.key])), r(a, "right", t.leftChecked); } }; }, gZ = ae({ name: "ElTransferPanel" }), yZ = ae({ ...gZ, props: dZ, emits: fZ, setup(e, { expose: t, emit: n }) { const o = e, r = An(), s = ({ option: b }) => b, { t: l } = Nt(), a = Ie("transfer"), u = Lt({ checked: [], allChecked: !1, query: "", checkChangeByUser: !0 }), c = Ii(o), { filteredData: d, checkedSummary: f, isIndeterminate: p, handleAllCheckedChange: v } = pZ(o, u, n), m = S(() => !wo(u.query) && wo(d.value)), h = S(() => !wo(r.default()[0].children)), { checked: g, allChecked: y, query: C } = Sn(u); return t({ query: C }), (b, w) => (k(), z("div", { class: O(i(a).b("panel")) }, [Q("p", { class: O(i(a).be("panel", "header")) }, [ee(i(Ao), { modelValue: i(y), "onUpdate:modelValue": w[0] || (w[0] = T => Jt(y) ? y.value = T : null), indeterminate: i(p), "validate-event": !1, onChange: i(v) }, { default: ie(() => [Ot(Be(b.title) + " ", 1), Q("span", null, Be(i(f)), 1)]), _: 1 }, 8, ["modelValue", "indeterminate", "onChange"])], 2), Q("div", { class: O([i(a).be("panel", "body"), i(a).is("with-footer", i(h))]) }, [b.filterable ? (k(), ge(i(Ln), { key: 0, modelValue: i(C), "onUpdate:modelValue": w[1] || (w[1] = T => Jt(C) ? C.value = T : null), class: O(i(a).be("panel", "filter")), size: "default", placeholder: b.placeholder, "prefix-icon": i(GP), clearable: "", "validate-event": !1 }, null, 8, ["modelValue", "class", "placeholder", "prefix-icon"])) : pe("v-if", !0), dt(ee(i(wC), { modelValue: i(g), "onUpdate:modelValue": w[2] || (w[2] = T => Jt(g) ? g.value = T : null), "validate-event": !1, class: O([i(a).is("filterable", b.filterable), i(a).be("panel", "list")]) }, { default: ie(() => [(k(!0), z(Qe, null, Et(i(d), T => (k(), ge(i(Ao), { key: T[i(c).key], class: O(i(a).be("panel", "item")), label: T[i(c).key], disabled: T[i(c).disabled], "validate-event": !1 }, { default: ie(() => { var E; return [ee(s, { option: (E = b.optionRender) == null ? void 0 : E.call(b, T) }, null, 8, ["option"])]; }), _: 2 }, 1032, ["class", "label", "disabled"]))), 128))]), _: 1 }, 8, ["modelValue", "class"]), [[Pt, !i(m) && !i(wo)(b.data)]]), dt(Q("p", { class: O(i(a).be("panel", "empty")) }, Be(i(m) ? i(l)("el.transfer.noMatch") : i(l)("el.transfer.noData")), 3), [[Pt, i(m) || i(wo)(b.data)]])], 2), i(h) ? (k(), z("p", { key: 0, class: O(i(a).be("panel", "footer")) }, [ke(b.$slots, "default")], 2)) : pe("v-if", !0)], 2)); } });
var iy = Fe(yZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/transfer/src/transfer-panel.vue"]]);
const bZ = { key: 0 }, wZ = { key: 0 }, CZ = ae({ name: "ElTransfer" }), SZ = ae({ ...CZ, props: ll, emits: cZ, setup(e, { expose: t, emit: n }) { const o = e, r = An(), { t: s } = Nt(), l = Ie("transfer"), { formItem: a } = Zn(), u = Lt({ leftChecked: [], rightChecked: [] }), c = Ii(o), { sourceData: d, targetData: f } = vZ(o), { onSourceCheckedChange: p, onTargetCheckedChange: v } = hZ(u, n), { addToLeft: m, addToRight: h } = mZ(o, u, n), g = M(), y = M(), C = I => { switch (I) {
        case "left":
            g.value.query = "";
            break;
        case "right":
            y.value.query = "";
            break;
    } }, b = S(() => o.buttonTexts.length === 2), w = S(() => o.titles[0] || s("el.transfer.titles.0")), T = S(() => o.titles[1] || s("el.transfer.titles.1")), E = S(() => o.filterPlaceholder || s("el.transfer.filterPlaceholder")); Oe(() => o.modelValue, () => { var I; o.validateEvent && ((I = a == null ? void 0 : a.validate) == null || I.call(a, "change").catch(L => void 0)); }); const x = S(() => I => o.renderContent ? o.renderContent(nt, I) : r.default ? r.default({ option: I }) : nt("span", I[c.value.label] || I[c.value.key])); return t({ clearQuery: C, leftPanel: g, rightPanel: y }), (I, L) => (k(), z("div", { class: O(i(l).b()) }, [ee(iy, { ref_key: "leftPanel", ref: g, data: i(d), "option-render": i(x), placeholder: i(E), title: i(w), filterable: I.filterable, format: I.format, "filter-method": I.filterMethod, "default-checked": I.leftDefaultChecked, props: o.props, onCheckedChange: i(p) }, { default: ie(() => [ke(I.$slots, "left-footer")]), _: 3 }, 8, ["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]), Q("div", { class: O(i(l).e("buttons")) }, [ee(i(xn), { type: "primary", class: O([i(l).e("button"), i(l).is("with-texts", i(b))]), disabled: i(wo)(u.rightChecked), onClick: i(m) }, { default: ie(() => [ee(i(Je), null, { default: ie(() => [ee(i(Zr))]), _: 1 }), i(En)(I.buttonTexts[0]) ? pe("v-if", !0) : (k(), z("span", bZ, Be(I.buttonTexts[0]), 1))]), _: 1 }, 8, ["class", "disabled", "onClick"]), ee(i(xn), { type: "primary", class: O([i(l).e("button"), i(l).is("with-texts", i(b))]), disabled: i(wo)(u.leftChecked), onClick: i(h) }, { default: ie(() => [i(En)(I.buttonTexts[1]) ? pe("v-if", !0) : (k(), z("span", wZ, Be(I.buttonTexts[1]), 1)), ee(i(Je), null, { default: ie(() => [ee(i(Un))]), _: 1 })]), _: 1 }, 8, ["class", "disabled", "onClick"])], 2), ee(iy, { ref_key: "rightPanel", ref: y, data: i(f), "option-render": i(x), placeholder: i(E), filterable: I.filterable, format: I.format, "filter-method": I.filterMethod, title: i(T), "default-checked": I.rightDefaultChecked, props: o.props, onCheckedChange: i(v) }, { default: ie(() => [ke(I.$slots, "right-footer")]), _: 3 }, 8, ["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"])], 2)); } });
var _Z = Fe(SZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/transfer/src/transfer.vue"]]);
const kZ = vt(_Z), wl = "$treeNodeId", uy = function (e, t) { !t || t[wl] || Object.defineProperty(t, wl, { value: e.id, enumerable: !1, configurable: !1, writable: !1 }); }, uv = function (e, t) { return e ? t[e] : t[wl]; }, sp = (e, t, n) => { const o = e.value.currentNode; n(); const r = e.value.currentNode; o !== r && t("current-change", r ? r.data : null, r); }, lp = e => { let t = !0, n = !0, o = !0; for (let r = 0, s = e.length; r < s; r++) {
    const l = e[r];
    (l.checked !== !0 || l.indeterminate) && (t = !1, l.disabled || (o = !1)), (l.checked !== !1 || l.indeterminate) && (n = !1);
} return { all: t, none: n, allWithoutDisable: o, half: !t && !n }; }, Ou = function (e) { if (e.childNodes.length === 0 || e.loading)
    return; const { all: t, none: n, half: o } = lp(e.childNodes); t ? (e.checked = !0, e.indeterminate = !1) : o ? (e.checked = !1, e.indeterminate = !0) : n && (e.checked = !1, e.indeterminate = !1); const r = e.parent; !r || r.level === 0 || e.store.checkStrictly || Ou(r); }, tu = function (e, t) { const n = e.store.props, o = e.data || {}, r = n[t]; if (typeof r == "function")
    return r(o, e); if (typeof r == "string")
    return o[r]; if (typeof r > "u") {
    const s = o[t];
    return s === void 0 ? "" : s;
} };
let EZ = 0;
class Bs {
    constructor(t) { this.id = EZ++, this.text = null, this.checked = !1, this.indeterminate = !1, this.data = null, this.expanded = !1, this.parent = null, this.visible = !0, this.isCurrent = !1, this.canFocus = !1; for (const n in t)
        Tt(t, n) && (this[n] = t[n]); this.level = 0, this.loaded = !1, this.childNodes = [], this.loading = !1, this.parent && (this.level = this.parent.level + 1); }
    initialize() { const t = this.store; if (!t)
        throw new Error("[Node]store is required!"); t.registerNode(this); const n = t.props; if (n && typeof n.isLeaf < "u") {
        const s = tu(this, "isLeaf");
        typeof s == "boolean" && (this.isLeafByUser = s);
    } if (t.lazy !== !0 && this.data ? (this.setData(this.data), t.defaultExpandAll && (this.expanded = !0, this.canFocus = !0)) : this.level > 0 && t.lazy && t.defaultExpandAll && this.expand(), Array.isArray(this.data) || uy(this, this.data), !this.data)
        return; const o = t.defaultExpandedKeys, r = t.key; r && o && o.includes(this.key) && this.expand(null, t.autoExpandParent), r && t.currentNodeKey !== void 0 && this.key === t.currentNodeKey && (t.currentNode = this, t.currentNode.isCurrent = !0), t.lazy && t._initDefaultCheckedNode(this), this.updateLeafState(), this.parent && (this.level === 1 || this.parent.expanded === !0) && (this.canFocus = !0); }
    setData(t) { Array.isArray(t) || uy(this, t), this.data = t, this.childNodes = []; let n; this.level === 0 && Array.isArray(this.data) ? n = this.data : n = tu(this, "children") || []; for (let o = 0, r = n.length; o < r; o++)
        this.insertChild({ data: n[o] }); }
    get label() { return tu(this, "label"); }
    get key() { const t = this.store.key; return this.data ? this.data[t] : null; }
    get disabled() { return tu(this, "disabled"); }
    get nextSibling() { const t = this.parent; if (t) {
        const n = t.childNodes.indexOf(this);
        if (n > -1)
            return t.childNodes[n + 1];
    } return null; }
    get previousSibling() { const t = this.parent; if (t) {
        const n = t.childNodes.indexOf(this);
        if (n > -1)
            return n > 0 ? t.childNodes[n - 1] : null;
    } return null; }
    contains(t, n = !0) { return (this.childNodes || []).some(o => o === t || n && o.contains(t)); }
    remove() { const t = this.parent; t && t.removeChild(this); }
    insertChild(t, n, o) { if (!t)
        throw new Error("InsertChild error: child is required."); if (!(t instanceof Bs)) {
        if (!o) {
            const r = this.getChildren(!0);
            r.includes(t.data) || (typeof n > "u" || n < 0 ? r.push(t.data) : r.splice(n, 0, t.data));
        }
        Object.assign(t, { parent: this, store: this.store }), t = Lt(new Bs(t)), t instanceof Bs && t.initialize();
    } t.level = this.level + 1, typeof n > "u" || n < 0 ? this.childNodes.push(t) : this.childNodes.splice(n, 0, t), this.updateLeafState(); }
    insertBefore(t, n) { let o; n && (o = this.childNodes.indexOf(n)), this.insertChild(t, o); }
    insertAfter(t, n) { let o; n && (o = this.childNodes.indexOf(n), o !== -1 && (o += 1)), this.insertChild(t, o); }
    removeChild(t) { const n = this.getChildren() || [], o = n.indexOf(t.data); o > -1 && n.splice(o, 1); const r = this.childNodes.indexOf(t); r > -1 && (this.store && this.store.deregisterNode(t), t.parent = null, this.childNodes.splice(r, 1)), this.updateLeafState(); }
    removeChildByData(t) { let n = null; for (let o = 0; o < this.childNodes.length; o++)
        if (this.childNodes[o].data === t) {
            n = this.childNodes[o];
            break;
        } n && this.removeChild(n); }
    expand(t, n) { const o = () => { if (n) {
        let r = this.parent;
        for (; r.level > 0;)
            r.expanded = !0, r = r.parent;
    } this.expanded = !0, t && t(), this.childNodes.forEach(r => { r.canFocus = !0; }); }; this.shouldLoadData() ? this.loadData(r => { Array.isArray(r) && (this.checked ? this.setChecked(!0, !0) : this.store.checkStrictly || Ou(this), o()); }) : o(); }
    doCreateChildren(t, n = {}) { t.forEach(o => { this.insertChild(Object.assign({ data: o }, n), void 0, !0); }); }
    collapse() { this.expanded = !1, this.childNodes.forEach(t => { t.canFocus = !1; }); }
    shouldLoadData() { return this.store.lazy === !0 && this.store.load && !this.loaded; }
    updateLeafState() { if (this.store.lazy === !0 && this.loaded !== !0 && typeof this.isLeafByUser < "u") {
        this.isLeaf = this.isLeafByUser;
        return;
    } const t = this.childNodes; if (!this.store.lazy || this.store.lazy === !0 && this.loaded === !0) {
        this.isLeaf = !t || t.length === 0;
        return;
    } this.isLeaf = !1; }
    setChecked(t, n, o, r) { if (this.indeterminate = t === "half", this.checked = t === !0, this.store.checkStrictly)
        return; if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
        const { all: l, allWithoutDisable: a } = lp(this.childNodes);
        !this.isLeaf && !l && a && (this.checked = !1, t = !1);
        const u = () => { if (n) {
            const c = this.childNodes;
            for (let p = 0, v = c.length; p < v; p++) {
                const m = c[p];
                r = r || t !== !1;
                const h = m.disabled ? m.checked : r;
                m.setChecked(h, n, !0, r);
            }
            const { half: d, all: f } = lp(c);
            f || (this.checked = f, this.indeterminate = d);
        } };
        if (this.shouldLoadData()) {
            this.loadData(() => { u(), Ou(this); }, { checked: t !== !1 });
            return;
        }
        else
            u();
    } const s = this.parent; !s || s.level === 0 || o || Ou(s); }
    getChildren(t = !1) { if (this.level === 0)
        return this.data; const n = this.data; if (!n)
        return null; const o = this.store.props; let r = "children"; return o && (r = o.children || "children"), n[r] === void 0 && (n[r] = null), t && !n[r] && (n[r] = []), n[r]; }
    updateChildren() { const t = this.getChildren() || [], n = this.childNodes.map(s => s.data), o = {}, r = []; t.forEach((s, l) => { const a = s[wl]; !!a && n.findIndex(c => c[wl] === a) >= 0 ? o[a] = { index: l, data: s } : r.push({ index: l, data: s }); }), this.store.lazy || n.forEach(s => { o[s[wl]] || this.removeChildByData(s); }), r.forEach(({ index: s, data: l }) => { this.insertChild({ data: l }, s); }), this.updateLeafState(); }
    loadData(t, n = {}) { if (this.store.lazy === !0 && this.store.load && !this.loaded && (!this.loading || Object.keys(n).length)) {
        this.loading = !0;
        const o = r => { this.childNodes = [], this.doCreateChildren(r, n), this.loaded = !0, this.loading = !1, this.updateLeafState(), t && t.call(this, r); };
        this.store.load(this, o);
    }
    else
        t && t.call(this); }
}
class $Z {
    constructor(t) { this.currentNode = null, this.currentNodeKey = null; for (const n in t)
        Tt(t, n) && (this[n] = t[n]); this.nodesMap = {}; }
    initialize() { if (this.root = new Bs({ data: this.data, store: this }), this.root.initialize(), this.lazy && this.load) {
        const t = this.load;
        t(this.root, n => { this.root.doCreateChildren(n), this._initDefaultCheckedNodes(); });
    }
    else
        this._initDefaultCheckedNodes(); }
    filter(t) { const n = this.filterNodeMethod, o = this.lazy, r = function (s) { const l = s.root ? s.root.childNodes : s.childNodes; if (l.forEach(a => { a.visible = n.call(a, t, a.data, a), r(a); }), !s.visible && l.length) {
        let a = !0;
        a = !l.some(u => u.visible), s.root ? s.root.visible = a === !1 : s.visible = a === !1;
    } t && s.visible && !s.isLeaf && !o && s.expand(); }; r(this); }
    setData(t) { t !== this.root.data ? (this.root.setData(t), this._initDefaultCheckedNodes()) : this.root.updateChildren(); }
    getNode(t) { if (t instanceof Bs)
        return t; const n = yt(t) ? uv(this.key, t) : t; return this.nodesMap[n] || null; }
    insertBefore(t, n) { const o = this.getNode(n); o.parent.insertBefore({ data: t }, o); }
    insertAfter(t, n) { const o = this.getNode(n); o.parent.insertAfter({ data: t }, o); }
    remove(t) { const n = this.getNode(t); n && n.parent && (n === this.currentNode && (this.currentNode = null), n.parent.removeChild(n)); }
    append(t, n) { const o = n ? this.getNode(n) : this.root; o && o.insertChild({ data: t }); }
    _initDefaultCheckedNodes() { const t = this.defaultCheckedKeys || [], n = this.nodesMap; t.forEach(o => { const r = n[o]; r && r.setChecked(!0, !this.checkStrictly); }); }
    _initDefaultCheckedNode(t) { (this.defaultCheckedKeys || []).includes(t.key) && t.setChecked(!0, !this.checkStrictly); }
    setDefaultCheckedKey(t) { t !== this.defaultCheckedKeys && (this.defaultCheckedKeys = t, this._initDefaultCheckedNodes()); }
    registerNode(t) { const n = this.key; !t || !t.data || (n ? t.key !== void 0 && (this.nodesMap[t.key] = t) : this.nodesMap[t.id] = t); }
    deregisterNode(t) { !this.key || !t || !t.data || (t.childNodes.forEach(o => { this.deregisterNode(o); }), delete this.nodesMap[t.key]); }
    getCheckedNodes(t = !1, n = !1) { const o = [], r = function (s) { (s.root ? s.root.childNodes : s.childNodes).forEach(a => { (a.checked || n && a.indeterminate) && (!t || t && a.isLeaf) && o.push(a.data), r(a); }); }; return r(this), o; }
    getCheckedKeys(t = !1) { return this.getCheckedNodes(t).map(n => (n || {})[this.key]); }
    getHalfCheckedNodes() { const t = [], n = function (o) { (o.root ? o.root.childNodes : o.childNodes).forEach(s => { s.indeterminate && t.push(s.data), n(s); }); }; return n(this), t; }
    getHalfCheckedKeys() { return this.getHalfCheckedNodes().map(t => (t || {})[this.key]); }
    _getAllNodes() { const t = [], n = this.nodesMap; for (const o in n)
        Tt(n, o) && t.push(n[o]); return t; }
    updateChildren(t, n) { const o = this.nodesMap[t]; if (!o)
        return; const r = o.childNodes; for (let s = r.length - 1; s >= 0; s--) {
        const l = r[s];
        this.remove(l.data);
    } for (let s = 0, l = n.length; s < l; s++) {
        const a = n[s];
        this.append(a, o.data);
    } }
    _setCheckedKeys(t, n = !1, o) { const r = this._getAllNodes().sort((a, u) => u.level - a.level), s = Object.create(null), l = Object.keys(o); r.forEach(a => a.setChecked(!1, !1)); for (let a = 0, u = r.length; a < u; a++) {
        const c = r[a], d = c.data[t].toString();
        if (!l.includes(d)) {
            c.checked && !s[d] && c.setChecked(!1, !1);
            continue;
        }
        let p = c.parent;
        for (; p && p.level > 0;)
            s[p.data[t]] = !0, p = p.parent;
        if (c.isLeaf || this.checkStrictly) {
            c.setChecked(!0, !1);
            continue;
        }
        if (c.setChecked(!0, !0), n) {
            c.setChecked(!1, !1);
            const v = function (m) { m.childNodes.forEach(g => { g.isLeaf || g.setChecked(!1, !1), v(g); }); };
            v(c);
        }
    } }
    setCheckedNodes(t, n = !1) { const o = this.key, r = {}; t.forEach(s => { r[(s || {})[o]] = !0; }), this._setCheckedKeys(o, n, r); }
    setCheckedKeys(t, n = !1) { this.defaultCheckedKeys = t; const o = this.key, r = {}; t.forEach(s => { r[s] = !0; }), this._setCheckedKeys(o, n, r); }
    setDefaultExpandedKeys(t) { t = t || [], this.defaultExpandedKeys = t, t.forEach(n => { const o = this.getNode(n); o && o.expand(null, this.autoExpandParent); }); }
    setChecked(t, n, o) { const r = this.getNode(t); r && r.setChecked(!!n, o); }
    getCurrentNode() { return this.currentNode; }
    setCurrentNode(t) { const n = this.currentNode; n && (n.isCurrent = !1), this.currentNode = t, this.currentNode.isCurrent = !0; }
    setUserCurrentNode(t, n = !0) { const o = t[this.key], r = this.nodesMap[o]; this.setCurrentNode(r), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0); }
    setCurrentNodeKey(t, n = !0) { if (t == null) {
        this.currentNode && (this.currentNode.isCurrent = !1), this.currentNode = null;
        return;
    } const o = this.getNode(t); o && (this.setCurrentNode(o), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0)); }
}
const TZ = ae({ name: "ElTreeNodeContent", props: { node: { type: Object, required: !0 }, renderContent: Function }, setup(e) { const t = Ie("tree"), n = Ye("NodeInstance"), o = Ye("RootTree"); return () => { const r = e.node, { data: s, store: l } = r; return e.renderContent ? e.renderContent(nt, { _self: n, node: r, data: s, store: l }) : o.ctx.slots.default ? o.ctx.slots.default({ node: r, data: s }) : nt("span", { class: t.be("node", "label") }, [r.label]); }; } });
var OZ = Fe(TZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node-content.vue"]]);
function hS(e) { const t = Ye("TreeNodeMap", null), n = { treeNodeExpand: o => { e.node !== o && e.node.collapse(); }, children: [] }; return t && t.children.push(n), St("TreeNodeMap", n), { broadcastExpanded: o => { if (e.accordion)
        for (const r of n.children)
            r.treeNodeExpand(o); } }; }
const vS = Symbol("dragEvents");
function IZ({ props: e, ctx: t, el$: n, dropIndicator$: o, store: r }) { const s = Ie("tree"), l = M({ showDropIndicator: !1, draggingNode: null, dropNode: null, allowDrop: !0, dropType: null }); return St(vS, { treeNodeDragStart: ({ event: d, treeNode: f }) => { if (typeof e.allowDrag == "function" && !e.allowDrag(f.node))
        return d.preventDefault(), !1; d.dataTransfer.effectAllowed = "move"; try {
        d.dataTransfer.setData("text/plain", "");
    }
    catch { } l.value.draggingNode = f, t.emit("node-drag-start", f.node, d); }, treeNodeDragOver: ({ event: d, treeNode: f }) => { const p = f, v = l.value.dropNode; v && v.node.id !== p.node.id && so(v.$el, s.is("drop-inner")); const m = l.value.draggingNode; if (!m || !p)
        return; let h = !0, g = !0, y = !0, C = !0; typeof e.allowDrop == "function" && (h = e.allowDrop(m.node, p.node, "prev"), C = g = e.allowDrop(m.node, p.node, "inner"), y = e.allowDrop(m.node, p.node, "next")), d.dataTransfer.dropEffect = g || h || y ? "move" : "none", (h || g || y) && (v == null ? void 0 : v.node.id) !== p.node.id && (v && t.emit("node-drag-leave", m.node, v.node, d), t.emit("node-drag-enter", m.node, p.node, d)), (h || g || y) && (l.value.dropNode = p), p.node.nextSibling === m.node && (y = !1), p.node.previousSibling === m.node && (h = !1), p.node.contains(m.node, !1) && (g = !1), (m.node === p.node || m.node.contains(p.node)) && (h = !1, g = !1, y = !1); const b = p.$el.querySelector(`.${s.be("node", "content")}`).getBoundingClientRect(), w = n.value.getBoundingClientRect(); let T; const E = h ? g ? .25 : y ? .45 : 1 : -1, x = y ? g ? .75 : h ? .55 : 0 : 1; let I = -9999; const L = d.clientY - b.top; L < b.height * E ? T = "before" : L > b.height * x ? T = "after" : g ? T = "inner" : T = "none"; const B = p.$el.querySelector(`.${s.be("node", "expand-icon")}`).getBoundingClientRect(), F = o.value; T === "before" ? I = B.top - w.top : T === "after" && (I = B.bottom - w.top), F.style.top = `${I}px`, F.style.left = `${B.right - w.left}px`, T === "inner" ? Jo(p.$el, s.is("drop-inner")) : so(p.$el, s.is("drop-inner")), l.value.showDropIndicator = T === "before" || T === "after", l.value.allowDrop = l.value.showDropIndicator || C, l.value.dropType = T, t.emit("node-drag-over", m.node, p.node, d); }, treeNodeDragEnd: d => { const { draggingNode: f, dropType: p, dropNode: v } = l.value; if (d.preventDefault(), d.dataTransfer.dropEffect = "move", f && v) {
        const m = { data: f.node.data };
        p !== "none" && f.node.remove(), p === "before" ? v.node.parent.insertBefore(m, v.node) : p === "after" ? v.node.parent.insertAfter(m, v.node) : p === "inner" && v.node.insertChild(m), p !== "none" && r.value.registerNode(m), so(v.$el, s.is("drop-inner")), t.emit("node-drag-end", f.node, v.node, p, d), p !== "none" && t.emit("node-drop", f.node, v.node, p, d);
    } f && !v && t.emit("node-drag-end", f.node, null, p, d), l.value.showDropIndicator = !1, l.value.draggingNode = null, l.value.dropNode = null, l.value.allowDrop = !0; } }), { dragState: l }; }
const xZ = ae({ name: "ElTreeNode", components: { ElCollapseTransition: jc, ElCheckbox: Ao, NodeContent: OZ, ElIcon: Je, Loading: as }, props: { node: { type: Bs, default: () => ({}) }, props: { type: Object, default: () => ({}) }, accordion: Boolean, renderContent: Function, renderAfterExpand: Boolean, showCheckbox: { type: Boolean, default: !1 } }, emits: ["node-expand"], setup(e, t) { const n = Ie("tree"), { broadcastExpanded: o } = hS(e), r = Ye("RootTree"), s = M(!1), l = M(!1), a = M(null), u = M(null), c = M(null), d = Ye(vS), f = ht(); St("NodeInstance", f), e.node.expanded && (s.value = !0, l.value = !0); const p = r.props.children || "children"; Oe(() => { const L = e.node.data[p]; return L && [...L]; }, () => { e.node.updateChildren(); }), Oe(() => e.node.indeterminate, L => { h(e.node.checked, L); }), Oe(() => e.node.checked, L => { h(L, e.node.indeterminate); }), Oe(() => e.node.expanded, L => { Xe(() => s.value = L), L && (l.value = !0); }); const v = L => uv(r.props.nodeKey, L.data), m = L => { const B = e.props.class; if (!B)
        return {}; let F; if (at(B)) {
        const { data: V } = L;
        F = B(V, L);
    }
    else
        F = B; return it(F) ? { [F]: !0 } : F; }, h = (L, B) => { (a.value !== L || u.value !== B) && r.ctx.emit("check-change", e.node.data, L, B), a.value = L, u.value = B; }, g = L => { sp(r.store, r.ctx.emit, () => r.store.value.setCurrentNode(e.node)), r.currentNode.value = e.node, r.props.expandOnClickNode && C(), r.props.checkOnClickNode && !e.node.disabled && b(null, { target: { checked: !e.node.checked } }), r.ctx.emit("node-click", e.node.data, e.node, f, L); }, y = L => { r.instance.vnode.props.onNodeContextmenu && (L.stopPropagation(), L.preventDefault()), r.ctx.emit("node-contextmenu", L, e.node.data, e.node, f); }, C = () => { e.node.isLeaf || (s.value ? (r.ctx.emit("node-collapse", e.node.data, e.node, f), e.node.collapse()) : (e.node.expand(), t.emit("node-expand", e.node.data, e.node, f))); }, b = (L, B) => { e.node.setChecked(B.target.checked, !r.props.checkStrictly), Xe(() => { const F = r.store.value; r.ctx.emit("check", e.node.data, { checkedNodes: F.getCheckedNodes(), checkedKeys: F.getCheckedKeys(), halfCheckedNodes: F.getHalfCheckedNodes(), halfCheckedKeys: F.getHalfCheckedKeys() }); }); }; return { ns: n, node$: c, tree: r, expanded: s, childNodeRendered: l, oldChecked: a, oldIndeterminate: u, getNodeKey: v, getNodeClass: m, handleSelectChange: h, handleClick: g, handleContextMenu: y, handleExpandIconClick: C, handleCheckChange: b, handleChildNodeExpand: (L, B, F) => { o(B), r.ctx.emit("node-expand", L, B, F); }, handleDragStart: L => { r.props.draggable && d.treeNodeDragStart({ event: L, treeNode: e }); }, handleDragOver: L => { L.preventDefault(), r.props.draggable && d.treeNodeDragOver({ event: L, treeNode: { $el: c.value, node: e.node } }); }, handleDrop: L => { L.preventDefault(); }, handleDragEnd: L => { r.props.draggable && d.treeNodeDragEnd(L); }, CaretRight: A1 }; } }), AZ = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"], MZ = ["aria-expanded"];
function NZ(e, t, n, o, r, s) { const l = ct("el-icon"), a = ct("el-checkbox"), u = ct("loading"), c = ct("node-content"), d = ct("el-tree-node"), f = ct("el-collapse-transition"); return dt((k(), z("div", { ref: "node$", class: O([e.ns.b("node"), e.ns.is("expanded", e.expanded), e.ns.is("current", e.node.isCurrent), e.ns.is("hidden", !e.node.visible), e.ns.is("focusable", !e.node.disabled), e.ns.is("checked", !e.node.disabled && e.node.checked), e.getNodeClass(e.node)]), role: "treeitem", tabindex: "-1", "aria-expanded": e.expanded, "aria-disabled": e.node.disabled, "aria-checked": e.node.checked, draggable: e.tree.props.draggable, "data-key": e.getNodeKey(e.node), onClick: t[1] || (t[1] = st((...p) => e.handleClick && e.handleClick(...p), ["stop"])), onContextmenu: t[2] || (t[2] = (...p) => e.handleContextMenu && e.handleContextMenu(...p)), onDragstart: t[3] || (t[3] = st((...p) => e.handleDragStart && e.handleDragStart(...p), ["stop"])), onDragover: t[4] || (t[4] = st((...p) => e.handleDragOver && e.handleDragOver(...p), ["stop"])), onDragend: t[5] || (t[5] = st((...p) => e.handleDragEnd && e.handleDragEnd(...p), ["stop"])), onDrop: t[6] || (t[6] = st((...p) => e.handleDrop && e.handleDrop(...p), ["stop"])) }, [Q("div", { class: O(e.ns.be("node", "content")), style: et({ paddingLeft: (e.node.level - 1) * e.tree.props.indent + "px" }) }, [e.tree.props.icon || e.CaretRight ? (k(), ge(l, { key: 0, class: O([e.ns.be("node", "expand-icon"), e.ns.is("leaf", e.node.isLeaf), { expanded: !e.node.isLeaf && e.expanded }]), onClick: st(e.handleExpandIconClick, ["stop"]) }, { default: ie(() => [(k(), ge(kt(e.tree.props.icon || e.CaretRight)))]), _: 1 }, 8, ["class", "onClick"])) : pe("v-if", !0), e.showCheckbox ? (k(), ge(a, { key: 1, "model-value": e.node.checked, indeterminate: e.node.indeterminate, disabled: !!e.node.disabled, onClick: t[0] || (t[0] = st(() => { }, ["stop"])), onChange: e.handleCheckChange }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : pe("v-if", !0), e.node.loading ? (k(), ge(l, { key: 2, class: O([e.ns.be("node", "loading-icon"), e.ns.is("loading")]) }, { default: ie(() => [ee(u)]), _: 1 }, 8, ["class"])) : pe("v-if", !0), ee(c, { node: e.node, "render-content": e.renderContent }, null, 8, ["node", "render-content"])], 6), ee(f, null, { default: ie(() => [!e.renderAfterExpand || e.childNodeRendered ? dt((k(), z("div", { key: 0, class: O(e.ns.be("node", "children")), role: "group", "aria-expanded": e.expanded }, [(k(!0), z(Qe, null, Et(e.node.childNodes, p => (k(), ge(d, { key: e.getNodeKey(p), "render-content": e.renderContent, "render-after-expand": e.renderAfterExpand, "show-checkbox": e.showCheckbox, node: p, accordion: e.accordion, props: e.props, onNodeExpand: e.handleChildNodeExpand }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]))), 128))], 10, MZ)), [[Pt, e.expanded]]) : pe("v-if", !0)]), _: 1 })], 42, AZ)), [[Pt, e.node.visible]]); }
var PZ = Fe(xZ, [["render", NZ], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node.vue"]]);
function RZ({ el$: e }, t) { const n = Ie("tree"), o = Xt([]), r = Xt([]); ft(() => { l(); }), Er(() => { o.value = Array.from(e.value.querySelectorAll("[role=treeitem]")), r.value = Array.from(e.value.querySelectorAll("input[type=checkbox]")); }), Oe(r, a => { a.forEach(u => { u.setAttribute("tabindex", "-1"); }); }), nn(e, "keydown", a => { const u = a.target; if (!u.className.includes(n.b("node")))
    return; const c = a.code; o.value = Array.from(e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`)); const d = o.value.indexOf(u); let f; if ([tt.up, tt.down].includes(c)) {
    if (a.preventDefault(), c === tt.up) {
        f = d === -1 ? 0 : d !== 0 ? d - 1 : o.value.length - 1;
        const v = f;
        for (; !t.value.getNode(o.value[f].dataset.key).canFocus;) {
            if (f--, f === v) {
                f = -1;
                break;
            }
            f < 0 && (f = o.value.length - 1);
        }
    }
    else {
        f = d === -1 ? 0 : d < o.value.length - 1 ? d + 1 : 0;
        const v = f;
        for (; !t.value.getNode(o.value[f].dataset.key).canFocus;) {
            if (f++, f === v) {
                f = -1;
                break;
            }
            f >= o.value.length && (f = 0);
        }
    }
    f !== -1 && o.value[f].focus();
} [tt.left, tt.right].includes(c) && (a.preventDefault(), u.click()); const p = u.querySelector('[type="checkbox"]'); [tt.enter, tt.space].includes(c) && p && (a.preventDefault(), p.click()); }); const l = () => { var a; o.value = Array.from(e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`)), r.value = Array.from(e.value.querySelectorAll("input[type=checkbox]")); const u = e.value.querySelectorAll(`.${n.is("checked")}[role=treeitem]`); if (u.length) {
    u[0].setAttribute("tabindex", "0");
    return;
} (a = o.value[0]) == null || a.setAttribute("tabindex", "0"); }; }
const LZ = ae({ name: "ElTree", components: { ElTreeNode: PZ }, props: { data: { type: Array, default: () => [] }, emptyText: { type: String }, renderAfterExpand: { type: Boolean, default: !0 }, nodeKey: String, checkStrictly: Boolean, defaultExpandAll: Boolean, expandOnClickNode: { type: Boolean, default: !0 }, checkOnClickNode: Boolean, checkDescendants: { type: Boolean, default: !1 }, autoExpandParent: { type: Boolean, default: !0 }, defaultCheckedKeys: Array, defaultExpandedKeys: Array, currentNodeKey: [String, Number], renderContent: Function, showCheckbox: { type: Boolean, default: !1 }, draggable: { type: Boolean, default: !1 }, allowDrag: Function, allowDrop: Function, props: { type: Object, default: () => ({ children: "children", label: "label", disabled: "disabled" }) }, lazy: { type: Boolean, default: !1 }, highlightCurrent: Boolean, load: Function, filterNodeMethod: Function, accordion: Boolean, indent: { type: Number, default: 18 }, icon: { type: Zt } }, emits: ["check-change", "current-change", "node-click", "node-contextmenu", "node-collapse", "node-expand", "check", "node-drag-start", "node-drag-end", "node-drop", "node-drag-leave", "node-drag-enter", "node-drag-over"], setup(e, t) { const { t: n } = Nt(), o = Ie("tree"), r = M(new $Z({ key: e.nodeKey, data: e.data, lazy: e.lazy, props: e.props, load: e.load, currentNodeKey: e.currentNodeKey, checkStrictly: e.checkStrictly, checkDescendants: e.checkDescendants, defaultCheckedKeys: e.defaultCheckedKeys, defaultExpandedKeys: e.defaultExpandedKeys, autoExpandParent: e.autoExpandParent, defaultExpandAll: e.defaultExpandAll, filterNodeMethod: e.filterNodeMethod })); r.value.initialize(); const s = M(r.value.root), l = M(null), a = M(null), u = M(null), { broadcastExpanded: c } = hS(e), { dragState: d } = IZ({ props: e, ctx: t, el$: a, dropIndicator$: u, store: r }); RZ({ el$: a }, r); const f = S(() => { const { childNodes: D } = s.value; return !D || D.length === 0 || D.every(({ visible: j }) => !j); }); Oe(() => e.currentNodeKey, D => { r.value.setCurrentNodeKey(D); }), Oe(() => e.defaultCheckedKeys, D => { r.value.setDefaultCheckedKey(D); }), Oe(() => e.defaultExpandedKeys, D => { r.value.setDefaultExpandedKeys(D); }), Oe(() => e.data, D => { r.value.setData(D); }, { deep: !0 }), Oe(() => e.checkStrictly, D => { r.value.checkStrictly = D; }); const p = D => { if (!e.filterNodeMethod)
        throw new Error("[Tree] filterNodeMethod is required when filter"); r.value.filter(D); }, v = D => uv(e.nodeKey, D.data), m = D => { if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in getNodePath"); const j = r.value.getNode(D); if (!j)
        return []; const A = [j.data]; let G = j.parent; for (; G && G !== s.value;)
        A.push(G.data), G = G.parent; return A.reverse(); }, h = (D, j) => r.value.getCheckedNodes(D, j), g = D => r.value.getCheckedKeys(D), y = () => { const D = r.value.getCurrentNode(); return D ? D.data : null; }, C = () => { if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in getCurrentKey"); const D = y(); return D ? D[e.nodeKey] : null; }, b = (D, j) => { if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedNodes"); r.value.setCheckedNodes(D, j); }, w = (D, j) => { if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedKeys"); r.value.setCheckedKeys(D, j); }, T = (D, j, A) => { r.value.setChecked(D, j, A); }, E = () => r.value.getHalfCheckedNodes(), x = () => r.value.getHalfCheckedKeys(), I = (D, j = !0) => { if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentNode"); sp(r, t.emit, () => r.value.setUserCurrentNode(D, j)); }, L = (D, j = !0) => { if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentKey"); sp(r, t.emit, () => r.value.setCurrentNodeKey(D, j)); }, B = D => r.value.getNode(D), F = D => { r.value.remove(D); }, V = (D, j) => { r.value.append(D, j); }, R = (D, j) => { r.value.insertBefore(D, j); }, K = (D, j) => { r.value.insertAfter(D, j); }, te = (D, j, A) => { c(j), t.emit("node-expand", D, j, A); }, U = (D, j) => { if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in updateKeyChild"); r.value.updateChildren(D, j); }; return St("RootTree", { ctx: t, props: e, store: r, root: s, currentNode: l, instance: ht() }), St(rr, void 0), { ns: o, store: r, root: s, currentNode: l, dragState: d, el$: a, dropIndicator$: u, isEmpty: f, filter: p, getNodeKey: v, getNodePath: m, getCheckedNodes: h, getCheckedKeys: g, getCurrentNode: y, getCurrentKey: C, setCheckedNodes: b, setCheckedKeys: w, setChecked: T, getHalfCheckedNodes: E, getHalfCheckedKeys: x, setCurrentNode: I, setCurrentKey: L, t: n, getNode: B, remove: F, append: V, insertBefore: R, insertAfter: K, handleNodeExpand: te, updateKeyChildren: U }; } });
function DZ(e, t, n, o, r, s) { const l = ct("el-tree-node"); return k(), z("div", { ref: "el$", class: O([e.ns.b(), e.ns.is("dragging", !!e.dragState.draggingNode), e.ns.is("drop-not-allow", !e.dragState.allowDrop), e.ns.is("drop-inner", e.dragState.dropType === "inner"), { [e.ns.m("highlight-current")]: e.highlightCurrent }]), role: "tree" }, [(k(!0), z(Qe, null, Et(e.root.childNodes, a => (k(), ge(l, { key: e.getNodeKey(a), node: a, props: e.props, accordion: e.accordion, "render-after-expand": e.renderAfterExpand, "show-checkbox": e.showCheckbox, "render-content": e.renderContent, onNodeExpand: e.handleNodeExpand }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]))), 128)), e.isEmpty ? (k(), z("div", { key: 0, class: O(e.ns.e("empty-block")) }, [ke(e.$slots, "empty", {}, () => { var a; return [Q("span", { class: O(e.ns.e("empty-text")) }, Be((a = e.emptyText) != null ? a : e.t("el.tree.emptyText")), 3)]; })], 2)) : pe("v-if", !0), dt(Q("div", { ref: "dropIndicator$", class: O(e.ns.e("drop-indicator")) }, null, 2), [[Pt, e.dragState.showDropIndicator]])], 2); }
var Iu = Fe(LZ, [["render", DZ], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree.vue"]]);
Iu.install = e => { e.component(Iu.name, Iu); };
const rc = Iu, BZ = rc, FZ = (e, { attrs: t }, { tree: n, key: o }) => { const r = Ie("tree-select"), s = { ...gr(Sn(e), Object.keys(Hs.props)), ...t, valueKey: o, popperClass: S(() => { const l = [r.e("popper")]; return e.popperClass && l.push(e.popperClass), l.join(" "); }), filterMethod: (l = "") => { e.filterMethod && e.filterMethod(l), Xe(() => { var a; (a = n.value) == null || a.filter(l); }); }, onVisibleChange: l => { var a; (a = t.onVisibleChange) == null || a.call(t, l), e.filterable && l && s.filterMethod(); } }; return s; }, VZ = ae({ extends: Xu, setup(e, t) { const n = Xu.setup(e, t); delete n.selectOptionClick; const o = ht().proxy; return Xe(() => { n.select.cachedOptions.get(o.value) || n.select.onOptionCreate(o); }), n; }, methods: { selectOptionClick() { this.$el.parentElement.click(); } } });
function ap(e) { return e || e === 0; }
function cv(e) { return Array.isArray(e) && e.length; }
function fa(e) { return Array.isArray(e) ? e : ap(e) ? [e] : []; }
function xu(e, t, n, o, r) { for (let s = 0; s < e.length; s++) {
    const l = e[s];
    if (t(l, s, e, r))
        return o ? o(l, s, e, r) : l;
    {
        const a = n(l);
        if (cv(a)) {
            const u = xu(a, t, n, o, l);
            if (u)
                return u;
        }
    }
} }
function mS(e, t, n, o) { for (let r = 0; r < e.length; r++) {
    const s = e[r];
    t(s, r, e, o);
    const l = n(s);
    cv(l) && mS(l, t, n, s);
} }
const zZ = (e, { attrs: t, slots: n, emit: o }, { select: r, tree: s, key: l }) => { Oe(() => e.modelValue, () => { e.showCheckbox && Xe(() => { const p = s.value; p && !ro(p.getCheckedKeys(), fa(e.modelValue)) && p.setCheckedKeys(fa(e.modelValue)); }); }, { immediate: !0, deep: !0 }); const a = S(() => ({ value: l.value, label: "label", children: "children", disabled: "disabled", isLeaf: "isLeaf", ...e.props })), u = (p, v) => { var m; const h = a.value[p]; return at(h) ? h(v, (m = s.value) == null ? void 0 : m.getNode(u("value", v))) : v[h]; }, c = fa(e.modelValue).map(p => xu(e.data || [], v => u("value", v) === p, v => u("children", v), (v, m, h, g) => g && u("value", g))).filter(p => ap(p)), d = S(() => { if (!e.renderAfterExpand && !e.lazy)
    return []; const p = []; return mS(e.data.concat(e.cacheData), v => { const m = u("value", v); p.push({ value: m, currentLabel: u("label", v), isDisabled: u("disabled", v) }); }, v => u("children", v)), p; }), f = S(() => d.value.reduce((p, v) => ({ ...p, [v.value]: v }), {})); return { ...gr(Sn(e), Object.keys(rc.props)), ...t, nodeKey: l, expandOnClickNode: S(() => !e.checkStrictly && e.expandOnClickNode), defaultExpandedKeys: S(() => e.defaultExpandedKeys ? e.defaultExpandedKeys.concat(c) : c), renderContent: (p, { node: v, data: m, store: h }) => p(VZ, { value: u("value", m), label: u("label", m), disabled: u("disabled", m) }, e.renderContent ? () => e.renderContent(p, { node: v, data: m, store: h }) : n.default ? () => n.default({ node: v, data: m, store: h }) : void 0), filterNodeMethod: (p, v, m) => { var h; return e.filterNodeMethod ? e.filterNodeMethod(p, v, m) : p ? (h = u("label", v)) == null ? void 0 : h.includes(p) : !0; }, onNodeClick: (p, v, m) => { var h, g, y; if ((h = t.onNodeClick) == null || h.call(t, p, v, m), !(e.showCheckbox && e.checkOnClickNode))
        if (!e.showCheckbox && (e.checkStrictly || v.isLeaf)) {
            if (!u("disabled", p)) {
                const C = (g = r.value) == null ? void 0 : g.options.get(u("value", p));
                (y = r.value) == null || y.handleOptionSelect(C);
            }
        }
        else
            e.expandOnClickNode && m.proxy.handleExpandIconClick(); }, onCheck: (p, v) => { if (!e.showCheckbox)
        return; const m = u("value", p), h = v.checkedKeys, g = e.multiple ? fa(e.modelValue).filter(C => C in f.value && !s.value.getNode(C) && !h.includes(C)) : [], y = h.concat(g); if (e.checkStrictly)
        o(gt, e.multiple ? y : y.includes(m) ? m : void 0);
    else if (e.multiple)
        o(gt, s.value.getCheckedKeys(!0));
    else {
        const C = xu([p], T => !cv(u("children", T)) && !u("disabled", T), T => u("children", T)), b = C ? u("value", C) : void 0, w = ap(e.modelValue) && !!xu([p], T => u("value", T) === e.modelValue, T => u("children", T));
        o(gt, b === e.modelValue || w ? void 0 : b);
    } Xe(() => { var C; const b = fa(e.modelValue); s.value.setCheckedKeys(b), (C = t.onCheck) == null || C.call(t, p, { checkedKeys: s.value.getCheckedKeys(), checkedNodes: s.value.getCheckedNodes(), halfCheckedKeys: s.value.getHalfCheckedKeys(), halfCheckedNodes: s.value.getHalfCheckedNodes() }); }); }, cacheOptions: d }; };
var HZ = ae({ props: { data: { type: Array, default: () => [] } }, setup(e) { const t = Ye(Ti); return Oe(() => e.data, () => { var n; e.data.forEach(r => { t.cachedOptions.has(r.value) || t.cachedOptions.set(r.value, r); }); const o = ((n = t.selectWrapper) == null ? void 0 : n.querySelectorAll("input")) || []; Array.from(o).includes(document.activeElement) || t.setSelected(); }, { flush: "post", immediate: !0 }), () => { }; } });
const KZ = ae({ name: "ElTreeSelect", inheritAttrs: !1, props: { ...Hs.props, ...rc.props, cacheData: { type: Array, default: () => [] } }, setup(e, t) { const { slots: n, expose: o } = t, r = M(), s = M(), l = S(() => e.nodeKey || e.valueKey || "value"), a = FZ(e, t, { select: r, tree: s, key: l }), { cacheOptions: u, ...c } = zZ(e, t, { select: r, tree: s, key: l }), d = Lt({}); return o(d), ft(() => { Object.assign(d, { ...gr(s.value, ["filter", "updateKeyChildren", "getCheckedNodes", "setCheckedNodes", "getCheckedKeys", "setCheckedKeys", "setChecked", "getHalfCheckedNodes", "getHalfCheckedKeys", "getCurrentKey", "getCurrentNode", "setCurrentKey", "setCurrentNode", "getNode", "remove", "append", "insertBefore", "insertAfter"]), ...gr(r.value, ["focus", "blur"]) }); }), () => nt(Hs, Lt({ ...a, ref: f => r.value = f }), { ...n, default: () => [nt(HZ, { data: u.value }), nt(rc, Lt({ ...c, ref: f => s.value = f }))] }); } });
var Au = Fe(KZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-select/src/tree-select.vue"]]);
Au.install = e => { e.component(Au.name, Au); };
const jZ = Au, WZ = jZ, dv = Symbol(), UZ = { key: -1, level: -1, data: {} };
var ma = (e => (e.KEY = "id", e.LABEL = "label", e.CHILDREN = "children", e.DISABLED = "disabled", e))(ma || {}), ip = (e => (e.ADD = "add", e.DELETE = "delete", e))(ip || {});
const gS = { type: Number, default: 26 }, qZ = Ve({ data: { type: ve(Array), default: () => ln([]) }, emptyText: { type: String }, height: { type: Number, default: 200 }, props: { type: ve(Object), default: () => ln({ children: "children", label: "label", disabled: "disabled", value: "id" }) }, highlightCurrent: { type: Boolean, default: !1 }, showCheckbox: { type: Boolean, default: !1 }, defaultCheckedKeys: { type: ve(Array), default: () => ln([]) }, checkStrictly: { type: Boolean, default: !1 }, defaultExpandedKeys: { type: ve(Array), default: () => ln([]) }, indent: { type: Number, default: 16 }, itemSize: gS, icon: { type: Zt }, expandOnClickNode: { type: Boolean, default: !0 }, checkOnClickNode: { type: Boolean, default: !1 }, currentNodeKey: { type: ve([String, Number]) }, accordion: { type: Boolean, default: !1 }, filterMethod: { type: ve(Function) }, perfMode: { type: Boolean, default: !0 } }), YZ = Ve({ node: { type: ve(Object), default: () => ln(UZ) }, expanded: { type: Boolean, default: !1 }, checked: { type: Boolean, default: !1 }, indeterminate: { type: Boolean, default: !1 }, showCheckbox: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, current: { type: Boolean, default: !1 }, hiddenExpandIcon: { type: Boolean, default: !1 }, itemSize: gS }), GZ = Ve({ node: { type: ve(Object), required: !0 } }), yS = "node-click", bS = "node-expand", wS = "node-collapse", CS = "current-change", SS = "check", _S = "check-change", kS = "node-contextmenu", XZ = { [yS]: (e, t, n) => e && t && n, [bS]: (e, t) => e && t, [wS]: (e, t) => e && t, [CS]: (e, t) => e && t, [SS]: (e, t) => e && t, [_S]: (e, t) => e && typeof t == "boolean", [kS]: (e, t, n) => e && t && n }, JZ = { click: (e, t) => !!(e && t), toggle: e => !!e, check: (e, t) => e && typeof t == "boolean" };
function ZZ(e, t) { const n = M(new Set), o = M(new Set), { emit: r } = ht(); Oe([() => t.value, () => e.defaultCheckedKeys], () => Xe(() => { C(e.defaultCheckedKeys); }), { immediate: !0 }); const s = () => { if (!t.value || !e.showCheckbox || e.checkStrictly)
    return; const { levelTreeNodeMap: b, maxLevel: w } = t.value, T = n.value, E = new Set; for (let x = w - 1; x >= 1; --x) {
    const I = b.get(x);
    I && I.forEach(L => { const B = L.children; if (B) {
        let F = !0, V = !1;
        for (const R of B) {
            const K = R.key;
            if (T.has(K))
                V = !0;
            else if (E.has(K)) {
                F = !1, V = !0;
                break;
            }
            else
                F = !1;
        }
        F ? T.add(L.key) : V ? (E.add(L.key), T.delete(L.key)) : (T.delete(L.key), E.delete(L.key));
    } });
} o.value = E; }, l = b => n.value.has(b.key), a = b => o.value.has(b.key), u = (b, w, T = !0) => { const E = n.value, x = (I, L) => { E[L ? ip.ADD : ip.DELETE](I.key); const B = I.children; !e.checkStrictly && B && B.forEach(F => { F.disabled || x(F, L); }); }; x(b, w), s(), T && c(b, w); }, c = (b, w) => { const { checkedNodes: T, checkedKeys: E } = m(), { halfCheckedNodes: x, halfCheckedKeys: I } = h(); r(SS, b.data, { checkedKeys: E, checkedNodes: T, halfCheckedKeys: I, halfCheckedNodes: x }), r(_S, b.data, w); }; function d(b = !1) { return m(b).checkedKeys; } function f(b = !1) { return m(b).checkedNodes; } function p() { return h().halfCheckedKeys; } function v() { return h().halfCheckedNodes; } function m(b = !1) { const w = [], T = []; if (t != null && t.value && e.showCheckbox) {
    const { treeNodeMap: E } = t.value;
    n.value.forEach(x => { const I = E.get(x); I && (!b || b && I.isLeaf) && (T.push(x), w.push(I.data)); });
} return { checkedKeys: T, checkedNodes: w }; } function h() { const b = [], w = []; if (t != null && t.value && e.showCheckbox) {
    const { treeNodeMap: T } = t.value;
    o.value.forEach(E => { const x = T.get(E); x && (w.push(E), b.push(x.data)); });
} return { halfCheckedNodes: b, halfCheckedKeys: w }; } function g(b) { n.value.clear(), o.value.clear(), C(b); } function y(b, w) { if (t != null && t.value && e.showCheckbox) {
    const T = t.value.treeNodeMap.get(b);
    T && u(T, w, !1);
} } function C(b) { if (t != null && t.value) {
    const { treeNodeMap: w } = t.value;
    if (e.showCheckbox && w && b)
        for (const T of b) {
            const E = w.get(T);
            E && !l(E) && u(E, !0, !1);
        }
} } return { updateCheckedKeys: s, toggleCheckbox: u, isChecked: l, isIndeterminate: a, getCheckedKeys: d, getCheckedNodes: f, getHalfCheckedKeys: p, getHalfCheckedNodes: v, setChecked: y, setCheckedKeys: g }; }
function QZ(e, t) { const n = M(new Set([])), o = M(new Set([])), r = S(() => at(e.filterMethod)); function s(a) { var u; if (!r.value)
    return; const c = new Set, d = o.value, f = n.value, p = [], v = ((u = t.value) == null ? void 0 : u.treeNodes) || [], m = e.filterMethod; f.clear(); function h(g) { g.forEach(y => { p.push(y), m != null && m(a, y.data) ? p.forEach(b => { c.add(b.key); }) : y.isLeaf && f.add(y.key); const C = y.children; if (C && h(C), !y.isLeaf) {
    if (!c.has(y.key))
        f.add(y.key);
    else if (C) {
        let b = !0;
        for (const w of C)
            if (!f.has(w.key)) {
                b = !1;
                break;
            }
        b ? d.add(y.key) : d.delete(y.key);
    }
} p.pop(); }); } return h(v), c; } function l(a) { return o.value.has(a.key); } return { hiddenExpandIconKeySet: o, hiddenNodeKeySet: n, doFilter: s, isForceHiddenExpandIcon: l }; }
function eQ(e, t) { const n = M(new Set(e.defaultExpandedKeys)), o = M(), r = Xt(); Oe(() => e.currentNodeKey, oe => { o.value = oe; }, { immediate: !0 }), Oe(() => e.data, oe => { me(oe); }, { immediate: !0 }); const { isIndeterminate: s, isChecked: l, toggleCheckbox: a, getCheckedKeys: u, getCheckedNodes: c, getHalfCheckedKeys: d, getHalfCheckedNodes: f, setChecked: p, setCheckedKeys: v } = ZZ(e, r), { doFilter: m, hiddenNodeKeySet: h, isForceHiddenExpandIcon: g } = QZ(e, r), y = S(() => { var oe; return ((oe = e.props) == null ? void 0 : oe.value) || ma.KEY; }), C = S(() => { var oe; return ((oe = e.props) == null ? void 0 : oe.children) || ma.CHILDREN; }), b = S(() => { var oe; return ((oe = e.props) == null ? void 0 : oe.disabled) || ma.DISABLED; }), w = S(() => { var oe; return ((oe = e.props) == null ? void 0 : oe.label) || ma.LABEL; }), T = S(() => { const oe = n.value, fe = h.value, Ce = [], Ae = r.value && r.value.treeNodes || []; function q() { const re = []; for (let he = Ae.length - 1; he >= 0; --he)
    re.push(Ae[he]); for (; re.length;) {
    const he = re.pop();
    if (he && (fe.has(he.key) || Ce.push(he), oe.has(he.key))) {
        const Ee = he.children;
        if (Ee) {
            const Ne = Ee.length;
            for (let Se = Ne - 1; Se >= 0; --Se)
                re.push(Ee[Se]);
        }
    }
} } return q(), Ce; }), E = S(() => T.value.length > 0); function x(oe) { const fe = new Map, Ce = new Map; let Ae = 1; function q(he, Ee = 1, Ne = void 0) { var Se; const De = []; for (const Me of he) {
    const $e = B(Me), Pe = { level: Ee, key: $e, data: Me };
    Pe.label = V(Me), Pe.parent = Ne;
    const He = L(Me);
    Pe.disabled = F(Me), Pe.isLeaf = !He || He.length === 0, He && He.length && (Pe.children = q(He, Ee + 1, Pe)), De.push(Pe), fe.set($e, Pe), Ce.has(Ee) || Ce.set(Ee, []), (Se = Ce.get(Ee)) == null || Se.push(Pe);
} return Ee > Ae && (Ae = Ee), De; } const re = q(oe); return { treeNodeMap: fe, levelTreeNodeMap: Ce, maxLevel: Ae, treeNodes: re }; } function I(oe) { const fe = m(oe); fe && (n.value = fe); } function L(oe) { return oe[C.value]; } function B(oe) { return oe ? oe[y.value] : ""; } function F(oe) { return oe[b.value]; } function V(oe) { return oe[w.value]; } function R(oe) { n.value.has(oe.key) ? A(oe) : j(oe); } function K(oe) { n.value = new Set(oe); } function te(oe, fe) { t(yS, oe.data, oe, fe), U(oe), e.expandOnClickNode && R(oe), e.showCheckbox && e.checkOnClickNode && !oe.disabled && a(oe, !l(oe), !0); } function U(oe) { Z(oe) || (o.value = oe.key, t(CS, oe.data, oe)); } function D(oe, fe) { a(oe, fe); } function j(oe) { const fe = n.value; if (r.value && e.accordion) {
    const { treeNodeMap: Ce } = r.value;
    fe.forEach(Ae => { const q = Ce.get(Ae); oe && oe.level === (q == null ? void 0 : q.level) && fe.delete(Ae); });
} fe.add(oe.key), t(bS, oe.data, oe); } function A(oe) { n.value.delete(oe.key), t(wS, oe.data, oe); } function G(oe) { return n.value.has(oe.key); } function se(oe) { return !!oe.disabled; } function Z(oe) { const fe = o.value; return !!fe && fe === oe.key; } function ce() { var oe, fe; if (o.value)
    return (fe = (oe = r.value) == null ? void 0 : oe.treeNodeMap.get(o.value)) == null ? void 0 : fe.data; } function ye() { return o.value; } function Re(oe) { o.value = oe; } function me(oe) { Xe(() => r.value = x(oe)); } function le(oe) { var fe; const Ce = yt(oe) ? B(oe) : oe; return (fe = r.value) == null ? void 0 : fe.treeNodeMap.get(Ce); } return { tree: r, flattenTree: T, isNotEmpty: E, getKey: B, getChildren: L, toggleExpand: R, toggleCheckbox: a, isExpanded: G, isChecked: l, isIndeterminate: s, isDisabled: se, isCurrent: Z, isForceHiddenExpandIcon: g, handleNodeClick: te, handleNodeCheck: D, getCurrentNode: ce, getCurrentKey: ye, setCurrentKey: Re, getCheckedKeys: u, getCheckedNodes: c, getHalfCheckedKeys: d, getHalfCheckedNodes: f, setChecked: p, setCheckedKeys: v, filter: I, setData: me, getNode: le, expandNode: j, collapseNode: A, setExpandedKeys: K }; }
var tQ = ae({ name: "ElTreeNodeContent", props: GZ, setup(e) { const t = Ye(dv), n = Ie("tree"); return () => { const o = e.node, { data: r } = o; return t != null && t.ctx.slots.default ? t.ctx.slots.default({ node: o, data: r }) : nt("span", { class: n.be("node", "label") }, [o == null ? void 0 : o.label]); }; } });
const nQ = ["aria-expanded", "aria-disabled", "aria-checked", "data-key", "onClick"], oQ = ae({ name: "ElTreeNode" }), rQ = ae({ ...oQ, props: YZ, emits: JZ, setup(e, { emit: t }) { const n = e, o = Ye(dv), r = Ie("tree"), s = S(() => { var f; return (f = o == null ? void 0 : o.props.indent) != null ? f : 16; }), l = S(() => { var f; return (f = o == null ? void 0 : o.props.icon) != null ? f : A1; }), a = f => { t("click", n.node, f); }, u = () => { t("toggle", n.node); }, c = f => { t("check", n.node, f); }, d = f => { var p, v, m, h; (m = (v = (p = o == null ? void 0 : o.instance) == null ? void 0 : p.vnode) == null ? void 0 : v.props) != null && m.onNodeContextmenu && (f.stopPropagation(), f.preventDefault()), o == null || o.ctx.emit(kS, f, (h = n.node) == null ? void 0 : h.data, n.node); }; return (f, p) => { var v, m, h; return k(), z("div", { ref: "node$", class: O([i(r).b("node"), i(r).is("expanded", f.expanded), i(r).is("current", f.current), i(r).is("focusable", !f.disabled), i(r).is("checked", !f.disabled && f.checked)]), role: "treeitem", tabindex: "-1", "aria-expanded": f.expanded, "aria-disabled": f.disabled, "aria-checked": f.checked, "data-key": (v = f.node) == null ? void 0 : v.key, onClick: st(a, ["stop"]), onContextmenu: d }, [Q("div", { class: O(i(r).be("node", "content")), style: et({ paddingLeft: `${(f.node.level - 1) * i(s)}px`, height: f.itemSize + "px" }) }, [i(l) ? (k(), ge(i(Je), { key: 0, class: O([i(r).is("leaf", !!((m = f.node) != null && m.isLeaf)), i(r).is("hidden", f.hiddenExpandIcon), { expanded: !((h = f.node) != null && h.isLeaf) && f.expanded }, i(r).be("node", "expand-icon")]), onClick: st(u, ["stop"]) }, { default: ie(() => [(k(), ge(kt(i(l))))]), _: 1 }, 8, ["class", "onClick"])) : pe("v-if", !0), f.showCheckbox ? (k(), ge(i(Ao), { key: 1, "model-value": f.checked, indeterminate: f.indeterminate, disabled: f.disabled, onChange: c, onClick: p[0] || (p[0] = st(() => { }, ["stop"])) }, null, 8, ["model-value", "indeterminate", "disabled"])) : pe("v-if", !0), ee(i(tQ), { node: f.node }, null, 8, ["node"])], 6)], 42, nQ); }; } });
var sQ = Fe(rQ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree-node.vue"]]);
const lQ = ae({ name: "ElTreeV2" }), aQ = ae({ ...lQ, props: qZ, emits: XZ, setup(e, { expose: t, emit: n }) { const o = e, r = An(), s = S(() => o.itemSize); St(dv, { ctx: { emit: n, slots: r }, props: o, instance: ht() }), St(rr, void 0); const { t: l } = Nt(), a = Ie("tree"), { flattenTree: u, isNotEmpty: c, toggleExpand: d, isExpanded: f, isIndeterminate: p, isChecked: v, isDisabled: m, isCurrent: h, isForceHiddenExpandIcon: g, handleNodeClick: y, handleNodeCheck: C, toggleCheckbox: b, getCurrentNode: w, getCurrentKey: T, setCurrentKey: E, getCheckedKeys: x, getCheckedNodes: I, getHalfCheckedKeys: L, getHalfCheckedNodes: B, setChecked: F, setCheckedKeys: V, filter: R, setData: K, getNode: te, expandNode: U, collapseNode: D, setExpandedKeys: j } = eQ(o, n); return t({ toggleCheckbox: b, getCurrentNode: w, getCurrentKey: T, setCurrentKey: E, getCheckedKeys: x, getCheckedNodes: I, getHalfCheckedKeys: L, getHalfCheckedNodes: B, setChecked: F, setCheckedKeys: V, filter: R, setData: K, getNode: te, expandNode: U, collapseNode: D, setExpandedKeys: j }), (A, G) => { var se; return k(), z("div", { class: O([i(a).b(), { [i(a).m("highlight-current")]: A.highlightCurrent }]), role: "tree" }, [i(c) ? (k(), ge(i(x2), { key: 0, "class-name": i(a).b("virtual-list"), data: i(u), total: i(u).length, height: A.height, "item-size": i(s), "perf-mode": A.perfMode }, { default: ie(({ data: Z, index: ce, style: ye }) => [(k(), ge(sQ, { key: Z[ce].key, style: et(ye), node: Z[ce], expanded: i(f)(Z[ce]), "show-checkbox": A.showCheckbox, checked: i(v)(Z[ce]), indeterminate: i(p)(Z[ce]), "item-size": i(s), disabled: i(m)(Z[ce]), current: i(h)(Z[ce]), "hidden-expand-icon": i(g)(Z[ce]), onClick: i(y), onToggle: i(d), onCheck: i(C) }, null, 8, ["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "item-size", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck"]))]), _: 1 }, 8, ["class-name", "data", "total", "height", "item-size", "perf-mode"])) : (k(), z("div", { key: 1, class: O(i(a).e("empty-block")) }, [Q("span", { class: O(i(a).e("empty-text")) }, Be((se = A.emptyText) != null ? se : i(l)("el.tree.emptyText")), 3)], 2))], 2); }; } });
var iQ = Fe(aQ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree.vue"]]);
const uQ = vt(iQ), ES = Symbol("uploadContextKey"), cQ = "ElUpload";
class dQ extends Error {
    constructor(t, n, o, r) { super(t), this.name = "UploadAjaxError", this.status = n, this.method = o, this.url = r; }
}
function cy(e, t, n) { let o; return n.response ? o = `${n.response.error || n.response}` : n.responseText ? o = `${n.responseText}` : o = `fail to ${t.method} ${e} ${n.status}`, new dQ(o, n.status, t.method, e); }
function fQ(e) { const t = e.responseText || e.response; if (!t)
    return t; try {
    return JSON.parse(t);
}
catch {
    return t;
} }
const pQ = e => { typeof XMLHttpRequest > "u" && _n(cQ, "XMLHttpRequest is undefined"); const t = new XMLHttpRequest, n = e.action; t.upload && t.upload.addEventListener("progress", s => { const l = s; l.percent = s.total > 0 ? s.loaded / s.total * 100 : 0, e.onProgress(l); }); const o = new FormData; if (e.data)
    for (const [s, l] of Object.entries(e.data))
        Array.isArray(l) ? o.append(s, ...l) : o.append(s, l); o.append(e.filename, e.file, e.file.name), t.addEventListener("error", () => { e.onError(cy(n, e, t)); }), t.addEventListener("load", () => { if (t.status < 200 || t.status >= 300)
    return e.onError(cy(n, e, t)); e.onSuccess(fQ(t)); }), t.open(e.method, n, !0), e.withCredentials && "withCredentials" in t && (t.withCredentials = !0); const r = e.headers || {}; if (r instanceof Headers)
    r.forEach((s, l) => t.setRequestHeader(l, s));
else
    for (const [s, l] of Object.entries(r))
        bn(l) || t.setRequestHeader(s, String(l)); return t.send(o), t; }, $S = ["text", "picture", "picture-card"];
let hQ = 1;
const up = () => Date.now() + hQ++, TS = Ve({ action: { type: String, default: "#" }, headers: { type: ve(Object) }, method: { type: String, default: "post" }, data: { type: Object, default: () => ln({}) }, multiple: { type: Boolean, default: !1 }, name: { type: String, default: "file" }, drag: { type: Boolean, default: !1 }, withCredentials: Boolean, showFileList: { type: Boolean, default: !0 }, accept: { type: String, default: "" }, type: { type: String, default: "select" }, fileList: { type: ve(Array), default: () => ln([]) }, autoUpload: { type: Boolean, default: !0 }, listType: { type: String, values: $S, default: "text" }, httpRequest: { type: ve(Function), default: pQ }, disabled: Boolean, limit: Number }), vQ = Ve({ ...TS, beforeUpload: { type: ve(Function), default: Wt }, beforeRemove: { type: ve(Function) }, onRemove: { type: ve(Function), default: Wt }, onChange: { type: ve(Function), default: Wt }, onPreview: { type: ve(Function), default: Wt }, onSuccess: { type: ve(Function), default: Wt }, onProgress: { type: ve(Function), default: Wt }, onError: { type: ve(Function), default: Wt }, onExceed: { type: ve(Function), default: Wt } }), mQ = Ve({ files: { type: ve(Array), default: () => ln([]) }, disabled: { type: Boolean, default: !1 }, handlePreview: { type: ve(Function), default: Wt }, listType: { type: String, values: $S, default: "text" } }), gQ = { remove: e => !!e }, yQ = ["onKeydown"], bQ = ["src"], wQ = ["onClick"], CQ = ["title"], SQ = ["onClick"], _Q = ["onClick"], kQ = ae({ name: "ElUploadList" }), EQ = ae({ ...kQ, props: mQ, emits: gQ, setup(e, { emit: t }) { const { t: n } = Nt(), o = Ie("upload"), r = Ie("icon"), s = Ie("list"), l = uo(), a = M(!1), u = c => { t("remove", c); }; return (c, d) => (k(), ge(Sb, { tag: "ul", class: O([i(o).b("list"), i(o).bm("list", c.listType), i(o).is("disabled", i(l))]), name: i(s).b() }, { default: ie(() => [(k(!0), z(Qe, null, Et(c.files, f => (k(), z("li", { key: f.uid || f.name, class: O([i(o).be("list", "item"), i(o).is(f.status), { focusing: a.value }]), tabindex: "0", onKeydown: Mt(p => !i(l) && u(f), ["delete"]), onFocus: d[0] || (d[0] = p => a.value = !0), onBlur: d[1] || (d[1] = p => a.value = !1), onClick: d[2] || (d[2] = p => a.value = !1) }, [ke(c.$slots, "default", { file: f }, () => [c.listType === "picture" || f.status !== "uploading" && c.listType === "picture-card" ? (k(), z("img", { key: 0, class: O(i(o).be("list", "item-thumbnail")), src: f.url, alt: "" }, null, 10, bQ)) : pe("v-if", !0), f.status === "uploading" || c.listType !== "picture-card" ? (k(), z("div", { key: 1, class: O(i(o).be("list", "item-info")) }, [Q("a", { class: O(i(o).be("list", "item-name")), onClick: st(p => c.handlePreview(f), ["prevent"]) }, [ee(i(Je), { class: O(i(r).m("document")) }, { default: ie(() => [ee(i(SN))]), _: 1 }, 8, ["class"]), Q("span", { class: O(i(o).be("list", "item-file-name")), title: f.name }, Be(f.name), 11, CQ)], 10, wQ), f.status === "uploading" ? (k(), ge(i(C2), { key: 0, type: c.listType === "picture-card" ? "circle" : "line", "stroke-width": c.listType === "picture-card" ? 6 : 2, percentage: Number(f.percentage), style: et(c.listType === "picture-card" ? "" : "margin-top: 0.5rem") }, null, 8, ["type", "stroke-width", "percentage", "style"])) : pe("v-if", !0)], 2)) : pe("v-if", !0), Q("label", { class: O(i(o).be("list", "item-status-label")) }, [c.listType === "text" ? (k(), ge(i(Je), { key: 0, class: O([i(r).m("upload-success"), i(r).m("circle-check")]) }, { default: ie(() => [ee(i(ah))]), _: 1 }, 8, ["class"])) : ["picture-card", "picture"].includes(c.listType) ? (k(), ge(i(Je), { key: 1, class: O([i(r).m("upload-success"), i(r).m("check")]) }, { default: ie(() => [ee(i(_i))]), _: 1 }, 8, ["class"])) : pe("v-if", !0)], 2), i(l) ? pe("v-if", !0) : (k(), ge(i(Je), { key: 2, class: O(i(r).m("close")), onClick: p => u(f) }, { default: ie(() => [ee(i(Ho))]), _: 2 }, 1032, ["class", "onClick"])), pe(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"), pe(" This is a bug which needs to be fixed "), pe(" TODO: Fix the incorrect navigation interaction "), i(l) ? pe("v-if", !0) : (k(), z("i", { key: 3, class: O(i(r).m("close-tip")) }, Be(i(n)("el.upload.deleteTip")), 3)), c.listType === "picture-card" ? (k(), z("span", { key: 4, class: O(i(o).be("list", "item-actions")) }, [Q("span", { class: O(i(o).be("list", "item-preview")), onClick: p => c.handlePreview(f) }, [ee(i(Je), { class: O(i(r).m("zoom-in")) }, { default: ie(() => [ee(i(R1))]), _: 1 }, 8, ["class"])], 10, SQ), i(l) ? pe("v-if", !0) : (k(), z("span", { key: 0, class: O(i(o).be("list", "item-delete")), onClick: p => u(f) }, [ee(i(Je), { class: O(i(r).m("delete")) }, { default: ie(() => [ee(i(mN))]), _: 1 }, 8, ["class"])], 10, _Q))], 2)) : pe("v-if", !0)])], 42, yQ))), 128)), ke(c.$slots, "append")]), _: 3 }, 8, ["class", "name"])); } });
var dy = Fe(EQ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-list.vue"]]);
const $Q = Ve({ disabled: { type: Boolean, default: !1 } }), TQ = { file: e => qe(e) }, OQ = ["onDrop", "onDragover"], OS = "ElUploadDrag", IQ = ae({ name: OS }), xQ = ae({ ...IQ, props: $Q, emits: TQ, setup(e, { emit: t }) { const n = Ye(ES); n || _n(OS, "usage: <el-upload><el-upload-dragger /></el-upload>"); const o = Ie("upload"), r = M(!1), s = uo(), l = u => { if (s.value)
        return; r.value = !1, u.stopPropagation(); const c = Array.from(u.dataTransfer.files), d = n.accept.value; if (!d) {
        t("file", c);
        return;
    } const f = c.filter(p => { const { type: v, name: m } = p, h = m.includes(".") ? `.${m.split(".").pop()}` : "", g = v.replace(/\/.*$/, ""); return d.split(",").map(y => y.trim()).filter(y => y).some(y => y.startsWith(".") ? h === y : /\/\*$/.test(y) ? g === y.replace(/\/\*$/, "") : /^[^/]+\/[^/]+$/.test(y) ? v === y : !1); }); t("file", f); }, a = () => { s.value || (r.value = !0); }; return (u, c) => (k(), z("div", { class: O([i(o).b("dragger"), i(o).is("dragover", r.value)]), onDrop: st(l, ["prevent"]), onDragover: st(a, ["prevent"]), onDragleave: c[0] || (c[0] = st(d => r.value = !1, ["prevent"])) }, [ke(u.$slots, "default")], 42, OQ)); } });
var AQ = Fe(xQ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-dragger.vue"]]);
const MQ = Ve({ ...TS, beforeUpload: { type: ve(Function), default: Wt }, onRemove: { type: ve(Function), default: Wt }, onStart: { type: ve(Function), default: Wt }, onSuccess: { type: ve(Function), default: Wt }, onProgress: { type: ve(Function), default: Wt }, onError: { type: ve(Function), default: Wt }, onExceed: { type: ve(Function), default: Wt } }), NQ = ["onKeydown"], PQ = ["name", "multiple", "accept"], RQ = ae({ name: "ElUploadContent", inheritAttrs: !1 }), LQ = ae({ ...RQ, props: MQ, setup(e, { expose: t }) { const n = e, o = Ie("upload"), r = uo(), s = Xt({}), l = Xt(), a = m => { if (m.length === 0)
        return; const { autoUpload: h, limit: g, fileList: y, multiple: C, onStart: b, onExceed: w } = n; if (g && y.length + m.length > g) {
        w(m, y);
        return;
    } C || (m = m.slice(0, 1)); for (const T of m) {
        const E = T;
        E.uid = up(), b(E), h && u(E);
    } }, u = async (m) => { if (l.value.value = "", !n.beforeUpload)
        return c(m); let h, g = {}; try {
        const C = n.data, b = n.beforeUpload(m);
        g = yt(n.data) ? Hu(n.data) : n.data, h = await b, yt(n.data) && ro(C, g) && (g = Hu(n.data));
    }
    catch {
        h = !1;
    } if (h === !1) {
        n.onRemove(m);
        return;
    } let y = m; h instanceof Blob && (h instanceof File ? y = h : y = new File([h], m.name, { type: m.type })), c(Object.assign(y, { uid: m.uid }), g); }, c = (m, h) => { const { headers: g, data: y, method: C, withCredentials: b, name: w, action: T, onProgress: E, onSuccess: x, onError: I, httpRequest: L } = n, { uid: B } = m, F = { headers: g || {}, withCredentials: b, file: m, data: h ?? y, method: C, filename: w, action: T, onProgress: R => { E(R, m); }, onSuccess: R => { x(R, m), delete s.value[B]; }, onError: R => { I(R, m), delete s.value[B]; } }, V = L(F); s.value[B] = V, V instanceof Promise && V.then(F.onSuccess, F.onError); }, d = m => { const h = m.target.files; h && a(Array.from(h)); }, f = () => { r.value || (l.value.value = "", l.value.click()); }, p = () => { f(); }; return t({ abort: m => { SM(s.value).filter(m ? ([g]) => String(m.uid) === g : () => !0).forEach(([g, y]) => { y instanceof XMLHttpRequest && y.abort(), delete s.value[g]; }); }, upload: u }), (m, h) => (k(), z("div", { class: O([i(o).b(), i(o).m(m.listType), i(o).is("drag", m.drag)]), tabindex: "0", onClick: f, onKeydown: Mt(st(p, ["self"]), ["enter", "space"]) }, [m.drag ? (k(), ge(AQ, { key: 0, disabled: i(r), onFile: a }, { default: ie(() => [ke(m.$slots, "default")]), _: 3 }, 8, ["disabled"])) : ke(m.$slots, "default", { key: 1 }), Q("input", { ref_key: "inputRef", ref: l, class: O(i(o).e("input")), name: m.name, multiple: m.multiple, accept: m.accept, type: "file", onChange: d, onClick: h[0] || (h[0] = st(() => { }, ["stop"])) }, null, 42, PQ)], 42, NQ)); } });
var fy = Fe(LQ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-content.vue"]]);
const py = "ElUpload", DQ = e => { var t; (t = e.url) != null && t.startsWith("blob:") && URL.revokeObjectURL(e.url); }, BQ = (e, t) => { const n = fT(e, "fileList", void 0, { passive: !0 }), o = p => n.value.find(v => v.uid === p.uid); function r(p) { var v; (v = t.value) == null || v.abort(p); } function s(p = ["ready", "uploading", "success", "fail"]) { n.value = n.value.filter(v => !p.includes(v.status)); } const l = (p, v) => { const m = o(v); m && (console.error(p), m.status = "fail", n.value.splice(n.value.indexOf(m), 1), e.onError(p, m, n.value), e.onChange(m, n.value)); }, a = (p, v) => { const m = o(v); m && (e.onProgress(p, m, n.value), m.status = "uploading", m.percentage = Math.round(p.percent)); }, u = (p, v) => { const m = o(v); m && (m.status = "success", m.response = p, e.onSuccess(p, m, n.value), e.onChange(m, n.value)); }, c = p => { bn(p.uid) && (p.uid = up()); const v = { name: p.name, percentage: 0, status: "ready", size: p.size, raw: p, uid: p.uid }; if (e.listType === "picture-card" || e.listType === "picture")
    try {
        v.url = URL.createObjectURL(p);
    }
    catch (m) {
        m.message, e.onError(m, v, n.value);
    } n.value = [...n.value, v], e.onChange(v, n.value); }, d = async (p) => { const v = p instanceof File ? o(p) : p; v || _n(py, "file to be removed not found"); const m = h => { r(h); const g = n.value; g.splice(g.indexOf(h), 1), e.onRemove(h, g), DQ(h); }; e.beforeRemove ? await e.beforeRemove(v, n.value) !== !1 && m(v) : m(v); }; function f() { n.value.filter(({ status: p }) => p === "ready").forEach(({ raw: p }) => { var v; return p && ((v = t.value) == null ? void 0 : v.upload(p)); }); } return Oe(() => e.listType, p => { p !== "picture-card" && p !== "picture" || (n.value = n.value.map(v => { const { raw: m, url: h } = v; if (!h && m)
    try {
        v.url = URL.createObjectURL(m);
    }
    catch (g) {
        e.onError(g, v, n.value);
    } return v; })); }), Oe(n, p => { for (const v of p)
    v.uid || (v.uid = up()), v.status || (v.status = "success"); }, { immediate: !0, deep: !0 }), { uploadFiles: n, abort: r, clearFiles: s, handleError: l, handleProgress: a, handleStart: c, handleSuccess: u, handleRemove: d, submit: f }; }, FQ = ae({ name: "ElUpload" }), VQ = ae({ ...FQ, props: vQ, setup(e, { expose: t }) { const n = e, o = An(), r = uo(), s = Xt(), { abort: l, submit: a, clearFiles: u, uploadFiles: c, handleStart: d, handleError: f, handleRemove: p, handleSuccess: v, handleProgress: m } = BQ(n, s), h = S(() => n.listType === "picture-card"), g = S(() => ({ ...n, fileList: c.value, onStart: d, onProgress: m, onSuccess: v, onError: f, onRemove: p })); return on(() => { c.value.forEach(({ url: y }) => { y != null && y.startsWith("blob:") && URL.revokeObjectURL(y); }); }), St(ES, { accept: an(n, "accept") }), t({ abort: l, submit: a, clearFiles: u, handleStart: d, handleRemove: p }), (y, C) => (k(), z("div", null, [i(h) && y.showFileList ? (k(), ge(dy, { key: 0, disabled: i(r), "list-type": y.listType, files: i(c), "handle-preview": y.onPreview, onRemove: i(p) }, Cr({ append: ie(() => [ee(fy, Ct({ ref_key: "uploadRef", ref: s }, i(g)), { default: ie(() => [i(o).trigger ? ke(y.$slots, "trigger", { key: 0 }) : pe("v-if", !0), !i(o).trigger && i(o).default ? ke(y.$slots, "default", { key: 1 }) : pe("v-if", !0)]), _: 3 }, 16)]), _: 2 }, [y.$slots.file ? { name: "default", fn: ie(({ file: b }) => [ke(y.$slots, "file", { file: b })]) } : void 0]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : pe("v-if", !0), !i(h) || i(h) && !y.showFileList ? (k(), ge(fy, Ct({ key: 1, ref_key: "uploadRef", ref: s }, i(g)), { default: ie(() => [i(o).trigger ? ke(y.$slots, "trigger", { key: 0 }) : pe("v-if", !0), !i(o).trigger && i(o).default ? ke(y.$slots, "default", { key: 1 }) : pe("v-if", !0)]), _: 3 }, 16)) : pe("v-if", !0), y.$slots.trigger ? ke(y.$slots, "default", { key: 2 }) : pe("v-if", !0), ke(y.$slots, "tip"), !i(h) && y.showFileList ? (k(), ge(dy, { key: 3, disabled: i(r), "list-type": y.listType, files: i(c), "handle-preview": y.onPreview, onRemove: i(p) }, Cr({ _: 2 }, [y.$slots.file ? { name: "default", fn: ie(({ file: b }) => [ke(y.$slots, "file", { file: b })]) } : void 0]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : pe("v-if", !0)])); } });
var zQ = Fe(VQ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload.vue"]]);
const HQ = vt(zQ);
var KQ = [Z6, uL, RB, rJ, HB, GB, Fw, iF, uF, xn, Uw, O5, N5, q5, Y5, iz, YV, hz, Ao, hV, wC, $z, Wz, Uz, Lz, CH, j6, NH, PH, RH, LH, DH, XK, l9, a9, S9, t2, L9, Tj, Oj, Ij, c2, nD, oD, Je, C7, d2, Ln, f2, R7, tW, nW, oW, rW, dW, mU, SU, AU, Lw, C2, TC, xV, IV, YU, QU, Cz, Or, Hs, Xu, HW, Kq, Jq, Zq, OY, NY, V2, jY, QY, eG, dG, bX, wX, oJ, bJ, wJ, ri, EJ, l5, AJ, LJ, DJ, Jn, uZ, kZ, BZ, WZ, uQ, HQ];
const Po = "ElInfiniteScroll", jQ = 50, WQ = 200, UQ = 0, qQ = { delay: { type: Number, default: WQ }, distance: { type: Number, default: UQ }, disabled: { type: Boolean, default: !1 }, immediate: { type: Boolean, default: !0 } }, fv = (e, t) => Object.entries(qQ).reduce((n, [o, r]) => { var s, l; const { type: a, default: u } = r, c = e.getAttribute(`infinite-scroll-${o}`); let d = (l = (s = t[c]) != null ? s : c) != null ? l : u; return d = d === "false" ? !1 : d, d = a(d), n[o] = Number.isNaN(d) ? u : d, n; }, {}), IS = e => { const { observer: t } = e[Po]; t && (t.disconnect(), delete e[Po].observer); }, YQ = (e, t) => { const { container: n, containerEl: o, instance: r, observer: s, lastScrollTop: l } = e[Po], { disabled: a, distance: u } = fv(e, r), { clientHeight: c, scrollHeight: d, scrollTop: f } = o, p = f - l; if (e[Po].lastScrollTop = f, s || a || p < 0)
    return; let v = !1; if (n === e)
    v = d - (c + f) <= u;
else {
    const { clientTop: m, scrollHeight: h } = e, g = mT(e, o);
    v = f + c >= g + m + h - u;
} v && t.call(r); };
function Kd(e, t) { const { containerEl: n, instance: o } = e[Po], { disabled: r } = fv(e, o); r || n.clientHeight === 0 || (n.scrollHeight <= n.clientHeight ? t.call(o) : IS(e)); }
const GQ = { async mounted(e, t) { const { instance: n, value: o } = t; at(o) || _n(Po, "'v-infinite-scroll' binding value must be a function"), await Xe(); const { delay: r, immediate: s } = fv(e, n), l = lh(e, !0), a = l === window ? document.documentElement : l, u = Rs(YQ.bind(null, e, o), r); if (l) {
        if (e[Po] = { instance: n, container: l, containerEl: a, delay: r, cb: o, onScroll: u, lastScrollTop: a.scrollTop }, s) {
            const c = new MutationObserver(Rs(Kd.bind(null, e, o), jQ));
            e[Po].observer = c, c.observe(e, { childList: !0, subtree: !0 }), Kd(e, o);
        }
        l.addEventListener("scroll", u);
    } }, unmounted(e) { const { container: t, onScroll: n } = e[Po]; t == null || t.removeEventListener("scroll", n), IS(e); }, async updated(e) { if (!e[Po])
        await Xe();
    else {
        const { containerEl: t, cb: n, observer: o } = e[Po];
        t.clientHeight && o && Kd(e, n);
    } } }, cp = GQ;
cp.install = e => { e.directive("InfiniteScroll", cp); };
const XQ = cp;
function JQ(e) { let t; const n = M(!1), o = Lt({ ...e, originalPosition: "", originalOverflow: "", visible: !1 }); function r(p) { o.text = p; } function s() { const p = o.parent, v = f.ns; if (!p.vLoadingAddClassList) {
    let m = p.getAttribute("loading-number");
    m = Number.parseInt(m) - 1, m ? p.setAttribute("loading-number", m.toString()) : (so(p, v.bm("parent", "relative")), p.removeAttribute("loading-number")), so(p, v.bm("parent", "hidden"));
} l(), d.unmount(); } function l() { var p, v; (v = (p = f.$el) == null ? void 0 : p.parentNode) == null || v.removeChild(f.$el); } function a() { var p; e.beforeClose && !e.beforeClose() || (n.value = !0, clearTimeout(t), t = window.setTimeout(u, 400), o.visible = !1, (p = e.closed) == null || p.call(e)); } function u() { if (!n.value)
    return; const p = o.parent; n.value = !1, p.vLoadingAddClassList = void 0, s(); } const c = ae({ name: "ElLoading", setup(p, { expose: v }) { const { ns: m, zIndex: h } = Vc("loading"); return v({ ns: m, zIndex: h }), () => { const g = o.spinner || o.svg, y = nt("svg", { class: "circular", viewBox: o.svgViewBox ? o.svgViewBox : "0 0 50 50", ...g ? { innerHTML: g } : {} }, [nt("circle", { class: "path", cx: "25", cy: "25", r: "20", fill: "none" })]), C = o.text ? nt("p", { class: m.b("text") }, [o.text]) : void 0; return nt(yn, { name: m.b("fade"), onAfterLeave: u }, { default: ie(() => [dt(ee("div", { style: { backgroundColor: o.background || "" }, class: [m.b("mask"), o.customClass, o.fullscreen ? "is-fullscreen" : ""] }, [nt("div", { class: m.b("spinner") }, [y, C])]), [[Pt, o.visible]])]) }); }; } }), d = Tb(c), f = d.mount(document.createElement("div")); return { ...Sn(o), setText: r, removeElLoadingChild: l, close: a, handleAfterLeave: u, vm: f, get $el() { return f.$el; } }; }
let nu;
const dp = function (e = {}) { if (!At)
    return; const t = ZQ(e); if (t.fullscreen && nu)
    return nu; const n = JQ({ ...t, closed: () => { var r; (r = t.closed) == null || r.call(t), t.fullscreen && (nu = void 0); } }); QQ(t, t.parent, n), hy(t, t.parent, n), t.parent.vLoadingAddClassList = () => hy(t, t.parent, n); let o = t.parent.getAttribute("loading-number"); return o ? o = `${Number.parseInt(o) + 1}` : o = "1", t.parent.setAttribute("loading-number", o), t.parent.appendChild(n.$el), Xe(() => n.visible.value = t.visible), t.fullscreen && (nu = n), n; }, ZQ = e => { var t, n, o, r; let s; return it(e.target) ? s = (t = document.querySelector(e.target)) != null ? t : document.body : s = e.target || document.body, { parent: s === document.body || e.body ? document.body : s, background: e.background || "", svg: e.svg || "", svgViewBox: e.svgViewBox || "", spinner: e.spinner || !1, text: e.text || "", fullscreen: s === document.body && ((n = e.fullscreen) != null ? n : !0), lock: (o = e.lock) != null ? o : !1, customClass: e.customClass || "", visible: (r = e.visible) != null ? r : !0, target: s }; }, QQ = async (e, t, n) => { const { nextZIndex: o } = n.vm.zIndex || n.vm._.exposed.zIndex, r = {}; if (e.fullscreen)
    n.originalPosition.value = Kr(document.body, "position"), n.originalOverflow.value = Kr(document.body, "overflow"), r.zIndex = o();
else if (e.parent === document.body) {
    n.originalPosition.value = Kr(document.body, "position"), await Xe();
    for (const s of ["top", "left"]) {
        const l = s === "top" ? "scrollTop" : "scrollLeft";
        r[s] = `${e.target.getBoundingClientRect()[s] + document.body[l] + document.documentElement[l] - Number.parseInt(Kr(document.body, `margin-${s}`), 10)}px`;
    }
    for (const s of ["height", "width"])
        r[s] = `${e.target.getBoundingClientRect()[s]}px`;
}
else
    n.originalPosition.value = Kr(t, "position"); for (const [s, l] of Object.entries(r))
    n.$el.style[s] = l; }, hy = (e, t, n) => { const o = n.vm.ns || n.vm._.exposed.ns; ["absolute", "fixed", "sticky"].includes(n.originalPosition.value) ? so(t, o.bm("parent", "relative")) : Jo(t, o.bm("parent", "relative")), e.fullscreen && e.lock ? Jo(t, o.bm("parent", "hidden")) : so(t, o.bm("parent", "hidden")); }, fp = Symbol("ElLoading"), vy = (e, t) => { var n, o, r, s; const l = t.instance, a = p => yt(t.value) ? t.value[p] : void 0, u = p => { const v = it(p) && (l == null ? void 0 : l[p]) || p; return v && M(v); }, c = p => u(a(p) || e.getAttribute(`element-loading-${os(p)}`)), d = (n = a("fullscreen")) != null ? n : t.modifiers.fullscreen, f = { text: c("text"), svg: c("svg"), svgViewBox: c("svgViewBox"), spinner: c("spinner"), background: c("background"), customClass: c("customClass"), fullscreen: d, target: (o = a("target")) != null ? o : d ? void 0 : e, body: (r = a("body")) != null ? r : t.modifiers.body, lock: (s = a("lock")) != null ? s : t.modifiers.lock }; e[fp] = { options: f, instance: dp(f) }; }, eee = (e, t) => { for (const n of Object.keys(t))
    Jt(t[n]) && (t[n].value = e[n]); }, my = { mounted(e, t) { t.value && vy(e, t); }, updated(e, t) { const n = e[fp]; t.oldValue !== t.value && (t.value && !t.oldValue ? vy(e, t) : t.value && t.oldValue ? yt(t.value) && eee(t.value, n.options) : n == null || n.instance.close()); }, unmounted(e) { var t; (t = e[fp]) == null || t.instance.close(); } }, tee = { install(e) { e.directive("loading", my), e.config.globalProperties.$loading = dp; }, directive: my, service: dp }, xS = ["success", "info", "warning", "error"], no = ln({ customClass: "", center: !1, dangerouslyUseHTMLString: !1, duration: 3e3, icon: void 0, id: "", message: "", onClose: void 0, showClose: !1, type: "info", offset: 16, zIndex: 0, grouping: !1, repeatNum: 1, appendTo: At ? document.body : void 0 }), nee = Ve({ customClass: { type: String, default: no.customClass }, center: { type: Boolean, default: no.center }, dangerouslyUseHTMLString: { type: Boolean, default: no.dangerouslyUseHTMLString }, duration: { type: Number, default: no.duration }, icon: { type: Zt, default: no.icon }, id: { type: String, default: no.id }, message: { type: ve([String, Object, Function]), default: no.message }, onClose: { type: ve(Function), required: !1 }, showClose: { type: Boolean, default: no.showClose }, type: { type: String, values: xS, default: no.type }, offset: { type: Number, default: no.offset }, zIndex: { type: Number, default: no.zIndex }, grouping: { type: Boolean, default: no.grouping }, repeatNum: { type: Number, default: no.repeatNum } }), oee = { destroy: () => !0 }, Bo = kp([]), ree = e => { const t = Bo.findIndex(r => r.id === e), n = Bo[t]; let o; return t > 0 && (o = Bo[t - 1]), { current: n, prev: o }; }, see = e => { const { prev: t } = ree(e); return t ? t.vm.exposed.bottom.value : 0; }, lee = (e, t) => Bo.findIndex(o => o.id === e) > 0 ? 20 : t, aee = ["id"], iee = ["innerHTML"], uee = ae({ name: "ElMessage" }), cee = ae({ ...uee, props: nee, emits: oee, setup(e, { expose: t }) { const n = e, { Close: o } = ch, { ns: r, zIndex: s } = Vc("message"), { currentZIndex: l, nextZIndex: a } = s, u = M(), c = M(!1), d = M(0); let f; const p = S(() => n.type ? n.type === "error" ? "danger" : n.type : "info"), v = S(() => { const x = n.type; return { [r.bm("icon", x)]: x && Qr[x] }; }), m = S(() => n.icon || Qr[n.type] || ""), h = S(() => see(n.id)), g = S(() => lee(n.id, n.offset) + h.value), y = S(() => d.value + g.value), C = S(() => ({ top: `${g.value}px`, zIndex: l.value })); function b() { n.duration !== 0 && ({ stop: f } = Vs(() => { T(); }, n.duration)); } function w() { f == null || f(); } function T() { c.value = !1; } function E({ code: x }) { x === tt.esc && T(); } return ft(() => { b(), a(), c.value = !0; }), Oe(() => n.repeatNum, () => { w(), b(); }), nn(document, "keydown", E), Vn(u, () => { d.value = u.value.getBoundingClientRect().height; }), t({ visible: c, bottom: y, close: T }), (x, I) => (k(), ge(yn, { name: i(r).b("fade"), onBeforeLeave: x.onClose, onAfterLeave: I[0] || (I[0] = L => x.$emit("destroy")), persisted: "" }, { default: ie(() => [dt(Q("div", { id: x.id, ref_key: "messageRef", ref: u, class: O([i(r).b(), { [i(r).m(x.type)]: x.type && !x.icon }, i(r).is("center", x.center), i(r).is("closable", x.showClose), x.customClass]), style: et(i(C)), role: "alert", onMouseenter: w, onMouseleave: b }, [x.repeatNum > 1 ? (k(), ge(i(Fw), { key: 0, value: x.repeatNum, type: i(p), class: O(i(r).e("badge")) }, null, 8, ["value", "type", "class"])) : pe("v-if", !0), i(m) ? (k(), ge(i(Je), { key: 1, class: O([i(r).e("icon"), i(v)]) }, { default: ie(() => [(k(), ge(kt(i(m))))]), _: 1 }, 8, ["class"])) : pe("v-if", !0), ke(x.$slots, "default", {}, () => [x.dangerouslyUseHTMLString ? (k(), z(Qe, { key: 1 }, [pe(" Caution here, message could've been compromised, never use user's input as message "), Q("p", { class: O(i(r).e("content")), innerHTML: x.message }, null, 10, iee)], 2112)) : (k(), z("p", { key: 0, class: O(i(r).e("content")) }, Be(x.message), 3))]), x.showClose ? (k(), ge(i(Je), { key: 2, class: O(i(r).e("closeBtn")), onClick: st(T, ["stop"]) }, { default: ie(() => [ee(i(o))]), _: 1 }, 8, ["class", "onClick"])) : pe("v-if", !0)], 46, aee), [[Pt, c.value]])]), _: 3 }, 8, ["name", "onBeforeLeave"])); } });
var dee = Fe(cee, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);
let fee = 1;
const AS = e => { const t = !e || it(e) || un(e) || at(e) ? { message: e } : e, n = { ...no, ...t }; if (!n.appendTo)
    n.appendTo = document.body;
else if (it(n.appendTo)) {
    let o = document.querySelector(n.appendTo);
    To(o) || (o = document.body), n.appendTo = o;
} return n; }, pee = e => { const t = Bo.indexOf(e); if (t === -1)
    return; Bo.splice(t, 1); const { handler: n } = e; n.close(); }, hee = ({ appendTo: e, ...t }, n) => { const o = `message_${fee++}`, r = t.onClose, s = document.createElement("div"), l = { ...t, id: o, onClose: () => { r == null || r(), pee(d); }, onDestroy: () => { El(null, s); } }, a = ee(dee, l, at(l.message) || un(l.message) ? { default: at(l.message) ? l.message : () => l.message } : null); a.appContext = n || zl._context, El(a, s), e.appendChild(s.firstElementChild); const u = a.component, d = { id: o, vnode: a, vm: u, handler: { close: () => { u.exposed.visible.value = !1; } }, props: a.component.props }; return d; }, zl = (e = {}, t) => { if (!At)
    return { close: () => { } }; if (lt(yf.max) && Bo.length >= yf.max)
    return { close: () => { } }; const n = AS(e); if (n.grouping && Bo.length) {
    const r = Bo.find(({ vnode: s }) => { var l; return ((l = s.props) == null ? void 0 : l.message) === n.message; });
    if (r)
        return r.props.repeatNum += 1, r.props.type = n.type, r.handler;
} const o = hee(n, t); return Bo.push(o), o.handler; };
xS.forEach(e => { zl[e] = (t = {}, n) => { const o = AS(t); return zl({ ...o, type: e }, n); }; });
function vee(e) { for (const t of Bo)
    (!e || e === t.props.type) && t.handler.close(); }
zl.closeAll = vee;
zl._context = null;
const mee = F1(zl, "$message"), gee = ae({ name: "ElMessageBox", directives: { TrapFocus: HF }, components: { ElButton: xn, ElFocusTrap: Hc, ElInput: Ln, ElOverlay: Fh, ElIcon: Je, ...ch }, inheritAttrs: !1, props: { buttonSize: { type: String, validator: Mc }, modal: { type: Boolean, default: !0 }, lockScroll: { type: Boolean, default: !0 }, showClose: { type: Boolean, default: !0 }, closeOnClickModal: { type: Boolean, default: !0 }, closeOnPressEscape: { type: Boolean, default: !0 }, closeOnHashChange: { type: Boolean, default: !0 }, center: Boolean, draggable: Boolean, roundButton: { default: !1, type: Boolean }, container: { type: String, default: "body" }, boxType: { type: String, default: "" } }, emits: ["vanish", "action"], setup(e, { emit: t }) { const { locale: n, zIndex: o, ns: r, size: s } = Vc("message-box", S(() => e.buttonSize)), { t: l } = n, { nextZIndex: a } = o, u = M(!1), c = Lt({ autofocus: !0, beforeClose: null, callback: null, cancelButtonText: "", cancelButtonClass: "", confirmButtonText: "", confirmButtonClass: "", customClass: "", customStyle: {}, dangerouslyUseHTMLString: !1, distinguishCancelAndClose: !1, icon: "", inputPattern: null, inputPlaceholder: "", inputType: "text", inputValue: null, inputValidator: null, inputErrorMessage: "", message: null, modalFade: !0, modalClass: "", showCancelButton: !1, showConfirmButton: !0, type: "", title: void 0, showInput: !1, action: "", confirmButtonLoading: !1, cancelButtonLoading: !1, confirmButtonDisabled: !1, editorErrorMessage: "", validateError: !1, zIndex: a() }), d = S(() => { const te = c.type; return { [r.bm("icon", te)]: te && Qr[te] }; }), f = xo(), p = xo(), v = S(() => c.icon || Qr[c.type] || ""), m = S(() => !!c.message), h = M(), g = M(), y = M(), C = M(), b = M(), w = S(() => c.confirmButtonClass); Oe(() => c.inputValue, async (te) => { await Xe(), e.boxType === "prompt" && te !== null && F(); }, { immediate: !0 }), Oe(() => u.value, te => { var U, D; te && (e.boxType !== "prompt" && (c.autofocus ? y.value = (D = (U = b.value) == null ? void 0 : U.$el) != null ? D : h.value : y.value = h.value), c.zIndex = a()), e.boxType === "prompt" && (te ? Xe().then(() => { var j; C.value && C.value.$el && (c.autofocus ? y.value = (j = V()) != null ? j : h.value : y.value = h.value); }) : (c.editorErrorMessage = "", c.validateError = !1)); }); const T = S(() => e.draggable); V1(h, g, T), ft(async () => { await Xe(), e.closeOnHashChange && window.addEventListener("hashchange", E); }), on(() => { e.closeOnHashChange && window.removeEventListener("hashchange", E); }); function E() { u.value && (u.value = !1, Xe(() => { c.action && t("action", c.action); })); } const x = () => { e.closeOnClickModal && B(c.distinguishCancelAndClose ? "close" : "cancel"); }, I = Ch(x), L = te => { if (c.inputType !== "textarea")
        return te.preventDefault(), B("confirm"); }, B = te => { var U; e.boxType === "prompt" && te === "confirm" && !F() || (c.action = te, c.beforeClose ? (U = c.beforeClose) == null || U.call(c, te, c, E) : E()); }, F = () => { if (e.boxType === "prompt") {
        const te = c.inputPattern;
        if (te && !te.test(c.inputValue || ""))
            return c.editorErrorMessage = c.inputErrorMessage || l("el.messagebox.error"), c.validateError = !0, !1;
        const U = c.inputValidator;
        if (typeof U == "function") {
            const D = U(c.inputValue);
            if (D === !1)
                return c.editorErrorMessage = c.inputErrorMessage || l("el.messagebox.error"), c.validateError = !0, !1;
            if (typeof D == "string")
                return c.editorErrorMessage = D, c.validateError = !0, !1;
        }
    } return c.editorErrorMessage = "", c.validateError = !1, !0; }, V = () => { const te = C.value.$refs; return te.input || te.textarea; }, R = () => { B("close"); }, K = () => { e.closeOnPressEscape && R(); }; return e.lockScroll && K1(u), { ...Sn(c), ns: r, overlayEvent: I, visible: u, hasMessage: m, typeClass: d, contentId: f, inputId: p, btnSize: s, iconComponent: v, confirmButtonClasses: w, rootRef: h, focusStartRef: y, headerRef: g, inputRef: C, confirmRef: b, doClose: E, handleClose: R, onCloseRequested: K, handleWrapperClick: x, handleInputEnter: L, handleAction: B, t: l }; } }), yee = ["aria-label", "aria-describedby"], bee = ["aria-label"], wee = ["id"];
function Cee(e, t, n, o, r, s) { const l = ct("el-icon"), a = ct("close"), u = ct("el-input"), c = ct("el-button"), d = ct("el-focus-trap"), f = ct("el-overlay"); return k(), ge(yn, { name: "fade-in-linear", onAfterLeave: t[11] || (t[11] = p => e.$emit("vanish")), persisted: "" }, { default: ie(() => [dt(ee(f, { "z-index": e.zIndex, "overlay-class": [e.ns.is("message-box"), e.modalClass], mask: e.modal }, { default: ie(() => [Q("div", { role: "dialog", "aria-label": e.title, "aria-modal": "true", "aria-describedby": e.showInput ? void 0 : e.contentId, class: O(`${e.ns.namespace.value}-overlay-message-box`), onClick: t[8] || (t[8] = (...p) => e.overlayEvent.onClick && e.overlayEvent.onClick(...p)), onMousedown: t[9] || (t[9] = (...p) => e.overlayEvent.onMousedown && e.overlayEvent.onMousedown(...p)), onMouseup: t[10] || (t[10] = (...p) => e.overlayEvent.onMouseup && e.overlayEvent.onMouseup(...p)) }, [ee(d, { loop: "", trapped: e.visible, "focus-trap-el": e.rootRef, "focus-start-el": e.focusStartRef, onReleaseRequested: e.onCloseRequested }, { default: ie(() => [Q("div", { ref: "rootRef", class: O([e.ns.b(), e.customClass, e.ns.is("draggable", e.draggable), { [e.ns.m("center")]: e.center }]), style: et(e.customStyle), tabindex: "-1", onClick: t[7] || (t[7] = st(() => { }, ["stop"])) }, [e.title !== null && e.title !== void 0 ? (k(), z("div", { key: 0, ref: "headerRef", class: O(e.ns.e("header")) }, [Q("div", { class: O(e.ns.e("title")) }, [e.iconComponent && e.center ? (k(), ge(l, { key: 0, class: O([e.ns.e("status"), e.typeClass]) }, { default: ie(() => [(k(), ge(kt(e.iconComponent)))]), _: 1 }, 8, ["class"])) : pe("v-if", !0), Q("span", null, Be(e.title), 1)], 2), e.showClose ? (k(), z("button", { key: 0, type: "button", class: O(e.ns.e("headerbtn")), "aria-label": e.t("el.messagebox.close"), onClick: t[0] || (t[0] = p => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel")), onKeydown: t[1] || (t[1] = Mt(st(p => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"])) }, [ee(l, { class: O(e.ns.e("close")) }, { default: ie(() => [ee(a)]), _: 1 }, 8, ["class"])], 42, bee)) : pe("v-if", !0)], 2)) : pe("v-if", !0), Q("div", { id: e.contentId, class: O(e.ns.e("content")) }, [Q("div", { class: O(e.ns.e("container")) }, [e.iconComponent && !e.center && e.hasMessage ? (k(), ge(l, { key: 0, class: O([e.ns.e("status"), e.typeClass]) }, { default: ie(() => [(k(), ge(kt(e.iconComponent)))]), _: 1 }, 8, ["class"])) : pe("v-if", !0), e.hasMessage ? (k(), z("div", { key: 1, class: O(e.ns.e("message")) }, [ke(e.$slots, "default", {}, () => [e.dangerouslyUseHTMLString ? (k(), ge(kt(e.showInput ? "label" : "p"), { key: 1, for: e.showInput ? e.inputId : void 0, innerHTML: e.message }, null, 8, ["for", "innerHTML"])) : (k(), ge(kt(e.showInput ? "label" : "p"), { key: 0, for: e.showInput ? e.inputId : void 0 }, { default: ie(() => [Ot(Be(e.dangerouslyUseHTMLString ? "" : e.message), 1)]), _: 1 }, 8, ["for"]))])], 2)) : pe("v-if", !0)], 2), dt(Q("div", { class: O(e.ns.e("input")) }, [ee(u, { id: e.inputId, ref: "inputRef", modelValue: e.inputValue, "onUpdate:modelValue": t[2] || (t[2] = p => e.inputValue = p), type: e.inputType, placeholder: e.inputPlaceholder, "aria-invalid": e.validateError, class: O({ invalid: e.validateError }), onKeydown: Mt(e.handleInputEnter, ["enter"]) }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]), Q("div", { class: O(e.ns.e("errormsg")), style: et({ visibility: e.editorErrorMessage ? "visible" : "hidden" }) }, Be(e.editorErrorMessage), 7)], 2), [[Pt, e.showInput]])], 10, wee), Q("div", { class: O(e.ns.e("btns")) }, [e.showCancelButton ? (k(), ge(c, { key: 0, loading: e.cancelButtonLoading, class: O([e.cancelButtonClass]), round: e.roundButton, size: e.btnSize, onClick: t[3] || (t[3] = p => e.handleAction("cancel")), onKeydown: t[4] || (t[4] = Mt(st(p => e.handleAction("cancel"), ["prevent"]), ["enter"])) }, { default: ie(() => [Ot(Be(e.cancelButtonText || e.t("el.messagebox.cancel")), 1)]), _: 1 }, 8, ["loading", "class", "round", "size"])) : pe("v-if", !0), dt(ee(c, { ref: "confirmRef", type: "primary", loading: e.confirmButtonLoading, class: O([e.confirmButtonClasses]), round: e.roundButton, disabled: e.confirmButtonDisabled, size: e.btnSize, onClick: t[5] || (t[5] = p => e.handleAction("confirm")), onKeydown: t[6] || (t[6] = Mt(st(p => e.handleAction("confirm"), ["prevent"]), ["enter"])) }, { default: ie(() => [Ot(Be(e.confirmButtonText || e.t("el.messagebox.confirm")), 1)]), _: 1 }, 8, ["loading", "class", "round", "disabled", "size"]), [[Pt, e.showConfirmButton]])], 2)], 6)]), _: 3 }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])], 42, yee)]), _: 3 }, 8, ["z-index", "overlay-class", "mask"]), [[Pt, e.visible]])]), _: 3 }); }
var See = Fe(gee, [["render", Cee], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/message-box/src/index.vue"]]);
const pi = new Map, _ee = e => { let t = document.body; return e.appendTo && (it(e.appendTo) && (t = document.querySelector(e.appendTo)), To(e.appendTo) && (t = e.appendTo), To(t) || (t = document.body)), t; }, kee = (e, t, n = null) => { const o = ee(See, e, at(e.message) || un(e.message) ? { default: at(e.message) ? e.message : () => e.message } : null); return o.appContext = n, El(o, t), _ee(e).appendChild(t.firstElementChild), o.component; }, Eee = () => document.createElement("div"), $ee = (e, t) => { const n = Eee(); e.onVanish = () => { El(null, n), pi.delete(r); }, e.onAction = s => { const l = pi.get(r); let a; e.showInput ? a = { value: r.inputValue, action: s } : a = s, e.callback ? e.callback(a, o.proxy) : s === "cancel" || s === "close" ? e.distinguishCancelAndClose && s !== "cancel" ? l.reject("close") : l.reject("cancel") : l.resolve(a); }; const o = kee(e, n, t), r = o.proxy; for (const s in e)
    Tt(e, s) && !Tt(r.$props, s) && (r[s] = e[s]); return r.visible = !0, r; };
function Jl(e, t = null) { if (!At)
    return Promise.reject(); let n; return it(e) || un(e) ? e = { message: e } : n = e.callback, new Promise((o, r) => { const s = $ee(e, t ?? Jl._context); pi.set(s, { options: e, callback: n, resolve: o, reject: r }); }); }
const Tee = ["alert", "confirm", "prompt"], Oee = { alert: { closeOnPressEscape: !1, closeOnClickModal: !1 }, confirm: { showCancelButton: !0 }, prompt: { showCancelButton: !0, showInput: !0 } };
Tee.forEach(e => { Jl[e] = Iee(e); });
function Iee(e) { return (t, n, o, r) => { let s = ""; return yt(n) ? (o = n, s = "") : En(n) ? s = "" : s = n, Jl(Object.assign({ title: s, message: t, type: "", ...Oee[e] }, o, { boxType: e }), r); }; }
Jl.close = () => { pi.forEach((e, t) => { t.doClose(); }), pi.clear(); };
Jl._context = null;
const Fr = Jl;
Fr.install = e => { Fr._context = e._context, e.config.globalProperties.$msgbox = Fr, e.config.globalProperties.$messageBox = Fr, e.config.globalProperties.$alert = Fr.alert, e.config.globalProperties.$confirm = Fr.confirm, e.config.globalProperties.$prompt = Fr.prompt; };
const xee = Fr, MS = ["success", "info", "warning", "error"], Aee = Ve({ customClass: { type: String, default: "" }, dangerouslyUseHTMLString: { type: Boolean, default: !1 }, duration: { type: Number, default: 4500 }, icon: { type: Zt }, id: { type: String, default: "" }, message: { type: ve([String, Object]), default: "" }, offset: { type: Number, default: 0 }, onClick: { type: ve(Function), default: () => { } }, onClose: { type: ve(Function), required: !0 }, position: { type: String, values: ["top-right", "top-left", "bottom-right", "bottom-left"], default: "top-right" }, showClose: { type: Boolean, default: !0 }, title: { type: String, default: "" }, type: { type: String, values: [...MS, ""], default: "" }, zIndex: Number }), Mee = { destroy: () => !0 }, Nee = ["id"], Pee = ["textContent"], Ree = { key: 0 }, Lee = ["innerHTML"], Dee = ae({ name: "ElNotification" }), Bee = ae({ ...Dee, props: Aee, emits: Mee, setup(e, { expose: t }) { const n = e, { ns: o, zIndex: r } = Vc("notification"), { nextZIndex: s, currentZIndex: l } = r, { Close: a } = D1, u = M(!1); let c; const d = S(() => { const b = n.type; return b && Qr[n.type] ? o.m(b) : ""; }), f = S(() => n.type && Qr[n.type] || n.icon), p = S(() => n.position.endsWith("right") ? "right" : "left"), v = S(() => n.position.startsWith("top") ? "top" : "bottom"), m = S(() => { var b; return { [v.value]: `${n.offset}px`, zIndex: (b = n.zIndex) != null ? b : l.value }; }); function h() { n.duration > 0 && ({ stop: c } = Vs(() => { u.value && y(); }, n.duration)); } function g() { c == null || c(); } function y() { u.value = !1; } function C({ code: b }) { b === tt.delete || b === tt.backspace ? g() : b === tt.esc ? u.value && y() : h(); } return ft(() => { h(), s(), u.value = !0; }), nn(document, "keydown", C), t({ visible: u, close: y }), (b, w) => (k(), ge(yn, { name: i(o).b("fade"), onBeforeLeave: b.onClose, onAfterLeave: w[1] || (w[1] = T => b.$emit("destroy")), persisted: "" }, { default: ie(() => [dt(Q("div", { id: b.id, class: O([i(o).b(), b.customClass, i(p)]), style: et(i(m)), role: "alert", onMouseenter: g, onMouseleave: h, onClick: w[0] || (w[0] = (...T) => b.onClick && b.onClick(...T)) }, [i(f) ? (k(), ge(i(Je), { key: 0, class: O([i(o).e("icon"), i(d)]) }, { default: ie(() => [(k(), ge(kt(i(f))))]), _: 1 }, 8, ["class"])) : pe("v-if", !0), Q("div", { class: O(i(o).e("group")) }, [Q("h2", { class: O(i(o).e("title")), textContent: Be(b.title) }, null, 10, Pee), dt(Q("div", { class: O(i(o).e("content")), style: et(b.title ? void 0 : { margin: 0 }) }, [ke(b.$slots, "default", {}, () => [b.dangerouslyUseHTMLString ? (k(), z(Qe, { key: 1 }, [pe(" Caution here, message could've been compromised, never use user's input as message "), Q("p", { innerHTML: b.message }, null, 8, Lee)], 2112)) : (k(), z("p", Ree, Be(b.message), 1))])], 6), [[Pt, b.message]]), b.showClose ? (k(), ge(i(Je), { key: 0, class: O(i(o).e("closeBtn")), onClick: st(y, ["stop"]) }, { default: ie(() => [ee(i(a))]), _: 1 }, 8, ["class", "onClick"])) : pe("v-if", !0)], 2)], 46, Nee), [[Pt, u.value]])]), _: 3 }, 8, ["name", "onBeforeLeave"])); } });
var Fee = Fe(Bee, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/notification/src/notification.vue"]]);
const sc = { "top-left": [], "top-right": [], "bottom-left": [], "bottom-right": [] }, pp = 16;
let Vee = 1;
const Hl = function (e = {}, t = null) { if (!At)
    return { close: () => { } }; (typeof e == "string" || un(e)) && (e = { message: e }); const n = e.position || "top-right"; let o = e.offset || 0; sc[n].forEach(({ vm: d }) => { var f; o += (((f = d.el) == null ? void 0 : f.offsetHeight) || 0) + pp; }), o += pp; const r = `notification_${Vee++}`, s = e.onClose, l = { ...e, offset: o, id: r, onClose: () => { zee(r, n, s); } }; let a = document.body; To(e.appendTo) ? a = e.appendTo : it(e.appendTo) && (a = document.querySelector(e.appendTo)), To(a) || (a = document.body); const u = document.createElement("div"), c = ee(Fee, l, un(l.message) ? { default: () => l.message } : null); return c.appContext = t ?? Hl._context, c.props.onDestroy = () => { El(null, u); }, El(c, u), sc[n].push({ vm: c }), a.appendChild(u.firstElementChild), { close: () => { c.component.exposed.visible.value = !1; } }; };
MS.forEach(e => { Hl[e] = (t = {}) => ((typeof t == "string" || un(t)) && (t = { message: t }), Hl({ ...t, type: e })); });
function zee(e, t, n) { const o = sc[t], r = o.findIndex(({ vm: c }) => { var d; return ((d = c.component) == null ? void 0 : d.props.id) === e; }); if (r === -1)
    return; const { vm: s } = o[r]; if (!s)
    return; n == null || n(s); const l = s.el.offsetHeight, a = t.split("-")[0]; o.splice(r, 1); const u = o.length; if (!(u < 1))
    for (let c = r; c < u; c++) {
        const { el: d, component: f } = o[c].vm, p = Number.parseInt(d.style[a], 10) - l - pp;
        f.props.offset = p;
    } }
function Hee() { for (const e of Object.values(sc))
    e.forEach(({ vm: t }) => { t.component.exposed.visible.value = !1; }); }
Hl.closeAll = Hee;
Hl._context = null;
const Kee = F1(Hl, "$notify");
var jee = [XQ, tee, mee, xee, Kee, w2], Wee = U6([...KQ, ...jee]), hp = { exports: {} };
(function (e, t) {
    (function (n, o) { o(t); })(ko, function (n) {
        function o(W, X) { return X.forEach(function ($) { $ && typeof $ != "string" && !Array.isArray($) && Object.keys($).forEach(function (Y) { if (Y !== "default" && !(Y in W)) {
            var H = Object.getOwnPropertyDescriptor($, Y);
            Object.defineProperty(W, Y, H.get ? H : { enumerable: !0, get: function () { return $[Y]; } });
        } }); }), Object.freeze(W); }
        ArrayBuffer.isView || (ArrayBuffer.isView = function (W) { return W !== null && typeof W == "object" && W.buffer instanceof ArrayBuffer; }), typeof globalThis > "u" && typeof window < "u" && (window.globalThis = window);
        var r = function (W, X) { return r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function ($, Y) { $.__proto__ = Y; } || function ($, Y) { for (var H in Y)
            Object.prototype.hasOwnProperty.call(Y, H) && ($[H] = Y[H]); }, r(W, X); };
        function s(W, X) { if (typeof X != "function" && X !== null)
            throw new TypeError("Class extends value " + String(X) + " is not a constructor or null"); r(W, X); function $() { this.constructor = W; } W.prototype = X === null ? Object.create(X) : ($.prototype = X.prototype, new $); }
        function l(W, X, $, Y) { function H(ue) { return ue instanceof $ ? ue : new $(function (de) { de(ue); }); } return new ($ || ($ = Promise))(function (ue, de) { function be(Ke) { try {
            we(Y.next(Ke));
        }
        catch (rt) {
            de(rt);
        } } function J(Ke) { try {
            we(Y.throw(Ke));
        }
        catch (rt) {
            de(rt);
        } } function we(Ke) { Ke.done ? ue(Ke.value) : H(Ke.value).then(be, J); } we((Y = Y.apply(W, X || [])).next()); }); }
        function a(W, X) { var $ = { label: 0, sent: function () { if (ue[0] & 1)
                throw ue[1]; return ue[1]; }, trys: [], ops: [] }, Y, H, ue, de; return de = { next: be(0), throw: be(1), return: be(2) }, typeof Symbol == "function" && (de[Symbol.iterator] = function () { return this; }), de; function be(we) { return function (Ke) { return J([we, Ke]); }; } function J(we) { if (Y)
            throw new TypeError("Generator is already executing."); for (; de && (de = 0, we[0] && ($ = 0)), $;)
            try {
                if (Y = 1, H && (ue = we[0] & 2 ? H.return : we[0] ? H.throw || ((ue = H.return) && ue.call(H), 0) : H.next) && !(ue = ue.call(H, we[1])).done)
                    return ue;
                switch (H = 0, ue && (we = [we[0] & 2, ue.value]), we[0]) {
                    case 0:
                    case 1:
                        ue = we;
                        break;
                    case 4: return $.label++, { value: we[1], done: !1 };
                    case 5:
                        $.label++, H = we[1], we = [0];
                        continue;
                    case 7:
                        we = $.ops.pop(), $.trys.pop();
                        continue;
                    default:
                        if (ue = $.trys, !(ue = ue.length > 0 && ue[ue.length - 1]) && (we[0] === 6 || we[0] === 2)) {
                            $ = 0;
                            continue;
                        }
                        if (we[0] === 3 && (!ue || we[1] > ue[0] && we[1] < ue[3])) {
                            $.label = we[1];
                            break;
                        }
                        if (we[0] === 6 && $.label < ue[1]) {
                            $.label = ue[1], ue = we;
                            break;
                        }
                        if (ue && $.label < ue[2]) {
                            $.label = ue[2], $.ops.push(we);
                            break;
                        }
                        ue[2] && $.ops.pop(), $.trys.pop();
                        continue;
                }
                we = X.call(W, $);
            }
            catch (Ke) {
                we = [6, Ke], H = 0;
            }
            finally {
                Y = ue = 0;
            } if (we[0] & 5)
            throw we[1]; return { value: we[0] ? we[1] : void 0, done: !0 }; } }
        function u(W, X) { X.statusMessage = W.statusText, X.statusCode = W.status, X.data = W.body; }
        function c(W, X, $) { $ = $ || {}; var Y, H, ue = $.body; return $.method = W, $.headers = $.headers || {}, ue instanceof FormData || ue && typeof ue == "object" && ($.headers["content-type"] = "application/json", $.body = JSON.stringify(ue)), $.withCredentials && ($.credentials = "include"), $.timeout && (H = new AbortController, $.signal = H.signal, Y = setTimeout(H.abort, $.timeout)), new Promise((de, be) => { fetch(X, $).then((J, we) => { clearTimeout(Y), u(J, J), we = J.status >= 400 ? be : de, ue = J.headers.get("content-type"), !ue || !~ue.indexOf("application/json") ? we(J) : J.text().then(Ke => { try {
            J.data = JSON.parse(Ke, $.reviver), we(J);
        }
        catch (rt) {
            rt.headers = J.headers, u(J, rt), be(rt);
        } }); }).catch(J => { J.timeout = H && H.signal.aborted, be(J); }); }); }
        var d = c.bind(c, "GET"), f = c.bind(c, "POST"), p = c.bind(c, "PATCH"), v = c.bind(c, "DELETE"), m = c.bind(c, "PUT"), h = v, g = d, y = p, C = f, b = m, w = c, T = { del: h, get: g, patch: y, post: C, put: b, send: w }, E = o({ __proto__: null, default: T, del: h, get: g, patch: y, post: C, put: b, send: w }, [T]), x;
        (function (W) { W[W.CONSENTED = 4e3] = "CONSENTED", W[W.DEVMODE_RESTART = 4010] = "DEVMODE_RESTART"; })(x || (x = {}));
        var I = function (W) { s(X, W); function X($, Y) { var H = W.call(this, Y) || this; return H.name = "ServerError", H.code = $, H; } return X; }(Error);
        function L(W, X) { if (this._offset = X, W instanceof ArrayBuffer)
            this._buffer = W, this._view = new DataView(this._buffer);
        else if (ArrayBuffer.isView(W))
            this._buffer = W.buffer, this._view = new DataView(this._buffer, W.byteOffset, W.byteLength);
        else
            throw new Error("Invalid argument"); }
        function B(W, X, $) { for (var Y = "", H = 0, ue = X, de = X + $; ue < de; ue++) {
            var be = W.getUint8(ue);
            if (!(be & 128)) {
                Y += String.fromCharCode(be);
                continue;
            }
            if ((be & 224) === 192) {
                Y += String.fromCharCode((be & 31) << 6 | W.getUint8(++ue) & 63);
                continue;
            }
            if ((be & 240) === 224) {
                Y += String.fromCharCode((be & 15) << 12 | (W.getUint8(++ue) & 63) << 6 | (W.getUint8(++ue) & 63) << 0);
                continue;
            }
            if ((be & 248) === 240) {
                H = (be & 7) << 18 | (W.getUint8(++ue) & 63) << 12 | (W.getUint8(++ue) & 63) << 6 | (W.getUint8(++ue) & 63) << 0, H >= 65536 ? (H -= 65536, Y += String.fromCharCode((H >>> 10) + 55296, (H & 1023) + 56320)) : Y += String.fromCharCode(H);
                continue;
            }
            throw new Error("Invalid byte " + be.toString(16));
        } return Y; }
        L.prototype._array = function (W) { for (var X = new Array(W), $ = 0; $ < W; $++)
            X[$] = this._parse(); return X; }, L.prototype._map = function (W) { for (var X = "", $ = {}, Y = 0; Y < W; Y++)
            X = this._parse(), $[X] = this._parse(); return $; }, L.prototype._str = function (W) { var X = B(this._view, this._offset, W); return this._offset += W, X; }, L.prototype._bin = function (W) { var X = this._buffer.slice(this._offset, this._offset + W); return this._offset += W, X; }, L.prototype._parse = function () { var W = this._view.getUint8(this._offset++), X, $ = 0, Y = 0, H = 0, ue = 0; if (W < 192)
            return W < 128 ? W : W < 144 ? this._map(W & 15) : W < 160 ? this._array(W & 15) : this._str(W & 31); if (W > 223)
            return (255 - W + 1) * -1; switch (W) {
            case 192: return null;
            case 194: return !1;
            case 195: return !0;
            case 196: return $ = this._view.getUint8(this._offset), this._offset += 1, this._bin($);
            case 197: return $ = this._view.getUint16(this._offset), this._offset += 2, this._bin($);
            case 198: return $ = this._view.getUint32(this._offset), this._offset += 4, this._bin($);
            case 199:
                if ($ = this._view.getUint8(this._offset), Y = this._view.getInt8(this._offset + 1), this._offset += 2, Y === -1) {
                    var de = this._view.getUint32(this._offset);
                    return H = this._view.getInt32(this._offset + 4), ue = this._view.getUint32(this._offset + 8), this._offset += 12, new Date((H * 4294967296 + ue) * 1e3 + de / 1e6);
                }
                return [Y, this._bin($)];
            case 200: return $ = this._view.getUint16(this._offset), Y = this._view.getInt8(this._offset + 2), this._offset += 3, [Y, this._bin($)];
            case 201: return $ = this._view.getUint32(this._offset), Y = this._view.getInt8(this._offset + 4), this._offset += 5, [Y, this._bin($)];
            case 202: return X = this._view.getFloat32(this._offset), this._offset += 4, X;
            case 203: return X = this._view.getFloat64(this._offset), this._offset += 8, X;
            case 204: return X = this._view.getUint8(this._offset), this._offset += 1, X;
            case 205: return X = this._view.getUint16(this._offset), this._offset += 2, X;
            case 206: return X = this._view.getUint32(this._offset), this._offset += 4, X;
            case 207: return H = this._view.getUint32(this._offset) * Math.pow(2, 32), ue = this._view.getUint32(this._offset + 4), this._offset += 8, H + ue;
            case 208: return X = this._view.getInt8(this._offset), this._offset += 1, X;
            case 209: return X = this._view.getInt16(this._offset), this._offset += 2, X;
            case 210: return X = this._view.getInt32(this._offset), this._offset += 4, X;
            case 211: return H = this._view.getInt32(this._offset) * Math.pow(2, 32), ue = this._view.getUint32(this._offset + 4), this._offset += 8, H + ue;
            case 212:
                if (Y = this._view.getInt8(this._offset), this._offset += 1, Y === 0) {
                    this._offset += 1;
                    return;
                }
                return [Y, this._bin(1)];
            case 213: return Y = this._view.getInt8(this._offset), this._offset += 1, [Y, this._bin(2)];
            case 214: return Y = this._view.getInt8(this._offset), this._offset += 1, Y === -1 ? (X = this._view.getUint32(this._offset), this._offset += 4, new Date(X * 1e3)) : [Y, this._bin(4)];
            case 215:
                if (Y = this._view.getInt8(this._offset), this._offset += 1, Y === 0)
                    return H = this._view.getInt32(this._offset) * Math.pow(2, 32), ue = this._view.getUint32(this._offset + 4), this._offset += 8, new Date(H + ue);
                if (Y === -1) {
                    H = this._view.getUint32(this._offset), ue = this._view.getUint32(this._offset + 4), this._offset += 8;
                    var be = (H & 3) * 4294967296 + ue;
                    return new Date(be * 1e3 + (H >>> 2) / 1e6);
                }
                return [Y, this._bin(8)];
            case 216: return Y = this._view.getInt8(this._offset), this._offset += 1, [Y, this._bin(16)];
            case 217: return $ = this._view.getUint8(this._offset), this._offset += 1, this._str($);
            case 218: return $ = this._view.getUint16(this._offset), this._offset += 2, this._str($);
            case 219: return $ = this._view.getUint32(this._offset), this._offset += 4, this._str($);
            case 220: return $ = this._view.getUint16(this._offset), this._offset += 2, this._array($);
            case 221: return $ = this._view.getUint32(this._offset), this._offset += 4, this._array($);
            case 222: return $ = this._view.getUint16(this._offset), this._offset += 2, this._map($);
            case 223: return $ = this._view.getUint32(this._offset), this._offset += 4, this._map($);
        } throw new Error("Could not parse"); };
        function F(W, X) { X === void 0 && (X = 0); var $ = new L(W, X), Y = $._parse(); if ($._offset !== W.byteLength)
            throw new Error(W.byteLength - $._offset + " trailing bytes"); return Y; }
        var V = 4294967296 - 1, R = 17179869184 - 1;
        function K(W, X, $) { for (var Y = 0, H = 0, ue = $.length; H < ue; H++)
            Y = $.charCodeAt(H), Y < 128 ? W.setUint8(X++, Y) : Y < 2048 ? (W.setUint8(X++, 192 | Y >> 6), W.setUint8(X++, 128 | Y & 63)) : Y < 55296 || Y >= 57344 ? (W.setUint8(X++, 224 | Y >> 12), W.setUint8(X++, 128 | Y >> 6 & 63), W.setUint8(X++, 128 | Y & 63)) : (H++, Y = 65536 + ((Y & 1023) << 10 | $.charCodeAt(H) & 1023), W.setUint8(X++, 240 | Y >> 18), W.setUint8(X++, 128 | Y >> 12 & 63), W.setUint8(X++, 128 | Y >> 6 & 63), W.setUint8(X++, 128 | Y & 63)); }
        function te(W) { for (var X = 0, $ = 0, Y = 0, H = W.length; Y < H; Y++)
            X = W.charCodeAt(Y), X < 128 ? $ += 1 : X < 2048 ? $ += 2 : X < 55296 || X >= 57344 ? $ += 3 : (Y++, $ += 4); return $; }
        function U(W, X, $) { var Y = typeof $, H = 0, ue = 0, de = 0, be = 0, J = 0, we = 0; if (Y === "string") {
            if (J = te($), J < 32)
                W.push(J | 160), we = 1;
            else if (J < 256)
                W.push(217, J), we = 2;
            else if (J < 65536)
                W.push(218, J >> 8, J), we = 3;
            else if (J < 4294967296)
                W.push(219, J >> 24, J >> 16, J >> 8, J), we = 5;
            else
                throw new Error("String too long");
            return X.push({ _str: $, _length: J, _offset: W.length }), we + J;
        } if (Y === "number")
            return Math.floor($) !== $ || !isFinite($) ? (W.push(203), X.push({ _float: $, _length: 8, _offset: W.length }), 9) : $ >= 0 ? $ < 128 ? (W.push($), 1) : $ < 256 ? (W.push(204, $), 2) : $ < 65536 ? (W.push(205, $ >> 8, $), 3) : $ < 4294967296 ? (W.push(206, $ >> 24, $ >> 16, $ >> 8, $), 5) : (de = $ / Math.pow(2, 32) >> 0, be = $ >>> 0, W.push(207, de >> 24, de >> 16, de >> 8, de, be >> 24, be >> 16, be >> 8, be), 9) : $ >= -32 ? (W.push($), 1) : $ >= -128 ? (W.push(208, $), 2) : $ >= -32768 ? (W.push(209, $ >> 8, $), 3) : $ >= -2147483648 ? (W.push(210, $ >> 24, $ >> 16, $ >> 8, $), 5) : (de = Math.floor($ / Math.pow(2, 32)), be = $ >>> 0, W.push(211, de >> 24, de >> 16, de >> 8, de, be >> 24, be >> 16, be >> 8, be), 9); if (Y === "object") {
            if ($ === null)
                return W.push(192), 1;
            if (Array.isArray($)) {
                if (J = $.length, J < 16)
                    W.push(J | 144), we = 1;
                else if (J < 65536)
                    W.push(220, J >> 8, J), we = 3;
                else if (J < 4294967296)
                    W.push(221, J >> 24, J >> 16, J >> 8, J), we = 5;
                else
                    throw new Error("Array too large");
                for (H = 0; H < J; H++)
                    we += U(W, X, $[H]);
                return we;
            }
            if ($ instanceof Date) {
                var Ke = $.getTime(), rt = Math.floor(Ke / 1e3), _e = (Ke - rt * 1e3) * 1e6;
                return rt >= 0 && _e >= 0 && rt <= R ? _e === 0 && rt <= V ? (W.push(214, 255, rt >> 24, rt >> 16, rt >> 8, rt), 6) : (de = rt / 4294967296, be = rt & 4294967295, W.push(215, 255, _e >> 22, _e >> 14, _e >> 6, de, be >> 24, be >> 16, be >> 8, be), 10) : (de = Math.floor(rt / 4294967296), be = rt >>> 0, W.push(199, 12, 255, _e >> 24, _e >> 16, _e >> 8, _e, de >> 24, de >> 16, de >> 8, de, be >> 24, be >> 16, be >> 8, be), 15);
            }
            if ($ instanceof ArrayBuffer) {
                if (J = $.byteLength, J < 256)
                    W.push(196, J), we = 2;
                else if (J < 65536)
                    W.push(197, J >> 8, J), we = 3;
                else if (J < 4294967296)
                    W.push(198, J >> 24, J >> 16, J >> 8, J), we = 5;
                else
                    throw new Error("Buffer too large");
                return X.push({ _bin: $, _length: J, _offset: W.length }), we + J;
            }
            if (typeof $.toJSON == "function")
                return U(W, X, $.toJSON());
            var ze = [], We = "", ut = Object.keys($);
            for (H = 0, ue = ut.length; H < ue; H++)
                We = ut[H], $[We] !== void 0 && typeof $[We] != "function" && ze.push(We);
            if (J = ze.length, J < 16)
                W.push(J | 128), we = 1;
            else if (J < 65536)
                W.push(222, J >> 8, J), we = 3;
            else if (J < 4294967296)
                W.push(223, J >> 24, J >> 16, J >> 8, J), we = 5;
            else
                throw new Error("Object too large");
            for (H = 0; H < J; H++)
                We = ze[H], we += U(W, X, We), we += U(W, X, $[We]);
            return we;
        } if (Y === "boolean")
            return W.push($ ? 195 : 194), 1; if (Y === "undefined")
            return W.push(192), 1; if (typeof $.toJSON == "function")
            return U(W, X, $.toJSON()); throw new Error("Could not encode"); }
        function D(W) { var X = [], $ = [], Y = U(X, $, W), H = new ArrayBuffer(Y), ue = new DataView(H), de = 0, be = 0, J = -1; $.length > 0 && (J = $[0]._offset); for (var we, Ke = 0, rt = 0, _e = 0, ze = X.length; _e < ze; _e++)
            if (ue.setUint8(be + _e, X[_e]), _e + 1 === J) {
                if (we = $[de], Ke = we._length, rt = be + J, we._bin)
                    for (var We = new Uint8Array(we._bin), ut = 0; ut < Ke; ut++)
                        ue.setUint8(rt + ut, We[ut]);
                else
                    we._str ? K(ue, rt, we._str) : we._float !== void 0 && ue.setFloat64(rt, we._float);
                de++, be += Ke, $[de] && (J = $[de]._offset);
            } return H; }
        var j = function () { throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object"); }, A = globalThis.WebSocket || j, G = function () { function W(X) { this.events = X; } return W.prototype.send = function (X) { X instanceof ArrayBuffer ? this.ws.send(X) : Array.isArray(X) && this.ws.send(new Uint8Array(X).buffer); }, W.prototype.connect = function (X) { this.ws = new A(X, this.protocols), this.ws.binaryType = "arraybuffer", this.ws.onopen = this.events.onopen, this.ws.onmessage = this.events.onmessage, this.ws.onclose = this.events.onclose, this.ws.onerror = this.events.onerror; }, W.prototype.close = function (X, $) { this.ws.close(X, $); }, Object.defineProperty(W.prototype, "isOpen", { get: function () { return this.ws.readyState === A.OPEN; }, enumerable: !1, configurable: !0 }), W; }(), se = function () { function W() { this.events = {}, this.transport = new G(this.events); } return W.prototype.send = function (X) { this.transport.send(X); }, W.prototype.connect = function (X) { this.transport.connect(X); }, W.prototype.close = function (X, $) { this.transport.close(X, $); }, Object.defineProperty(W.prototype, "isOpen", { get: function () { return this.transport.isOpen; }, enumerable: !1, configurable: !0 }), W; }();
        n.Protocol = void 0, function (W) { W[W.HANDSHAKE = 9] = "HANDSHAKE", W[W.JOIN_ROOM = 10] = "JOIN_ROOM", W[W.ERROR = 11] = "ERROR", W[W.LEAVE_ROOM = 12] = "LEAVE_ROOM", W[W.ROOM_DATA = 13] = "ROOM_DATA", W[W.ROOM_STATE = 14] = "ROOM_STATE", W[W.ROOM_STATE_PATCH = 15] = "ROOM_STATE_PATCH", W[W.ROOM_DATA_SCHEMA = 16] = "ROOM_DATA_SCHEMA", W[W.ROOM_DATA_BYTES = 17] = "ROOM_DATA_BYTES"; }(n.Protocol || (n.Protocol = {})), n.ErrorCode = void 0, function (W) { W[W.MATCHMAKE_NO_HANDLER = 4210] = "MATCHMAKE_NO_HANDLER", W[W.MATCHMAKE_INVALID_CRITERIA = 4211] = "MATCHMAKE_INVALID_CRITERIA", W[W.MATCHMAKE_INVALID_ROOM_ID = 4212] = "MATCHMAKE_INVALID_ROOM_ID", W[W.MATCHMAKE_UNHANDLED = 4213] = "MATCHMAKE_UNHANDLED", W[W.MATCHMAKE_EXPIRED = 4214] = "MATCHMAKE_EXPIRED", W[W.AUTH_FAILED = 4215] = "AUTH_FAILED", W[W.APPLICATION_ERROR = 4216] = "APPLICATION_ERROR"; }(n.ErrorCode || (n.ErrorCode = {}));
        function Z(W, X) { for (var $ = W[X++], Y = "", H = 0, ue = X, de = X + $; ue < de; ue++) {
            var be = W[ue];
            if (!(be & 128)) {
                Y += String.fromCharCode(be);
                continue;
            }
            if ((be & 224) === 192) {
                Y += String.fromCharCode((be & 31) << 6 | W[++ue] & 63);
                continue;
            }
            if ((be & 240) === 224) {
                Y += String.fromCharCode((be & 15) << 12 | (W[++ue] & 63) << 6 | (W[++ue] & 63) << 0);
                continue;
            }
            if ((be & 248) === 240) {
                H = (be & 7) << 18 | (W[++ue] & 63) << 12 | (W[++ue] & 63) << 6 | (W[++ue] & 63) << 0, H >= 65536 ? (H -= 65536, Y += String.fromCharCode((H >>> 10) + 55296, (H & 1023) + 56320)) : Y += String.fromCharCode(H);
                continue;
            }
            throw new Error("Invalid byte " + be.toString(16));
        } return Y; }
        function ce(W) { W === void 0 && (W = ""); for (var X = 0, $ = 0, Y = 0, H = W.length; Y < H; Y++)
            X = W.charCodeAt(Y), X < 128 ? $ += 1 : X < 2048 ? $ += 2 : X < 55296 || X >= 57344 ? $ += 3 : (Y++, $ += 4); return $ + 1; }
        var ye = {};
        function Re(W, X) { ye[W] = X; }
        function me(W) { var X = ye[W]; if (!X)
            throw new Error("missing serializer: " + W); return X; }
        let le = () => ({ events: {}, emit(W, ...X) { (this.events[W] || []).forEach($ => $(...X)); }, on(W, X) { return (this.events[W] = this.events[W] || []).push(X), () => this.events[W] = (this.events[W] || []).filter($ => $ !== X); } });
        var oe = function () { function W() { this.handlers = []; } return W.prototype.register = function (X, $) { return this.handlers.push(X), this; }, W.prototype.invoke = function () { for (var X = this, $ = [], Y = 0; Y < arguments.length; Y++)
            $[Y] = arguments[Y]; this.handlers.forEach(function (H) { return H.apply(X, $); }); }, W.prototype.invokeAsync = function () { for (var X = this, $ = [], Y = 0; Y < arguments.length; Y++)
            $[Y] = arguments[Y]; return Promise.all(this.handlers.map(function (H) { return H.apply(X, $); })); }, W.prototype.remove = function (X) { var $ = this.handlers.indexOf(X); this.handlers[$] = this.handlers[this.handlers.length - 1], this.handlers.pop(); }, W.prototype.clear = function () { this.handlers = []; }, W; }();
        function fe() { var W = new oe; function X($) { return W.register($, this === null); } return X.once = function ($) { var Y = function () { for (var H = [], ue = 0; ue < arguments.length; ue++)
            H[ue] = arguments[ue]; $.apply(this, H), W.remove(Y); }; W.register(Y); }, X.remove = function ($) { return W.remove($); }, X.invoke = function () { for (var $ = [], Y = 0; Y < arguments.length; Y++)
            $[Y] = arguments[Y]; return W.invoke.apply(W, $); }, X.invokeAsync = function () { for (var $ = [], Y = 0; Y < arguments.length; Y++)
            $[Y] = arguments[Y]; return W.invokeAsync.apply(W, $); }, X.clear = function () { return W.clear(); }, X; }
        var Ce = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof ko < "u" ? ko : typeof self < "u" ? self : {};
        function Ae(W) { var X = { exports: {} }; return W(X, X.exports), X.exports; }
        var q = Ae(function (W, X) {
            (function ($, Y) { Y(X); })(Ce, function ($) {
                var Y = function (N, _) { return Y = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (P, ne) { P.__proto__ = ne; } || function (P, ne) { for (var xe in ne)
                    Object.prototype.hasOwnProperty.call(ne, xe) && (P[xe] = ne[xe]); }, Y(N, _); };
                function H(N, _) { if (typeof _ != "function" && _ !== null)
                    throw new TypeError("Class extends value " + String(_) + " is not a constructor or null"); Y(N, _); function P() { this.constructor = N; } N.prototype = _ === null ? Object.create(_) : (P.prototype = _.prototype, new P); }
                function ue(N, _, P, ne) { var xe = arguments.length, Ze = xe < 3 ? _ : ne === null ? ne = Object.getOwnPropertyDescriptor(_, P) : ne, mt; if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                    Ze = Reflect.decorate(N, _, P, ne);
                else
                    for (var xt = N.length - 1; xt >= 0; xt--)
                        (mt = N[xt]) && (Ze = (xe < 3 ? mt(Ze) : xe > 3 ? mt(_, P, Ze) : mt(_, P)) || Ze); return xe > 3 && Ze && Object.defineProperty(_, P, Ze), Ze; }
                function de(N, _, P) { if (P || arguments.length === 2)
                    for (var ne = 0, xe = _.length, Ze; ne < xe; ne++)
                        (Ze || !(ne in _)) && (Ze || (Ze = Array.prototype.slice.call(_, 0, ne)), Ze[ne] = _[ne]); return N.concat(Ze || Array.prototype.slice.call(_)); }
                var be = 255, J = 213;
                $.OPERATION = void 0, function (N) { N[N.ADD = 128] = "ADD", N[N.REPLACE = 0] = "REPLACE", N[N.DELETE = 64] = "DELETE", N[N.DELETE_AND_ADD = 192] = "DELETE_AND_ADD", N[N.TOUCH = 1] = "TOUCH", N[N.CLEAR = 10] = "CLEAR"; }($.OPERATION || ($.OPERATION = {}));
                var we = function () { function N(_, P, ne) { this.changed = !1, this.changes = new Map, this.allChanges = new Set, this.caches = {}, this.currentCustomOperation = 0, this.ref = _, this.setParent(P, ne); } return N.prototype.setParent = function (_, P, ne) { var xe = this; if (this.indexes || (this.indexes = this.ref instanceof go ? this.ref._definition.indexes : {}), this.parent = _, this.parentIndex = ne, !!P)
                    if (this.root = P, this.ref instanceof go) {
                        var Ze = this.ref._definition;
                        for (var mt in Ze.schema) {
                            var xt = this.ref[mt];
                            if (xt && xt.$changes) {
                                var Ut = Ze.indexes[mt];
                                xt.$changes.setParent(this.ref, P, Ut);
                            }
                        }
                    }
                    else
                        typeof this.ref == "object" && this.ref.forEach(function (Ft, _t) { if (Ft instanceof go) {
                            var qt = Ft.$changes, $t = xe.ref.$changes.indexes[_t];
                            qt.setParent(xe.ref, xe.root, $t);
                        } }); }, N.prototype.operation = function (_) { this.changes.set(--this.currentCustomOperation, _); }, N.prototype.change = function (_, P) { P === void 0 && (P = $.OPERATION.ADD); var ne = typeof _ == "number" ? _ : this.indexes[_]; this.assertValidIndex(ne, _); var xe = this.changes.get(ne); (!xe || xe.op === $.OPERATION.DELETE || xe.op === $.OPERATION.TOUCH) && this.changes.set(ne, { op: xe && xe.op === $.OPERATION.DELETE ? $.OPERATION.DELETE_AND_ADD : P, index: ne }), this.allChanges.add(ne), this.changed = !0, this.touchParents(); }, N.prototype.touch = function (_) { var P = typeof _ == "number" ? _ : this.indexes[_]; this.assertValidIndex(P, _), this.changes.has(P) || this.changes.set(P, { op: $.OPERATION.TOUCH, index: P }), this.allChanges.add(P), this.touchParents(); }, N.prototype.touchParents = function () { this.parent && this.parent.$changes.touch(this.parentIndex); }, N.prototype.getType = function (_) { if (this.ref._definition) {
                    var P = this.ref._definition;
                    return P.schema[P.fieldsByIndex[_]];
                }
                else {
                    var P = this.parent._definition, ne = P.schema[P.fieldsByIndex[this.parentIndex]];
                    return Object.values(ne)[0];
                } }, N.prototype.getChildrenFilter = function () { var _ = this.parent._definition.childFilters; return _ && _[this.parentIndex]; }, N.prototype.getValue = function (_) { return this.ref.getByIndex(_); }, N.prototype.delete = function (_) { var P = typeof _ == "number" ? _ : this.indexes[_]; if (P === void 0) {
                    console.warn("@colyseus/schema ".concat(this.ref.constructor.name, ": trying to delete non-existing index: ").concat(_, " (").concat(P, ")"));
                    return;
                } var ne = this.getValue(P); this.changes.set(P, { op: $.OPERATION.DELETE, index: P }), this.allChanges.delete(P), delete this.caches[P], ne && ne.$changes && (ne.$changes.parent = void 0), this.changed = !0, this.touchParents(); }, N.prototype.discard = function (_, P) { var ne = this; _ === void 0 && (_ = !1), P === void 0 && (P = !1), this.ref instanceof go || this.changes.forEach(function (xe) { if (xe.op === $.OPERATION.DELETE) {
                    var Ze = ne.ref.getIndex(xe.index);
                    delete ne.indexes[Ze];
                } }), this.changes.clear(), this.changed = _, P && this.allChanges.clear(), this.currentCustomOperation = 0; }, N.prototype.discardAll = function () { var _ = this; this.changes.forEach(function (P) { var ne = _.getValue(P.index); ne && ne.$changes && ne.$changes.discardAll(); }), this.discard(); }, N.prototype.cache = function (_, P) { this.caches[_] = P; }, N.prototype.clone = function () { return new N(this.ref, this.parent, this.root); }, N.prototype.ensureRefId = function () { this.refId === void 0 && (this.refId = this.root.getNextUniqueId()); }, N.prototype.assertValidIndex = function (_, P) { if (_ === void 0)
                    throw new Error('ChangeTree: missing index for field "'.concat(P, '"')); }, N; }();
                function Ke(N, _, P, ne) { return N[_] || (N[_] = []), N[_].push(P), ne == null || ne.forEach(function (xe, Ze) { return P(xe, Ze); }), function () { return _e(N[_], N[_].indexOf(P)); }; }
                function rt(N) { var _ = this, P = typeof this.$changes.getType() != "string"; this.$items.forEach(function (ne, xe) { N.push({ refId: _.$changes.refId, op: $.OPERATION.DELETE, field: xe, value: void 0, previousValue: ne }), P && _.$changes.root.removeRef(ne.$changes.refId); }); }
                function _e(N, _) { if (_ === -1 || _ >= N.length)
                    return !1; for (var P = N.length - 1, ne = _; ne < P; ne++)
                    N[ne] = N[ne + 1]; return N.length = P, !0; }
                var ze = function (N, _) { var P = N.toString(), ne = _.toString(); return P < ne ? -1 : P > ne ? 1 : 0; };
                function We(N) { return N.$proxy = !0, N = new Proxy(N, { get: function (_, P) { return typeof P != "symbol" && !isNaN(P) ? _.at(P) : _[P]; }, set: function (_, P, ne) { if (typeof P != "symbol" && !isNaN(P)) {
                        var xe = Array.from(_.$items.keys()), Ze = parseInt(xe[P] || P);
                        ne == null ? _.deleteAt(Ze) : _.setAt(Ze, ne);
                    }
                    else
                        _[P] = ne; return !0; }, deleteProperty: function (_, P) { return typeof P == "number" ? _.deleteAt(P) : delete _[P], !0; } }), N; }
                var ut = function () { function N() { for (var _ = [], P = 0; P < arguments.length; P++)
                    _[P] = arguments[P]; this.$changes = new we(this), this.$items = new Map, this.$indexes = new Map, this.$refId = 0, this.push.apply(this, _); } return N.prototype.onAdd = function (_, P) { return P === void 0 && (P = !0), Ke(this.$callbacks || (this.$callbacks = []), $.OPERATION.ADD, _, P ? this.$items : void 0); }, N.prototype.onRemove = function (_) { return Ke(this.$callbacks || (this.$callbacks = []), $.OPERATION.DELETE, _); }, N.prototype.onChange = function (_) { return Ke(this.$callbacks || (this.$callbacks = []), $.OPERATION.REPLACE, _); }, N.is = function (_) { return Array.isArray(_) || _.array !== void 0; }, Object.defineProperty(N.prototype, "length", { get: function () { return this.$items.size; }, set: function (_) { _ === 0 ? this.clear() : this.splice(_, this.length - _); }, enumerable: !1, configurable: !0 }), N.prototype.push = function () { for (var _ = this, P = [], ne = 0; ne < arguments.length; ne++)
                    P[ne] = arguments[ne]; var xe; return P.forEach(function (Ze) { xe = _.$refId++, _.setAt(xe, Ze); }), xe; }, N.prototype.pop = function () { var _ = Array.from(this.$indexes.values()).pop(); if (_ !== void 0) {
                    this.$changes.delete(_), this.$indexes.delete(_);
                    var P = this.$items.get(_);
                    return this.$items.delete(_), P;
                } }, N.prototype.at = function (_) { var P = Array.from(this.$items.keys())[_]; return this.$items.get(P); }, N.prototype.setAt = function (_, P) { var ne, xe; P.$changes !== void 0 && P.$changes.setParent(this, this.$changes.root, _); var Ze = (xe = (ne = this.$changes.indexes[_]) === null || ne === void 0 ? void 0 : ne.op) !== null && xe !== void 0 ? xe : $.OPERATION.ADD; this.$changes.indexes[_] = _, this.$indexes.set(_, _), this.$items.set(_, P), this.$changes.change(_, Ze); }, N.prototype.deleteAt = function (_) { var P = Array.from(this.$items.keys())[_]; return P === void 0 ? !1 : this.$deleteAt(P); }, N.prototype.$deleteAt = function (_) { return this.$changes.delete(_), this.$indexes.delete(_), this.$items.delete(_); }, N.prototype.clear = function (_) { this.$changes.discard(!0, !0), this.$changes.indexes = {}, this.$indexes.clear(), _ && rt.call(this, _), this.$items.clear(), this.$changes.operation({ index: 0, op: $.OPERATION.CLEAR }), this.$changes.touchParents(); }, N.prototype.concat = function () { for (var _, P = [], ne = 0; ne < arguments.length; ne++)
                    P[ne] = arguments[ne]; return new (N.bind.apply(N, de([void 0], (_ = Array.from(this.$items.values())).concat.apply(_, P), !1))); }, N.prototype.join = function (_) { return Array.from(this.$items.values()).join(_); }, N.prototype.reverse = function () { var _ = this, P = Array.from(this.$items.keys()), ne = Array.from(this.$items.values()).reverse(); return ne.forEach(function (xe, Ze) { _.setAt(P[Ze], xe); }), this; }, N.prototype.shift = function () { var _ = Array.from(this.$items.keys()), P = _.shift(); if (P !== void 0) {
                    var ne = this.$items.get(P);
                    return this.$deleteAt(P), ne;
                } }, N.prototype.slice = function (_, P) { var ne = new N; return ne.push.apply(ne, Array.from(this.$items.values()).slice(_, P)), ne; }, N.prototype.sort = function (_) { var P = this; _ === void 0 && (_ = ze); var ne = Array.from(this.$items.keys()), xe = Array.from(this.$items.values()).sort(_); return xe.forEach(function (Ze, mt) { P.setAt(ne[mt], Ze); }), this; }, N.prototype.splice = function (_, P) { P === void 0 && (P = this.length - _); for (var ne = Array.from(this.$items.keys()), xe = [], Ze = _; Ze < _ + P; Ze++)
                    xe.push(this.$items.get(ne[Ze])), this.$deleteAt(ne[Ze]); return xe; }, N.prototype.unshift = function () { for (var _ = this, P = [], ne = 0; ne < arguments.length; ne++)
                    P[ne] = arguments[ne]; var xe = this.length, Ze = P.length, mt = Array.from(this.$items.values()); return P.forEach(function (xt, Ut) { _.setAt(Ut, xt); }), mt.forEach(function (xt, Ut) { _.setAt(Ze + Ut, xt); }), xe + Ze; }, N.prototype.indexOf = function (_, P) { return Array.from(this.$items.values()).indexOf(_, P); }, N.prototype.lastIndexOf = function (_, P) { return P === void 0 && (P = this.length - 1), Array.from(this.$items.values()).lastIndexOf(_, P); }, N.prototype.every = function (_, P) { return Array.from(this.$items.values()).every(_, P); }, N.prototype.some = function (_, P) { return Array.from(this.$items.values()).some(_, P); }, N.prototype.forEach = function (_, P) { Array.from(this.$items.values()).forEach(_, P); }, N.prototype.map = function (_, P) { return Array.from(this.$items.values()).map(_, P); }, N.prototype.filter = function (_, P) { return Array.from(this.$items.values()).filter(_, P); }, N.prototype.reduce = function (_, P) { return Array.prototype.reduce.apply(Array.from(this.$items.values()), arguments); }, N.prototype.reduceRight = function (_, P) { return Array.prototype.reduceRight.apply(Array.from(this.$items.values()), arguments); }, N.prototype.find = function (_, P) { return Array.from(this.$items.values()).find(_, P); }, N.prototype.findIndex = function (_, P) { return Array.from(this.$items.values()).findIndex(_, P); }, N.prototype.fill = function (_, P, ne) { throw new Error("ArraySchema#fill() not implemented"); }, N.prototype.copyWithin = function (_, P, ne) { throw new Error("ArraySchema#copyWithin() not implemented"); }, N.prototype.toString = function () { return this.$items.toString(); }, N.prototype.toLocaleString = function () { return this.$items.toLocaleString(); }, N.prototype[Symbol.iterator] = function () { return Array.from(this.$items.values())[Symbol.iterator](); }, N.prototype.entries = function () { return this.$items.entries(); }, N.prototype.keys = function () { return this.$items.keys(); }, N.prototype.values = function () { return this.$items.values(); }, N.prototype.includes = function (_, P) { return Array.from(this.$items.values()).includes(_, P); }, N.prototype.flatMap = function (_, P) { throw new Error("ArraySchema#flatMap() is not supported."); }, N.prototype.flat = function (_) { throw new Error("ArraySchema#flat() is not supported."); }, N.prototype.findLast = function () { var _ = Array.from(this.$items.values()); return _.findLast.apply(_, arguments); }, N.prototype.findLastIndex = function () { var _ = Array.from(this.$items.values()); return _.findLastIndex.apply(_, arguments); }, N.prototype.setIndex = function (_, P) { this.$indexes.set(_, P); }, N.prototype.getIndex = function (_) { return this.$indexes.get(_); }, N.prototype.getByIndex = function (_) { return this.$items.get(this.$indexes.get(_)); }, N.prototype.deleteByIndex = function (_) { var P = this.$indexes.get(_); this.$items.delete(P), this.$indexes.delete(_); }, N.prototype.toArray = function () { return Array.from(this.$items.values()); }, N.prototype.toJSON = function () { return this.toArray().map(function (_) { return typeof _.toJSON == "function" ? _.toJSON() : _; }); }, N.prototype.clone = function (_) { var P; return _ ? P = new (N.bind.apply(N, de([void 0], Array.from(this.$items.values()), !1))) : P = new (N.bind.apply(N, de([void 0], this.map(function (ne) { return ne.$changes ? ne.clone() : ne; }), !1))), P; }, N; }();
                function rn(N) { return N.$proxy = !0, N = new Proxy(N, { get: function (_, P) { return typeof P != "symbol" && typeof _[P] > "u" ? _.get(P) : _[P]; }, set: function (_, P, ne) { return typeof P != "symbol" && P.indexOf("$") === -1 && P !== "onAdd" && P !== "onRemove" && P !== "onChange" ? _.set(P, ne) : _[P] = ne, !0; }, deleteProperty: function (_, P) { return _.delete(P), !0; } }), N; }
                var Rt = function () { function N(_) { var P = this; if (this.$changes = new we(this), this.$items = new Map, this.$indexes = new Map, this.$refId = 0, _)
                    if (_ instanceof Map || _ instanceof N)
                        _.forEach(function (xe, Ze) { return P.set(Ze, xe); });
                    else
                        for (var ne in _)
                            this.set(ne, _[ne]); } return N.prototype.onAdd = function (_, P) { return P === void 0 && (P = !0), Ke(this.$callbacks || (this.$callbacks = []), $.OPERATION.ADD, _, P ? this.$items : void 0); }, N.prototype.onRemove = function (_) { return Ke(this.$callbacks || (this.$callbacks = []), $.OPERATION.DELETE, _); }, N.prototype.onChange = function (_) { return Ke(this.$callbacks || (this.$callbacks = []), $.OPERATION.REPLACE, _); }, N.is = function (_) { return _.map !== void 0; }, N.prototype[Symbol.iterator] = function () { return this.$items[Symbol.iterator](); }, Object.defineProperty(N.prototype, Symbol.toStringTag, { get: function () { return this.$items[Symbol.toStringTag]; }, enumerable: !1, configurable: !0 }), N.prototype.set = function (_, P) { if (P == null)
                    throw new Error("MapSchema#set('".concat(_, "', ").concat(P, "): trying to set ").concat(P, " value on '").concat(_, "'.")); var ne = typeof this.$changes.indexes[_] < "u", xe = ne ? this.$changes.indexes[_] : this.$refId++, Ze = ne ? $.OPERATION.REPLACE : $.OPERATION.ADD, mt = P.$changes !== void 0; return mt && P.$changes.setParent(this, this.$changes.root, xe), ne ? mt && this.$items.get(_) !== P && (Ze = $.OPERATION.ADD) : (this.$changes.indexes[_] = xe, this.$indexes.set(xe, _)), this.$items.set(_, P), this.$changes.change(_, Ze), this; }, N.prototype.get = function (_) { return this.$items.get(_); }, N.prototype.delete = function (_) { return this.$changes.delete(_), this.$items.delete(_); }, N.prototype.clear = function (_) { this.$changes.discard(!0, !0), this.$changes.indexes = {}, this.$indexes.clear(), _ && rt.call(this, _), this.$items.clear(), this.$changes.operation({ index: 0, op: $.OPERATION.CLEAR }), this.$changes.touchParents(); }, N.prototype.has = function (_) { return this.$items.has(_); }, N.prototype.forEach = function (_) { this.$items.forEach(_); }, N.prototype.entries = function () { return this.$items.entries(); }, N.prototype.keys = function () { return this.$items.keys(); }, N.prototype.values = function () { return this.$items.values(); }, Object.defineProperty(N.prototype, "size", { get: function () { return this.$items.size; }, enumerable: !1, configurable: !0 }), N.prototype.setIndex = function (_, P) { this.$indexes.set(_, P); }, N.prototype.getIndex = function (_) { return this.$indexes.get(_); }, N.prototype.getByIndex = function (_) { return this.$items.get(this.$indexes.get(_)); }, N.prototype.deleteByIndex = function (_) { var P = this.$indexes.get(_); this.$items.delete(P), this.$indexes.delete(_); }, N.prototype.toJSON = function () { var _ = {}; return this.forEach(function (P, ne) { _[ne] = typeof P.toJSON == "function" ? P.toJSON() : P; }), _; }, N.prototype.clone = function (_) { var P; return _ ? P = Object.assign(new N, this) : (P = new N, this.forEach(function (ne, xe) { ne.$changes ? P.set(xe, ne.clone()) : P.set(xe, ne); })), P; }, N; }(), Le = {};
                function ot(N, _) { Le[N] = _; }
                function wt(N) { return Le[N]; }
                var zt = function () { function N() { this.indexes = {}, this.fieldsByIndex = {}, this.deprecated = {}, this.descriptors = {}; } return N.create = function (_) { var P = new N; return P.schema = Object.assign({}, _ && _.schema || {}), P.indexes = Object.assign({}, _ && _.indexes || {}), P.fieldsByIndex = Object.assign({}, _ && _.fieldsByIndex || {}), P.descriptors = Object.assign({}, _ && _.descriptors || {}), P.deprecated = Object.assign({}, _ && _.deprecated || {}), P; }, N.prototype.addField = function (_, P) { var ne = this.getNextFieldIndex(); this.fieldsByIndex[ne] = _, this.indexes[_] = ne, this.schema[_] = Array.isArray(P) ? { array: P[0] } : P; }, N.prototype.hasField = function (_) { return this.indexes[_] !== void 0; }, N.prototype.addFilter = function (_, P) { return this.filters || (this.filters = {}, this.indexesWithFilters = []), this.filters[this.indexes[_]] = P, this.indexesWithFilters.push(this.indexes[_]), !0; }, N.prototype.addChildrenFilter = function (_, P) { var ne = this.indexes[_], xe = this.schema[_]; if (wt(Object.keys(xe)[0]))
                    return this.childFilters || (this.childFilters = {}), this.childFilters[ne] = P, !0; console.warn("@filterChildren: field '".concat(_, "' can't have children. Ignoring filter.")); }, N.prototype.getChildrenFilter = function (_) { return this.childFilters && this.childFilters[this.indexes[_]]; }, N.prototype.getNextFieldIndex = function () { return Object.keys(this.schema || {}).length; }, N; }();
                function Qn(N) { return N._context && N._context.useFilters; }
                var Mn = function () { function N() { this.types = {}, this.schemas = new Map, this.useFilters = !1; } return N.prototype.has = function (_) { return this.schemas.has(_); }, N.prototype.get = function (_) { return this.types[_]; }, N.prototype.add = function (_, P) { P === void 0 && (P = this.schemas.size), _._definition = zt.create(_._definition), _._typeid = P, this.types[P] = _, this.schemas.set(_, P); }, N.create = function (_) { return _ === void 0 && (_ = {}), function (P) { return _.context || (_.context = new N), cn(P, _); }; }, N; }(), Ir = new Mn;
                function cn(N, _) {
                    return _ === void 0 && (_ = {}), function (P, ne) {
                        var xe = _.context || Ir, Ze = P.constructor;
                        if (Ze._context = xe, !N)
                            throw new Error("".concat(Ze.name, ': @type() reference provided for "').concat(ne, `" is undefined. Make sure you don't have any circular dependencies.`));
                        xe.has(Ze) || xe.add(Ze);
                        var mt = Ze._definition;
                        if (mt.addField(ne, N), mt.descriptors[ne]) {
                            if (mt.deprecated[ne])
                                return;
                            try {
                                throw new Error("@colyseus/schema: Duplicate '".concat(ne, "' definition on '").concat(Ze.name, `'.
Check @type() annotation`));
                            }
                            catch ($t) {
                                var xt = $t.stack.split(`
`)[4].trim();
                                throw new Error("".concat($t.message, " ").concat(xt));
                            }
                        }
                        var Ut = ut.is(N), Ft = !Ut && Rt.is(N);
                        if (typeof N != "string" && !go.is(N)) {
                            var _t = Object.values(N)[0];
                            typeof _t != "string" && !xe.has(_t) && xe.add(_t);
                        }
                        if (_.manual) {
                            mt.descriptors[ne] = { enumerable: !0, configurable: !0, writable: !0 };
                            return;
                        }
                        var qt = "_".concat(ne);
                        mt.descriptors[qt] = { enumerable: !1, configurable: !1, writable: !0 }, mt.descriptors[ne] = { get: function () { return this[qt]; }, set: function ($t) { $t !== this[qt] && ($t != null ? (Ut && !($t instanceof ut) && ($t = new (ut.bind.apply(ut, de([void 0], $t, !1)))), Ft && !($t instanceof Rt) && ($t = new Rt($t)), $t.$proxy === void 0 && (Ft ? $t = rn($t) : Ut && ($t = We($t))), this.$changes.change(ne), $t.$changes && $t.$changes.setParent(this, this.$changes.root, this._definition.indexes[ne])) : this[qt] && this.$changes.delete(ne), this[qt] = $t); }, enumerable: !0, configurable: !0 };
                    };
                }
                function ir(N) { return function (_, P) { var ne = _.constructor, xe = ne._definition; xe.addFilter(P, N) && (ne._context.useFilters = !0); }; }
                function NS(N) { return function (_, P) { var ne = _.constructor, xe = ne._definition; xe.addChildrenFilter(P, N) && (ne._context.useFilters = !0); }; }
                function PS(N) { return N === void 0 && (N = !0), function (_, P) { var ne = _.constructor, xe = ne._definition; xe.deprecated[P] = !0, N && (xe.descriptors[P] = { get: function () { throw new Error("".concat(P, " is deprecated.")); }, set: function (Ze) { }, enumerable: !1, configurable: !0 }); }; }
                function RS(N, _, P) { P === void 0 && (P = {}), P.context || (P.context = N._context || P.context || Ir); for (var ne in _)
                    cn(_[ne], P)(N.prototype, ne); return N; }
                function LS(N) { for (var _ = 0, P = 0, ne = 0, xe = N.length; ne < xe; ne++)
                    _ = N.charCodeAt(ne), _ < 128 ? P += 1 : _ < 2048 ? P += 2 : _ < 55296 || _ >= 57344 ? P += 3 : (ne++, P += 4); return P; }
                function vv(N, _, P) { for (var ne = 0, xe = 0, Ze = P.length; xe < Ze; xe++)
                    ne = P.charCodeAt(xe), ne < 128 ? N[_++] = ne : ne < 2048 ? (N[_++] = 192 | ne >> 6, N[_++] = 128 | ne & 63) : ne < 55296 || ne >= 57344 ? (N[_++] = 224 | ne >> 12, N[_++] = 128 | ne >> 6 & 63, N[_++] = 128 | ne & 63) : (xe++, ne = 65536 + ((ne & 1023) << 10 | P.charCodeAt(xe) & 1023), N[_++] = 240 | ne >> 18, N[_++] = 128 | ne >> 12 & 63, N[_++] = 128 | ne >> 6 & 63, N[_++] = 128 | ne & 63); }
                function mv(N, _) { N.push(_ & 255); }
                function zn(N, _) { N.push(_ & 255); }
                function gv(N, _) { N.push(_ & 255), N.push(_ >> 8 & 255); }
                function Gc(N, _) { N.push(_ & 255), N.push(_ >> 8 & 255); }
                function Zl(N, _) { N.push(_ & 255), N.push(_ >> 8 & 255), N.push(_ >> 16 & 255), N.push(_ >> 24 & 255); }
                function cs(N, _) { var P = _ >> 24, ne = _ >> 16, xe = _ >> 8, Ze = _; N.push(Ze & 255), N.push(xe & 255), N.push(ne & 255), N.push(P & 255); }
                function yv(N, _) { var P = Math.floor(_ / Math.pow(2, 32)), ne = _ >>> 0; cs(N, ne), cs(N, P); }
                function bv(N, _) { var P = _ / Math.pow(2, 32) >> 0, ne = _ >>> 0; cs(N, ne), cs(N, P); }
                function DS(N, _) { wv(N, _); }
                function BS(N, _) { Xc(N, _); }
                var Ql = new Int32Array(2), FS = new Float32Array(Ql.buffer), VS = new Float64Array(Ql.buffer);
                function wv(N, _) { FS[0] = _, Zl(N, Ql[0]); }
                function Xc(N, _) { VS[0] = _, Zl(N, Ql[0]), Zl(N, Ql[1]); }
                function zS(N, _) { return zn(N, _ ? 1 : 0); }
                function xi(N, _) { _ || (_ = ""); var P = LS(_), ne = 0; if (P < 32)
                    N.push(P | 160), ne = 1;
                else if (P < 256)
                    N.push(217), zn(N, P), ne = 2;
                else if (P < 65536)
                    N.push(218), Gc(N, P), ne = 3;
                else if (P < 4294967296)
                    N.push(219), cs(N, P), ne = 5;
                else
                    throw new Error("String too long"); return vv(N, N.length, _), ne + P; }
                function eo(N, _) { if (isNaN(_))
                    return eo(N, 0); if (isFinite(_)) {
                    if (_ !== (_ | 0))
                        return N.push(203), Xc(N, _), 9;
                }
                else
                    return eo(N, _ > 0 ? Number.MAX_SAFE_INTEGER : -Number.MAX_SAFE_INTEGER); return _ >= 0 ? _ < 128 ? (zn(N, _), 1) : _ < 256 ? (N.push(204), zn(N, _), 2) : _ < 65536 ? (N.push(205), Gc(N, _), 3) : _ < 4294967296 ? (N.push(206), cs(N, _), 5) : (N.push(207), bv(N, _), 9) : _ >= -32 ? (N.push(224 | _ + 32), 1) : _ >= -128 ? (N.push(208), mv(N, _), 2) : _ >= -32768 ? (N.push(209), gv(N, _), 3) : _ >= -2147483648 ? (N.push(210), Zl(N, _), 5) : (N.push(211), yv(N, _), 9); }
                var Jc = Object.freeze({ __proto__: null, utf8Write: vv, int8: mv, uint8: zn, int16: gv, uint16: Gc, int32: Zl, uint32: cs, int64: yv, uint64: bv, float32: DS, float64: BS, writeFloat32: wv, writeFloat64: Xc, boolean: zS, string: xi, number: eo });
                function HS(N, _, P) { for (var ne = "", xe = 0, Ze = _, mt = _ + P; Ze < mt; Ze++) {
                    var xt = N[Ze];
                    if (!(xt & 128)) {
                        ne += String.fromCharCode(xt);
                        continue;
                    }
                    if ((xt & 224) === 192) {
                        ne += String.fromCharCode((xt & 31) << 6 | N[++Ze] & 63);
                        continue;
                    }
                    if ((xt & 240) === 224) {
                        ne += String.fromCharCode((xt & 15) << 12 | (N[++Ze] & 63) << 6 | (N[++Ze] & 63) << 0);
                        continue;
                    }
                    if ((xt & 248) === 240) {
                        xe = (xt & 7) << 18 | (N[++Ze] & 63) << 12 | (N[++Ze] & 63) << 6 | (N[++Ze] & 63) << 0, xe >= 65536 ? (xe -= 65536, ne += String.fromCharCode((xe >>> 10) + 55296, (xe & 1023) + 56320)) : ne += String.fromCharCode(xe);
                        continue;
                    }
                    console.error("Invalid byte " + xt.toString(16));
                } return ne; }
                function Cv(N, _) { return ea(N, _) << 24 >> 24; }
                function ea(N, _) { return N[_.offset++]; }
                function Sv(N, _) { return Ai(N, _) << 16 >> 16; }
                function Ai(N, _) { return N[_.offset++] | N[_.offset++] << 8; }
                function ds(N, _) { return N[_.offset++] | N[_.offset++] << 8 | N[_.offset++] << 16 | N[_.offset++] << 24; }
                function Xs(N, _) { return ds(N, _) >>> 0; }
                function KS(N, _) { return Zc(N, _); }
                function jS(N, _) { return Qc(N, _); }
                function _v(N, _) { var P = Xs(N, _), ne = ds(N, _) * Math.pow(2, 32); return ne + P; }
                function kv(N, _) { var P = Xs(N, _), ne = Xs(N, _) * Math.pow(2, 32); return ne + P; }
                var ta = new Int32Array(2), WS = new Float32Array(ta.buffer), US = new Float64Array(ta.buffer);
                function Zc(N, _) { return ta[0] = ds(N, _), WS[0]; }
                function Qc(N, _) { return ta[0] = ds(N, _), ta[1] = ds(N, _), US[0]; }
                function qS(N, _) { return ea(N, _) > 0; }
                function Ev(N, _) { var P = N[_.offset++], ne; P < 192 ? ne = P & 31 : P === 217 ? ne = ea(N, _) : P === 218 ? ne = Ai(N, _) : P === 219 && (ne = Xs(N, _)); var xe = HS(N, _.offset, ne); return _.offset += ne, xe; }
                function YS(N, _) { var P = N[_.offset]; return P < 192 && P > 160 || P === 217 || P === 218 || P === 219; }
                function fs(N, _) { var P = N[_.offset++]; if (P < 128)
                    return P; if (P === 202)
                    return Zc(N, _); if (P === 203)
                    return Qc(N, _); if (P === 204)
                    return ea(N, _); if (P === 205)
                    return Ai(N, _); if (P === 206)
                    return Xs(N, _); if (P === 207)
                    return kv(N, _); if (P === 208)
                    return Cv(N, _); if (P === 209)
                    return Sv(N, _); if (P === 210)
                    return ds(N, _); if (P === 211)
                    return _v(N, _); if (P > 223)
                    return (255 - P + 1) * -1; }
                function GS(N, _) { var P = N[_.offset]; return P < 128 || P >= 202 && P <= 211; }
                function XS(N, _) { return N[_.offset] < 160; }
                function $v(N, _) { return N[_.offset - 1] === be && (N[_.offset] < 128 || N[_.offset] >= 202 && N[_.offset] <= 211); }
                var Tv = Object.freeze({ __proto__: null, int8: Cv, uint8: ea, int16: Sv, uint16: Ai, int32: ds, uint32: Xs, float32: KS, float64: jS, int64: _v, uint64: kv, readFloat32: Zc, readFloat64: Qc, boolean: qS, string: Ev, stringCheck: YS, number: fs, numberCheck: GS, arrayCheck: XS, switchStructureCheck: $v }), ed = function () { function N(_) { var P = this; this.$changes = new we(this), this.$items = new Map, this.$indexes = new Map, this.$refId = 0, _ && _.forEach(function (ne) { return P.add(ne); }); } return N.prototype.onAdd = function (_, P) { return P === void 0 && (P = !0), Ke(this.$callbacks || (this.$callbacks = []), $.OPERATION.ADD, _, P ? this.$items : void 0); }, N.prototype.onRemove = function (_) { return Ke(this.$callbacks || (this.$callbacks = []), $.OPERATION.DELETE, _); }, N.prototype.onChange = function (_) { return Ke(this.$callbacks || (this.$callbacks = []), $.OPERATION.REPLACE, _); }, N.is = function (_) { return _.collection !== void 0; }, N.prototype.add = function (_) { var P = this.$refId++, ne = _.$changes !== void 0; return ne && _.$changes.setParent(this, this.$changes.root, P), this.$changes.indexes[P] = P, this.$indexes.set(P, P), this.$items.set(P, _), this.$changes.change(P), P; }, N.prototype.at = function (_) { var P = Array.from(this.$items.keys())[_]; return this.$items.get(P); }, N.prototype.entries = function () { return this.$items.entries(); }, N.prototype.delete = function (_) { for (var P = this.$items.entries(), ne, xe; (xe = P.next()) && !xe.done;)
                    if (_ === xe.value[1]) {
                        ne = xe.value[0];
                        break;
                    } return ne === void 0 ? !1 : (this.$changes.delete(ne), this.$indexes.delete(ne), this.$items.delete(ne)); }, N.prototype.clear = function (_) { this.$changes.discard(!0, !0), this.$changes.indexes = {}, this.$indexes.clear(), _ && rt.call(this, _), this.$items.clear(), this.$changes.operation({ index: 0, op: $.OPERATION.CLEAR }), this.$changes.touchParents(); }, N.prototype.has = function (_) { return Array.from(this.$items.values()).some(function (P) { return P === _; }); }, N.prototype.forEach = function (_) { var P = this; this.$items.forEach(function (ne, xe, Ze) { return _(ne, xe, P); }); }, N.prototype.values = function () { return this.$items.values(); }, Object.defineProperty(N.prototype, "size", { get: function () { return this.$items.size; }, enumerable: !1, configurable: !0 }), N.prototype.setIndex = function (_, P) { this.$indexes.set(_, P); }, N.prototype.getIndex = function (_) { return this.$indexes.get(_); }, N.prototype.getByIndex = function (_) { return this.$items.get(this.$indexes.get(_)); }, N.prototype.deleteByIndex = function (_) { var P = this.$indexes.get(_); this.$items.delete(P), this.$indexes.delete(_); }, N.prototype.toArray = function () { return Array.from(this.$items.values()); }, N.prototype.toJSON = function () { var _ = []; return this.forEach(function (P, ne) { _.push(typeof P.toJSON == "function" ? P.toJSON() : P); }), _; }, N.prototype.clone = function (_) { var P; return _ ? P = Object.assign(new N, this) : (P = new N, this.forEach(function (ne) { ne.$changes ? P.add(ne.clone()) : P.add(ne); })), P; }, N; }(), td = function () { function N(_) { var P = this; this.$changes = new we(this), this.$items = new Map, this.$indexes = new Map, this.$refId = 0, _ && _.forEach(function (ne) { return P.add(ne); }); } return N.prototype.onAdd = function (_, P) { return P === void 0 && (P = !0), Ke(this.$callbacks || (this.$callbacks = []), $.OPERATION.ADD, _, P ? this.$items : void 0); }, N.prototype.onRemove = function (_) { return Ke(this.$callbacks || (this.$callbacks = []), $.OPERATION.DELETE, _); }, N.prototype.onChange = function (_) { return Ke(this.$callbacks || (this.$callbacks = []), $.OPERATION.REPLACE, _); }, N.is = function (_) { return _.set !== void 0; }, N.prototype.add = function (_) { var P, ne; if (this.has(_))
                    return !1; var xe = this.$refId++; _.$changes !== void 0 && _.$changes.setParent(this, this.$changes.root, xe); var Ze = (ne = (P = this.$changes.indexes[xe]) === null || P === void 0 ? void 0 : P.op) !== null && ne !== void 0 ? ne : $.OPERATION.ADD; return this.$changes.indexes[xe] = xe, this.$indexes.set(xe, xe), this.$items.set(xe, _), this.$changes.change(xe, Ze), xe; }, N.prototype.entries = function () { return this.$items.entries(); }, N.prototype.delete = function (_) { for (var P = this.$items.entries(), ne, xe; (xe = P.next()) && !xe.done;)
                    if (_ === xe.value[1]) {
                        ne = xe.value[0];
                        break;
                    } return ne === void 0 ? !1 : (this.$changes.delete(ne), this.$indexes.delete(ne), this.$items.delete(ne)); }, N.prototype.clear = function (_) { this.$changes.discard(!0, !0), this.$changes.indexes = {}, this.$indexes.clear(), _ && rt.call(this, _), this.$items.clear(), this.$changes.operation({ index: 0, op: $.OPERATION.CLEAR }), this.$changes.touchParents(); }, N.prototype.has = function (_) { for (var P = this.$items.values(), ne = !1, xe; (xe = P.next()) && !xe.done;)
                    if (_ === xe.value) {
                        ne = !0;
                        break;
                    } return ne; }, N.prototype.forEach = function (_) { var P = this; this.$items.forEach(function (ne, xe, Ze) { return _(ne, xe, P); }); }, N.prototype.values = function () { return this.$items.values(); }, Object.defineProperty(N.prototype, "size", { get: function () { return this.$items.size; }, enumerable: !1, configurable: !0 }), N.prototype.setIndex = function (_, P) { this.$indexes.set(_, P); }, N.prototype.getIndex = function (_) { return this.$indexes.get(_); }, N.prototype.getByIndex = function (_) { return this.$items.get(this.$indexes.get(_)); }, N.prototype.deleteByIndex = function (_) { var P = this.$indexes.get(_); this.$items.delete(P), this.$indexes.delete(_); }, N.prototype.toArray = function () { return Array.from(this.$items.values()); }, N.prototype.toJSON = function () { var _ = []; return this.forEach(function (P, ne) { _.push(typeof P.toJSON == "function" ? P.toJSON() : P); }), _; }, N.prototype.clone = function (_) { var P; return _ ? P = Object.assign(new N, this) : (P = new N, this.forEach(function (ne) { ne.$changes ? P.add(ne.clone()) : P.add(ne); })), P; }, N; }(), JS = function () { function N() { this.refIds = new WeakSet, this.containerIndexes = new WeakMap; } return N.prototype.addRefId = function (_) { this.refIds.has(_) || (this.refIds.add(_), this.containerIndexes.set(_, new Set)); }, N.get = function (_) { return _.$filterState === void 0 && (_.$filterState = new N), _.$filterState; }, N; }(), ZS = function () { function N() { this.refs = new Map, this.refCounts = {}, this.deletedRefs = new Set, this.nextUniqueId = 0; } return N.prototype.getNextUniqueId = function () { return this.nextUniqueId++; }, N.prototype.addRef = function (_, P, ne) { ne === void 0 && (ne = !0), this.refs.set(_, P), ne && (this.refCounts[_] = (this.refCounts[_] || 0) + 1); }, N.prototype.removeRef = function (_) { this.refCounts[_] = this.refCounts[_] - 1, this.deletedRefs.add(_); }, N.prototype.clearRefs = function () { this.refs.clear(), this.deletedRefs.clear(), this.refCounts = {}; }, N.prototype.garbageCollectDeletedRefs = function () { var _ = this; this.deletedRefs.forEach(function (P) { if (!(_.refCounts[P] > 0)) {
                    var ne = _.refs.get(P);
                    if (ne instanceof go)
                        for (var xe in ne._definition.schema)
                            typeof ne._definition.schema[xe] != "string" && ne[xe] && ne[xe].$changes && _.removeRef(ne[xe].$changes.refId);
                    else {
                        var Ze = ne.$changes.parent._definition, mt = Ze.schema[Ze.fieldsByIndex[ne.$changes.parentIndex]];
                        typeof Object.values(mt)[0] == "function" && Array.from(ne.values()).forEach(function (xt) { return _.removeRef(xt.$changes.refId); });
                    }
                    _.refs.delete(P), delete _.refCounts[P];
                } }), this.deletedRefs.clear(); }, N; }(), nd = function (N) { H(_, N); function _() { return N !== null && N.apply(this, arguments) || this; } return _; }(Error);
                function QS(N, _, P, ne) { var xe, Ze = !1; switch (_) {
                    case "number":
                    case "int8":
                    case "uint8":
                    case "int16":
                    case "uint16":
                    case "int32":
                    case "uint32":
                    case "int64":
                    case "uint64":
                    case "float32":
                    case "float64":
                        xe = "number", isNaN(N) && console.log('trying to encode "NaN" in '.concat(P.constructor.name, "#").concat(ne));
                        break;
                    case "string":
                        xe = "string", Ze = !0;
                        break;
                    case "boolean": return;
                } if (typeof N !== xe && (!Ze || Ze && N !== null)) {
                    var mt = "'".concat(JSON.stringify(N), "'").concat(N && N.constructor && " (".concat(N.constructor.name, ")") || "");
                    throw new nd("a '".concat(xe, "' was expected, but ").concat(mt, " was provided in ").concat(P.constructor.name, "#").concat(ne));
                } }
                function Ov(N, _, P, ne) { if (!(N instanceof _))
                    throw new nd("a '".concat(_.name, "' was expected, but '").concat(N.constructor.name, "' was provided in ").concat(P.constructor.name, "#").concat(ne)); }
                function e_(N, _, P, ne, xe) { QS(P, N, ne, xe); var Ze = Jc[N]; if (Ze)
                    Ze(_, P);
                else
                    throw new nd("a '".concat(N, "' was expected, but ").concat(P, " was provided in ").concat(ne.constructor.name, "#").concat(xe)); }
                function t_(N, _, P) { return Tv[N](_, P); }
                var go = function () { function N() { for (var _ = [], P = 0; P < arguments.length; P++)
                    _[P] = arguments[P]; Object.defineProperties(this, { $changes: { value: new we(this, void 0, new ZS), enumerable: !1, writable: !0 }, $callbacks: { value: void 0, enumerable: !1, writable: !0 } }); var ne = this._definition.descriptors; ne && Object.defineProperties(this, ne), _[0] && this.assign(_[0]); } return N.onError = function (_) { console.error(_); }, N.is = function (_) { return _._definition && _._definition.schema !== void 0; }, N.prototype.onChange = function (_) { return Ke(this.$callbacks || (this.$callbacks = []), $.OPERATION.REPLACE, _); }, N.prototype.onRemove = function (_) { return Ke(this.$callbacks || (this.$callbacks = []), $.OPERATION.DELETE, _); }, N.prototype.assign = function (_) { return Object.assign(this, _), this; }, Object.defineProperty(N.prototype, "_definition", { get: function () { return this.constructor._definition; }, enumerable: !1, configurable: !0 }), N.prototype.setDirty = function (_, P) { this.$changes.change(_, P); }, N.prototype.listen = function (_, P, ne) { var xe = this; return ne === void 0 && (ne = !0), this.$callbacks || (this.$callbacks = {}), this.$callbacks[_] || (this.$callbacks[_] = []), this.$callbacks[_].push(P), ne && this[_] !== void 0 && P(this[_], void 0), function () { return _e(xe.$callbacks[_], xe.$callbacks[_].indexOf(P)); }; }, N.prototype.decode = function (_, P, ne) { var xe; P === void 0 && (P = { offset: 0 }), ne === void 0 && (ne = this); var Ze = [], mt = this.$changes.root, xt = _.length, Ut = 0; for (mt.refs.set(Ut, this); P.offset < xt;) {
                    var Ft = _[P.offset++];
                    if (Ft == be) {
                        Ut = fs(_, P);
                        var _t = mt.refs.get(Ut);
                        if (!_t)
                            throw new Error('"refId" not found: '.concat(Ut));
                        ne = _t;
                        continue;
                    }
                    var qt = ne.$changes, $t = ne._definition !== void 0, Ht = $t ? Ft >> 6 << 6 : Ft;
                    if (Ht === $.OPERATION.CLEAR) {
                        ne.clear(Ze);
                        continue;
                    }
                    var It = $t ? Ft % (Ht || 255) : fs(_, P), Vt = $t ? ne._definition.fieldsByIndex[It] : "", bt = qt.getType(It), Kt = void 0, Qt = void 0, mn = void 0;
                    if ($t ? Qt = ne["_".concat(Vt)] : (Qt = ne.getByIndex(It), (Ht & $.OPERATION.ADD) === $.OPERATION.ADD ? (mn = ne instanceof Rt ? Ev(_, P) : It, ne.setIndex(It, mn)) : mn = ne.getIndex(It)), (Ht & $.OPERATION.DELETE) === $.OPERATION.DELETE && (Ht !== $.OPERATION.DELETE_AND_ADD && ne.deleteByIndex(It), Qt && Qt.$changes && mt.removeRef(Qt.$changes.refId), Kt = null), Vt === void 0) {
                        console.warn("@colyseus/schema: definition mismatch");
                        for (var Gt = { offset: P.offset }; P.offset < xt && !($v(_, P) && (Gt.offset = P.offset + 1, mt.refs.has(fs(_, Gt))));)
                            P.offset++;
                        continue;
                    }
                    else if (Ht !== $.OPERATION.DELETE)
                        if (N.is(bt)) {
                            var jt = fs(_, P);
                            if (Kt = mt.refs.get(jt), Ht !== $.OPERATION.REPLACE) {
                                var xr = this.getSchemaType(_, P, bt);
                                Kt || (Kt = this.createTypeInstance(xr), Kt.$changes.refId = jt, Qt && (Kt.$callbacks = Qt.$callbacks, Qt.$changes.refId && jt !== Qt.$changes.refId && mt.removeRef(Qt.$changes.refId))), mt.addRef(jt, Kt, Kt !== Qt);
                            }
                        }
                        else if (typeof bt == "string")
                            Kt = t_(bt, _, P);
                        else {
                            var sd = wt(Object.keys(bt)[0]), Hn = fs(_, P), Tn = mt.refs.has(Hn) ? Qt || mt.refs.get(Hn) : new sd.constructor;
                            if (Kt = Tn.clone(!0), Kt.$changes.refId = Hn, Qt && (Kt.$callbacks = Qt.$callbacks, Qt.$changes.refId && Hn !== Qt.$changes.refId)) {
                                mt.removeRef(Qt.$changes.refId);
                                for (var Nn = Qt.entries(), na = void 0; (na = Nn.next()) && !na.done;) {
                                    var ur = (xe = na.value, xe[0]), ld = xe[1];
                                    Ze.push({ refId: Hn, op: $.OPERATION.DELETE, field: ur, value: void 0, previousValue: ld });
                                }
                            }
                            mt.addRef(Hn, Kt, Tn !== Qt);
                        }
                    if (Kt != null) {
                        if (Kt.$changes && Kt.$changes.setParent(qt.ref, qt.root, It), ne instanceof N)
                            ne[Vt] = Kt;
                        else if (ne instanceof Rt) {
                            var ur = mn;
                            ne.$items.set(ur, Kt), ne.$changes.allChanges.add(It);
                        }
                        else if (ne instanceof ut)
                            ne.setAt(It, Kt);
                        else if (ne instanceof ed) {
                            var Ar = ne.add(Kt);
                            ne.setIndex(It, Ar);
                        }
                        else if (ne instanceof td) {
                            var Ar = ne.add(Kt);
                            Ar !== !1 && ne.setIndex(It, Ar);
                        }
                    }
                    Qt !== Kt && Ze.push({ refId: Ut, op: Ht, field: Vt, dynamicIndex: mn, value: Kt, previousValue: Qt });
                } return this._triggerChanges(Ze), mt.garbageCollectDeletedRefs(), Ze; }, N.prototype.encode = function (_, P, ne) { _ === void 0 && (_ = !1), P === void 0 && (P = []), ne === void 0 && (ne = !1); for (var xe = this.$changes, Ze = new WeakSet, mt = [xe], xt = 1, Ut = 0; Ut < xt; Ut++) {
                    var Ft = mt[Ut], _t = Ft.ref, qt = _t instanceof N;
                    Ft.ensureRefId(), Ze.add(Ft), Ft !== xe && (Ft.changed || _) && (zn(P, be), eo(P, Ft.refId));
                    for (var $t = _ ? Array.from(Ft.allChanges) : Array.from(Ft.changes.values()), Ht = 0, It = $t.length; Ht < It; Ht++) {
                        var Vt = _ ? { op: $.OPERATION.ADD, index: $t[Ht] } : $t[Ht], bt = Vt.index, Kt = qt ? _t._definition.fieldsByIndex && _t._definition.fieldsByIndex[bt] : bt, Qt = P.length;
                        if (Vt.op !== $.OPERATION.TOUCH)
                            if (qt)
                                zn(P, bt | Vt.op);
                            else {
                                if (zn(P, Vt.op), Vt.op === $.OPERATION.CLEAR)
                                    continue;
                                eo(P, bt);
                            }
                        if (!qt && (Vt.op & $.OPERATION.ADD) == $.OPERATION.ADD && _t instanceof Rt) {
                            var mn = Ft.ref.$indexes.get(bt);
                            xi(P, mn);
                        }
                        if (Vt.op !== $.OPERATION.DELETE) {
                            var Gt = Ft.getType(bt), jt = Ft.getValue(bt);
                            if (jt && jt.$changes && !Ze.has(jt.$changes) && (mt.push(jt.$changes), jt.$changes.ensureRefId(), xt++), Vt.op !== $.OPERATION.TOUCH) {
                                if (N.is(Gt))
                                    Ov(jt, Gt, _t, Kt), eo(P, jt.$changes.refId), (Vt.op & $.OPERATION.ADD) === $.OPERATION.ADD && this.tryEncodeTypeId(P, Gt, jt.constructor);
                                else if (typeof Gt == "string")
                                    e_(Gt, P, jt, _t, Kt);
                                else {
                                    var xr = wt(Object.keys(Gt)[0]);
                                    Ov(_t["_".concat(Kt)], xr.constructor, _t, Kt), eo(P, jt.$changes.refId);
                                }
                                ne && Ft.cache(bt, P.slice(Qt));
                            }
                        }
                    }
                    !_ && !ne && Ft.discard();
                } return P; }, N.prototype.encodeAll = function (_) { return this.encode(!0, [], _); }, N.prototype.applyFilters = function (_, P) { var ne, xe; P === void 0 && (P = !1); for (var Ze = this, mt = new Set, xt = JS.get(_), Ut = [this.$changes], Ft = 1, _t = [], qt = function (Ht) { var It = Ut[Ht]; if (mt.has(It.refId))
                    return "continue"; var Vt = It.ref, bt = Vt instanceof N; zn(_t, be), eo(_t, It.refId); var Kt = xt.refIds.has(It), Qt = P || !Kt; xt.addRefId(It); var mn = xt.containerIndexes.get(It), Gt = Qt ? Array.from(It.allChanges) : Array.from(It.changes.values()); if (!P && bt && Vt._definition.indexesWithFilters) {
                    var jt = Vt._definition.indexesWithFilters;
                    jt.forEach(function (Mi) { !mn.has(Mi) && It.allChanges.has(Mi) && (Qt ? Gt.push(Mi) : Gt.push({ op: $.OPERATION.ADD, index: Mi })); });
                } for (var xr = 0, sd = Gt.length; xr < sd; xr++) {
                    var Hn = Qt ? { op: $.OPERATION.ADD, index: Gt[xr] } : Gt[xr];
                    if (Hn.op === $.OPERATION.CLEAR) {
                        zn(_t, Hn.op);
                        continue;
                    }
                    var Tn = Hn.index;
                    if (Hn.op === $.OPERATION.DELETE) {
                        bt ? zn(_t, Hn.op | Tn) : (zn(_t, Hn.op), eo(_t, Tn));
                        continue;
                    }
                    var Nn = It.getValue(Tn), na = It.getType(Tn);
                    if (bt) {
                        var ur = Vt._definition.filters && Vt._definition.filters[Tn];
                        if (ur && !ur.call(Vt, _, Nn, Ze)) {
                            Nn && Nn.$changes && mt.add(Nn.$changes.refId);
                            continue;
                        }
                    }
                    else {
                        var ld = It.parent, ur = It.getChildrenFilter();
                        if (ur && !ur.call(ld, _, Vt.$indexes.get(Tn), Nn, Ze)) {
                            Nn && Nn.$changes && mt.add(Nn.$changes.refId);
                            continue;
                        }
                    }
                    if (Nn.$changes && (Ut.push(Nn.$changes), Ft++), Hn.op !== $.OPERATION.TOUCH)
                        if (Hn.op === $.OPERATION.ADD || bt)
                            _t.push.apply(_t, (ne = It.caches[Tn]) !== null && ne !== void 0 ? ne : []), mn.add(Tn);
                        else if (mn.has(Tn))
                            _t.push.apply(_t, (xe = It.caches[Tn]) !== null && xe !== void 0 ? xe : []);
                        else {
                            if (mn.add(Tn), zn(_t, $.OPERATION.ADD), eo(_t, Tn), Vt instanceof Rt) {
                                var Ar = It.ref.$indexes.get(Tn);
                                xi(_t, Ar);
                            }
                            Nn.$changes ? eo(_t, Nn.$changes.refId) : Jc[na](_t, Nn);
                        }
                    else if (Nn.$changes && !bt) {
                        if (zn(_t, $.OPERATION.ADD), eo(_t, Tn), Vt instanceof Rt) {
                            var Ar = It.ref.$indexes.get(Tn);
                            xi(_t, Ar);
                        }
                        eo(_t, Nn.$changes.refId);
                    }
                } }, $t = 0; $t < Ft; $t++)
                    qt($t); return _t; }, N.prototype.clone = function () { var _, P = new this.constructor, ne = this._definition.schema; for (var xe in ne)
                    typeof this[xe] == "object" && typeof ((_ = this[xe]) === null || _ === void 0 ? void 0 : _.clone) == "function" ? P[xe] = this[xe].clone() : P[xe] = this[xe]; return P; }, N.prototype.toJSON = function () { var _ = this._definition.schema, P = this._definition.deprecated, ne = {}; for (var xe in _)
                    !P[xe] && this[xe] !== null && typeof this[xe] < "u" && (ne[xe] = typeof this[xe].toJSON == "function" ? this[xe].toJSON() : this["_".concat(xe)]); return ne; }, N.prototype.discardAllChanges = function () { this.$changes.discardAll(); }, N.prototype.getByIndex = function (_) { return this[this._definition.fieldsByIndex[_]]; }, N.prototype.deleteByIndex = function (_) { this[this._definition.fieldsByIndex[_]] = void 0; }, N.prototype.tryEncodeTypeId = function (_, P, ne) { P._typeid !== ne._typeid && (zn(_, J), eo(_, ne._typeid)); }, N.prototype.getSchemaType = function (_, P, ne) { var xe; return _[P.offset] === J && (P.offset++, xe = this.constructor._context.get(fs(_, P))), xe || ne; }, N.prototype.createTypeInstance = function (_) { var P = new _; return P.$changes.root = this.$changes.root, P; }, N.prototype._triggerChanges = function (_) { for (var P, ne, xe, Ze, mt, xt, Ut, Ft, _t, qt = new Set, $t = this.$changes.root.refs, Ht = function (Vt) { var bt = _[Vt], Kt = bt.refId, Qt = $t.get(Kt), mn = Qt.$callbacks; if ((bt.op & $.OPERATION.DELETE) === $.OPERATION.DELETE && bt.previousValue instanceof N && ((ne = (P = bt.previousValue.$callbacks) === null || P === void 0 ? void 0 : P[$.OPERATION.DELETE]) === null || ne === void 0 || ne.forEach(function (Gt) { return Gt(); })), !mn)
                    return "continue"; if (Qt instanceof N) {
                    if (!qt.has(Kt))
                        try {
                            (xe = mn == null ? void 0 : mn[$.OPERATION.REPLACE]) === null || xe === void 0 || xe.forEach(function (Gt) { return Gt(_); });
                        }
                        catch (Gt) {
                            N.onError(Gt);
                        }
                    try {
                        mn.hasOwnProperty(bt.field) && ((Ze = mn[bt.field]) === null || Ze === void 0 || Ze.forEach(function (Gt) { return Gt(bt.value, bt.previousValue); }));
                    }
                    catch (Gt) {
                        N.onError(Gt);
                    }
                }
                else
                    bt.op === $.OPERATION.ADD && bt.previousValue === void 0 ? (mt = mn[$.OPERATION.ADD]) === null || mt === void 0 || mt.forEach(function (Gt) { var jt; return Gt(bt.value, (jt = bt.dynamicIndex) !== null && jt !== void 0 ? jt : bt.field); }) : bt.op === $.OPERATION.DELETE ? bt.previousValue !== void 0 && ((xt = mn[$.OPERATION.DELETE]) === null || xt === void 0 || xt.forEach(function (Gt) { var jt; return Gt(bt.previousValue, (jt = bt.dynamicIndex) !== null && jt !== void 0 ? jt : bt.field); })) : bt.op === $.OPERATION.DELETE_AND_ADD && (bt.previousValue !== void 0 && ((Ut = mn[$.OPERATION.DELETE]) === null || Ut === void 0 || Ut.forEach(function (Gt) { var jt; return Gt(bt.previousValue, (jt = bt.dynamicIndex) !== null && jt !== void 0 ? jt : bt.field); })), (Ft = mn[$.OPERATION.ADD]) === null || Ft === void 0 || Ft.forEach(function (Gt) { var jt; return Gt(bt.value, (jt = bt.dynamicIndex) !== null && jt !== void 0 ? jt : bt.field); })), bt.value !== bt.previousValue && ((_t = mn[$.OPERATION.REPLACE]) === null || _t === void 0 || _t.forEach(function (Gt) { var jt; return Gt(bt.value, (jt = bt.dynamicIndex) !== null && jt !== void 0 ? jt : bt.field); })); qt.add(Kt); }, It = 0; It < _.length; It++)
                    Ht(It); }, N._definition = zt.create(), N; }();
                function n_(N) { for (var _ = [N.$changes], P = 1, ne = {}, xe = ne, Ze = function (xt) { var Ut = _[xt]; Ut.changes.forEach(function (Ft) { var _t = Ut.ref, qt = Ft.index, $t = _t._definition ? _t._definition.fieldsByIndex[qt] : _t.$indexes.get(qt); xe[$t] = Ut.getValue(qt); }); }, mt = 0; mt < P; mt++)
                    Ze(mt); return ne; }
                var ps = { context: new Mn }, od = function (N) { H(_, N); function _() { return N !== null && N.apply(this, arguments) || this; } return ue([cn("string", ps)], _.prototype, "name", void 0), ue([cn("string", ps)], _.prototype, "type", void 0), ue([cn("number", ps)], _.prototype, "referencedType", void 0), _; }(go), rd = function (N) { H(_, N); function _() { var P = N !== null && N.apply(this, arguments) || this; return P.fields = new ut, P; } return ue([cn("number", ps)], _.prototype, "id", void 0), ue([cn([od], ps)], _.prototype, "fields", void 0), _; }(go), o_ = function (N) { H(_, N); function _() { var P = N !== null && N.apply(this, arguments) || this; return P.types = new ut, P; } return _.encode = function (P) { var ne = P.constructor, xe = new _; xe.rootType = ne._typeid; var Ze = function (Ft, _t) { for (var qt in _t) {
                    var $t = new od;
                    $t.name = qt;
                    var Ht = void 0;
                    if (typeof _t[qt] == "string")
                        Ht = _t[qt];
                    else {
                        var It = _t[qt], Vt = void 0;
                        go.is(It) ? (Ht = "ref", Vt = _t[qt]) : (Ht = Object.keys(It)[0], typeof It[Ht] == "string" ? Ht += ":" + It[Ht] : Vt = It[Ht]), $t.referencedType = Vt ? Vt._typeid : -1;
                    }
                    $t.type = Ht, Ft.fields.push($t);
                } xe.types.push(Ft); }, mt = ne._context.types; for (var xt in mt) {
                    var Ut = new rd;
                    Ut.id = Number(xt), Ze(Ut, mt[xt]._definition.schema);
                } return xe.encodeAll(); }, _.decode = function (P, ne) { var xe = new Mn, Ze = new _; Ze.decode(P, ne); var mt = Ze.types.reduce(function (qt, $t) { var Ht = function (Vt) { H(bt, Vt); function bt() { return Vt !== null && Vt.apply(this, arguments) || this; } return bt; }(go), It = $t.id; return qt[It] = Ht, xe.add(Ht, It), qt; }, {}); Ze.types.forEach(function (qt) { var $t = mt[qt.id]; qt.fields.forEach(function (Ht) { var It; if (Ht.referencedType !== void 0) {
                    var Vt = Ht.type, bt = mt[Ht.referencedType];
                    if (!bt) {
                        var Kt = Ht.type.split(":");
                        Vt = Kt[0], bt = Kt[1];
                    }
                    Vt === "ref" ? cn(bt, { context: xe })($t.prototype, Ht.name) : cn((It = {}, It[Vt] = bt, It), { context: xe })($t.prototype, Ht.name);
                }
                else
                    cn(Ht.type, { context: xe })($t.prototype, Ht.name); }); }); var xt = mt[Ze.rootType], Ut = new xt; for (var Ft in xt._definition.schema) {
                    var _t = xt._definition.schema[Ft];
                    typeof _t != "string" && (Ut[Ft] = typeof _t == "function" ? new _t : new (wt(Object.keys(_t)[0])).constructor);
                } return Ut; }, ue([cn([rd], ps)], _.prototype, "types", void 0), ue([cn("number", ps)], _.prototype, "rootType", void 0), _; }(go);
                ot("map", { constructor: Rt }), ot("array", { constructor: ut }), ot("set", { constructor: td }), ot("collection", { constructor: ed }), $.ArraySchema = ut, $.CollectionSchema = ed, $.Context = Mn, $.MapSchema = Rt, $.Reflection = o_, $.ReflectionField = od, $.ReflectionType = rd, $.Schema = go, $.SchemaDefinition = zt, $.SetSchema = td, $.decode = Tv, $.defineTypes = RS, $.deprecated = PS, $.dumpChanges = n_, $.encode = Jc, $.filter = ir, $.filterChildren = NS, $.hasFilter = Qn, $.registerType = ot, $.type = cn, Object.defineProperty($, "__esModule", { value: !0 });
            });
        }), re = function () { function W(X, $) { var Y = this; this.onStateChange = fe(), this.onError = fe(), this.onLeave = fe(), this.onJoin = fe(), this.hasJoined = !1, this.onMessageHandlers = le(), this.roomId = null, this.name = X, $ && (this.serializer = new (me("schema")), this.rootSchema = $, this.serializer.state = new $), this.onError(function (H, ue) { return console.warn("colyseus.js - onError => (".concat(H, ") ").concat(ue)); }), this.onLeave(function () { return Y.removeAllListeners(); }); } return Object.defineProperty(W.prototype, "id", { get: function () { return this.roomId; }, enumerable: !1, configurable: !0 }), W.prototype.connect = function (X, $, Y) { Y === void 0 && (Y = this); var H = new se; Y.connection = H, H.events.onmessage = W.prototype.onMessageCallback.bind(Y), H.events.onclose = function (ue) { if (!Y.hasJoined) {
            console.warn("Room connection was closed unexpectedly (".concat(ue.code, "): ").concat(ue.reason)), Y.onError.invoke(ue.code, ue.reason);
            return;
        } ue.code === x.DEVMODE_RESTART && $ ? $() : (Y.onLeave.invoke(ue.code), Y.destroy()); }, H.events.onerror = function (ue) { console.warn("Room, onError (".concat(ue.code, "): ").concat(ue.reason)), Y.onError.invoke(ue.code, ue.reason); }, H.connect(X); }, W.prototype.leave = function (X) { var $ = this; return X === void 0 && (X = !0), new Promise(function (Y) { $.onLeave(function (H) { return Y(H); }), $.connection ? X ? $.connection.send([n.Protocol.LEAVE_ROOM]) : $.connection.close() : $.onLeave.invoke(x.CONSENTED); }); }, W.prototype.onMessage = function (X, $) { return this.onMessageHandlers.on(this.getMessageHandlerKey(X), $); }, W.prototype.send = function (X, $) { var Y = [n.Protocol.ROOM_DATA]; typeof X == "string" ? q.encode.string(Y, X) : q.encode.number(Y, X); var H; if ($ !== void 0) {
            var ue = D($);
            H = new Uint8Array(Y.length + ue.byteLength), H.set(new Uint8Array(Y), 0), H.set(new Uint8Array(ue), Y.length);
        }
        else
            H = new Uint8Array(Y); this.connection.send(H.buffer); }, W.prototype.sendBytes = function (X, $) { var Y = [n.Protocol.ROOM_DATA_BYTES]; typeof X == "string" ? q.encode.string(Y, X) : q.encode.number(Y, X); var H; H = new Uint8Array(Y.length + ($.byteLength || $.length)), H.set(new Uint8Array(Y), 0), H.set(new Uint8Array($), Y.length), this.connection.send(H.buffer); }, Object.defineProperty(W.prototype, "state", { get: function () { return this.serializer.getState(); }, enumerable: !1, configurable: !0 }), W.prototype.removeAllListeners = function () { this.onJoin.clear(), this.onStateChange.clear(), this.onError.clear(), this.onLeave.clear(), this.onMessageHandlers.events = {}; }, W.prototype.onMessageCallback = function (X) { var $ = Array.from(new Uint8Array(X.data)), Y = $[0]; if (Y === n.Protocol.JOIN_ROOM) {
            var H = 1, ue = Z($, H);
            if (H += ce(ue), this.serializerId = Z($, H), H += ce(this.serializerId), !this.serializer) {
                var de = me(this.serializerId);
                this.serializer = new de;
            }
            $.length > H && this.serializer.handshake && this.serializer.handshake($, { offset: H }), this.reconnectionToken = "".concat(this.roomId, ":").concat(ue), this.hasJoined = !0, this.onJoin.invoke(), this.connection.send([n.Protocol.JOIN_ROOM]);
        }
        else if (Y === n.Protocol.ERROR) {
            var be = { offset: 1 }, J = q.decode.number($, be), we = q.decode.string($, be);
            this.onError.invoke(J, we);
        }
        else if (Y === n.Protocol.LEAVE_ROOM)
            this.leave();
        else if (Y === n.Protocol.ROOM_DATA_SCHEMA) {
            var Ke = { offset: 1 }, rt = this.serializer.getState().constructor._context, _e = rt.get(q.decode.number($, Ke)), we = new _e;
            we.decode($, Ke), this.dispatchMessage(_e, we);
        }
        else if (Y === n.Protocol.ROOM_STATE)
            $.shift(), this.setState($);
        else if (Y === n.Protocol.ROOM_STATE_PATCH)
            $.shift(), this.patch($);
        else if (Y === n.Protocol.ROOM_DATA) {
            var ze = { offset: 1 }, _e = q.decode.stringCheck($, ze) ? q.decode.string($, ze) : q.decode.number($, ze), we = $.length > ze.offset ? F(X.data, ze.offset) : void 0;
            this.dispatchMessage(_e, we);
        }
        else if (Y === n.Protocol.ROOM_DATA_BYTES) {
            var We = { offset: 1 }, _e = q.decode.stringCheck($, We) ? q.decode.string($, We) : q.decode.number($, We);
            this.dispatchMessage(_e, new Uint8Array($.slice(We.offset)));
        } }, W.prototype.setState = function (X) { this.serializer.setState(X), this.onStateChange.invoke(this.serializer.getState()); }, W.prototype.patch = function (X) { this.serializer.patch(X), this.onStateChange.invoke(this.serializer.getState()); }, W.prototype.dispatchMessage = function (X, $) { var Y = this.getMessageHandlerKey(X); this.onMessageHandlers.events[Y] ? this.onMessageHandlers.emit(Y, $) : this.onMessageHandlers.events["*"] ? this.onMessageHandlers.emit("*", X, $) : console.warn("colyseus.js: onMessage() not registered for type '".concat(X, "'.")); }, W.prototype.destroy = function () { this.serializer && this.serializer.teardown(); }, W.prototype.getMessageHandlerKey = function (X) { switch (typeof X) {
            case "function": return "$".concat(X._typeid);
            case "string": return X;
            case "number": return "i".concat(X);
            default: throw new Error("invalid message type.");
        } }, W; }(), he, Ee = function (W) { s(X, W); function X($, Y) { var H = W.call(this, $) || this; return H.code = Y, Object.setPrototypeOf(H, X.prototype), H; } return X; }(Error), Ne = typeof window < "u" && typeof ((he = window == null ? void 0 : window.location) === null || he === void 0 ? void 0 : he.hostname) < "u" ? "".concat(window.location.protocol.replace("http", "ws"), "//").concat(window.location.hostname).concat(window.location.port && ":".concat(window.location.port)) : "ws://127.0.0.1:2567", Se = function () { function W(X) { if (X === void 0 && (X = Ne), typeof X == "string") {
            var $ = new URL(X), Y = $.protocol === "https:" || $.protocol === "wss:", H = Number($.port || (Y ? 443 : 80));
            this.settings = { hostname: $.hostname, pathname: $.pathname !== "/" ? $.pathname : "", port: H, secure: Y };
        }
        else
            X.port === void 0 && (X.port = X.secure ? 443 : 80), X.pathname === void 0 && (X.pathname = ""), this.settings = X; } return W.prototype.joinOrCreate = function (X, $, Y) { return $ === void 0 && ($ = {}), l(this, void 0, void 0, function () { return a(this, function (H) { switch (H.label) {
            case 0: return [4, this.createMatchMakeRequest("joinOrCreate", X, $, Y)];
            case 1: return [2, H.sent()];
        } }); }); }, W.prototype.create = function (X, $, Y) { return $ === void 0 && ($ = {}), l(this, void 0, void 0, function () { return a(this, function (H) { switch (H.label) {
            case 0: return [4, this.createMatchMakeRequest("create", X, $, Y)];
            case 1: return [2, H.sent()];
        } }); }); }, W.prototype.join = function (X, $, Y) { return $ === void 0 && ($ = {}), l(this, void 0, void 0, function () { return a(this, function (H) { switch (H.label) {
            case 0: return [4, this.createMatchMakeRequest("join", X, $, Y)];
            case 1: return [2, H.sent()];
        } }); }); }, W.prototype.joinById = function (X, $, Y) { return $ === void 0 && ($ = {}), l(this, void 0, void 0, function () { return a(this, function (H) { switch (H.label) {
            case 0: return [4, this.createMatchMakeRequest("joinById", X, $, Y)];
            case 1: return [2, H.sent()];
        } }); }); }, W.prototype.reconnect = function (X, $) { return l(this, void 0, void 0, function () { var Y, H, ue; return a(this, function (de) { switch (de.label) {
            case 0:
                if (typeof X == "string" && typeof $ == "string")
                    throw new Error("DEPRECATED: .reconnect() now only accepts 'reconnectionToken' as argument.\nYou can get this token from previously connected `room.reconnectionToken`");
                return Y = X.split(":"), H = Y[0], ue = Y[1], [4, this.createMatchMakeRequest("reconnect", H, { reconnectionToken: ue }, $)];
            case 1: return [2, de.sent()];
        } }); }); }, W.prototype.getAvailableRooms = function (X) { return X === void 0 && (X = ""), l(this, void 0, void 0, function () { return a(this, function ($) { switch ($.label) {
            case 0: return [4, g(this.getHttpEndpoint("".concat(X)), { headers: { Accept: "application/json" } })];
            case 1: return [2, $.sent().data];
        } }); }); }, W.prototype.consumeSeatReservation = function (X, $, Y) { return l(this, void 0, void 0, function () { var H, ue, de, be = this; return a(this, function (J) { return H = this.createRoom(X.room.name, $), H.roomId = X.room.roomId, H.sessionId = X.sessionId, ue = { sessionId: H.sessionId }, X.reconnectionToken && (ue.reconnectionToken = X.reconnectionToken), de = Y || H, H.connect(this.buildEndpoint(X.room, ue), X.devMode && function () { return l(be, void 0, void 0, function () { var we, Ke, rt, _e = this; return a(this, function (ze) { return console.info("[Colyseus devMode]: ".concat(String.fromCodePoint(128260), " Re-establishing connection with room id '").concat(H.roomId, "'...")), we = 0, Ke = 8, rt = function () { return l(_e, void 0, void 0, function () { return a(this, function (We) { switch (We.label) {
            case 0: we++, We.label = 1;
            case 1: return We.trys.push([1, 3, , 4]), [4, this.consumeSeatReservation(X, $, de)];
            case 2: return We.sent(), console.info("[Colyseus devMode]: ".concat(String.fromCodePoint(9989), " Successfully re-established connection with room '").concat(H.roomId, "'")), [3, 4];
            case 3: return We.sent(), we < Ke ? (console.info("[Colyseus devMode]: ".concat(String.fromCodePoint(128260), " retrying... (").concat(we, " out of ").concat(Ke, ")")), setTimeout(rt, 2e3)) : console.info("[Colyseus devMode]: ".concat(String.fromCodePoint(10060), " Failed to reconnect. Is your server running? Please check server logs.")), [3, 4];
            case 4: return [2];
        } }); }); }, setTimeout(rt, 2e3), [2]; }); }); }, de), [2, new Promise(function (we, Ke) { var rt = function (_e, ze) { return Ke(new I(_e, ze)); }; de.onError.once(rt), de.onJoin.once(function () { de.onError.remove(rt), we(de); }); })]; }); }); }, W.prototype.createMatchMakeRequest = function (X, $, Y, H, ue) { return Y === void 0 && (Y = {}), l(this, void 0, void 0, function () { var de; return a(this, function (be) { switch (be.label) {
            case 0: return [4, C(this.getHttpEndpoint("".concat(X, "/").concat($)), { headers: { Accept: "application/json", "Content-Type": "application/json" }, body: JSON.stringify(Y) })];
            case 1:
                if (de = be.sent().data, de.error)
                    throw new Ee(de.error, de.code);
                return X === "reconnect" && (de.reconnectionToken = Y.reconnectionToken), [4, this.consumeSeatReservation(de, H, ue)];
            case 2: return [2, be.sent()];
        } }); }); }, W.prototype.createRoom = function (X, $) { return new re(X, $); }, W.prototype.buildEndpoint = function (X, $) { $ === void 0 && ($ = {}); var Y = []; for (var H in $)
            $.hasOwnProperty(H) && Y.push("".concat(H, "=").concat($[H])); var ue = this.settings.secure ? "wss://" : "ws://"; return X.publicAddress ? ue += "".concat(X.publicAddress) : ue += "".concat(this.settings.hostname).concat(this.getEndpointPort()).concat(this.settings.pathname), "".concat(ue, "/").concat(X.processId, "/").concat(X.roomId, "?").concat(Y.join("&")); }, W.prototype.getHttpEndpoint = function (X) { return X === void 0 && (X = ""), "".concat(this.settings.secure ? "https" : "http", "://").concat(this.settings.hostname).concat(this.getEndpointPort()).concat(this.settings.pathname, "/matchmake/").concat(X); }, W.prototype.getEndpointPort = function () { return this.settings.port !== 80 && this.settings.port !== 443 ? ":".concat(this.settings.port) : ""; }, W; }(), De;
        function Me() { return De || (De = typeof cc < "u" && cc.sys && cc.sys.localStorage ? cc.sys.localStorage : typeof window < "u" && window.localStorage ? window.localStorage : { cache: {}, setItem: function (W, X) { this.cache[W] = X; }, getItem: function (W) { this.cache[W]; }, removeItem: function (W) { delete this.cache[W]; } }), De; }
        function $e(W, X) { Me().setItem(W, X); }
        function Pe(W) { Me().removeItem(W); }
        function He(W, X) { var $ = Me().getItem(W); typeof Promise > "u" || !($ instanceof Promise) ? X($) : $.then(function (Y) { return X(Y); }); }
        var je = "colyseus-auth-token";
        n.Platform = void 0, function (W) { W.ios = "ios", W.android = "android"; }(n.Platform || (n.Platform = {}));
        var Ue = function () { function W(X) { var $ = this; this._id = void 0, this.username = void 0, this.displayName = void 0, this.avatarUrl = void 0, this.isAnonymous = void 0, this.email = void 0, this.lang = void 0, this.location = void 0, this.timezone = void 0, this.metadata = void 0, this.devices = void 0, this.facebookId = void 0, this.twitterId = void 0, this.googleId = void 0, this.gameCenterId = void 0, this.steamId = void 0, this.friendIds = void 0, this.blockedUserIds = void 0, this.createdAt = void 0, this.updatedAt = void 0, this.token = void 0, this.endpoint = X.replace("ws", "http"), He(je, function (Y) { return $.token = Y; }); } return Object.defineProperty(W.prototype, "hasToken", { get: function () { return !!this.token; }, enumerable: !1, configurable: !0 }), W.prototype.login = function (X) { return X === void 0 && (X = {}), l(this, void 0, void 0, function () { var $, Y, H; return a(this, function (ue) { switch (ue.label) {
            case 0: return $ = Object.assign({}, X), this.hasToken && ($.token = this.token), [4, this.request("post", "/auth", $)];
            case 1:
                Y = ue.sent(), this.token = Y.token, $e(je, this.token);
                for (H in Y)
                    this.hasOwnProperty(H) && (this[H] = Y[H]);
                return this.registerPingService(), [2, this];
        } }); }); }, W.prototype.save = function () { return l(this, void 0, void 0, function () { return a(this, function (X) { switch (X.label) {
            case 0: return [4, this.request("put", "/auth", {}, { username: this.username, displayName: this.displayName, avatarUrl: this.avatarUrl, lang: this.lang, location: this.location, timezone: this.timezone })];
            case 1: return X.sent(), [2, this];
        } }); }); }, W.prototype.getFriends = function () { return l(this, void 0, void 0, function () { return a(this, function (X) { switch (X.label) {
            case 0: return [4, this.request("get", "/friends/all")];
            case 1: return [2, X.sent()];
        } }); }); }, W.prototype.getOnlineFriends = function () { return l(this, void 0, void 0, function () { return a(this, function (X) { switch (X.label) {
            case 0: return [4, this.request("get", "/friends/online")];
            case 1: return [2, X.sent()];
        } }); }); }, W.prototype.getFriendRequests = function () { return l(this, void 0, void 0, function () { return a(this, function (X) { switch (X.label) {
            case 0: return [4, this.request("get", "/friends/requests")];
            case 1: return [2, X.sent()];
        } }); }); }, W.prototype.sendFriendRequest = function (X) { return l(this, void 0, void 0, function () { return a(this, function ($) { switch ($.label) {
            case 0: return [4, this.request("post", "/friends/requests", { userId: X })];
            case 1: return [2, $.sent()];
        } }); }); }, W.prototype.acceptFriendRequest = function (X) { return l(this, void 0, void 0, function () { return a(this, function ($) { switch ($.label) {
            case 0: return [4, this.request("put", "/friends/requests", { userId: X })];
            case 1: return [2, $.sent()];
        } }); }); }, W.prototype.declineFriendRequest = function (X) { return l(this, void 0, void 0, function () { return a(this, function ($) { switch ($.label) {
            case 0: return [4, this.request("del", "/friends/requests", { userId: X })];
            case 1: return [2, $.sent()];
        } }); }); }, W.prototype.blockUser = function (X) { return l(this, void 0, void 0, function () { return a(this, function ($) { switch ($.label) {
            case 0: return [4, this.request("post", "/friends/block", { userId: X })];
            case 1: return [2, $.sent()];
        } }); }); }, W.prototype.unblockUser = function (X) { return l(this, void 0, void 0, function () { return a(this, function ($) { switch ($.label) {
            case 0: return [4, this.request("put", "/friends/block", { userId: X })];
            case 1: return [2, $.sent()];
        } }); }); }, W.prototype.request = function (X, $, Y, H, ue) { return Y === void 0 && (Y = {}), ue === void 0 && (ue = {}), l(this, void 0, void 0, function () { var de, be, J, we; return a(this, function (Ke) { switch (Ke.label) {
            case 0:
                ue.Accept = "application/json", this.hasToken && (ue.Authorization = "Bearer " + this.token), de = [];
                for (be in Y)
                    de.push("".concat(be, "=").concat(Y[be]));
                return J = de.length > 0 ? "?".concat(de.join("&")) : "", we = { headers: ue }, H && (we.body = H), [4, E[X]("".concat(this.endpoint).concat($).concat(J), we)];
            case 1: return [2, Ke.sent().data];
        } }); }); }, W.prototype.logout = function () { this.token = void 0, Pe(je), this.unregisterPingService(); }, W.prototype.registerPingService = function (X) { var $ = this; X === void 0 && (X = 15e3), this.unregisterPingService(), this.keepOnlineInterval = setInterval(function () { return $.request("get", "/auth"); }, X); }, W.prototype.unregisterPingService = function () { clearInterval(this.keepOnlineInterval); }, W; }(), Te = function () { function W() { } return W.prototype.setState = function (X) { return this.state.decode(X); }, W.prototype.getState = function () { return this.state; }, W.prototype.patch = function (X) { return this.state.decode(X); }, W.prototype.teardown = function () { var X, $; ($ = (X = this.state) === null || X === void 0 ? void 0 : X.$changes) === null || $ === void 0 || $.root.clearRefs(); }, W.prototype.handshake = function (X, $) { if (this.state) {
            var Y = new q.Reflection;
            Y.decode(X, $);
        }
        else
            this.state = q.Reflection.decode(X, $); }, W; }(), Ge = function () { function W() { } return W.prototype.setState = function (X) { }, W.prototype.getState = function () { return null; }, W.prototype.patch = function (X) { }, W.prototype.teardown = function () { }, W.prototype.handshake = function (X) { }, W; }();
        Re("schema", Te), Re("none", Ge), n.Auth = Ue, n.Client = Se, n.Room = re, n.SchemaSerializer = Te, n.registerSerializer = Re, Object.defineProperty(n, "__esModule", { value: !0 });
    });
})(hp, hp.exports);
var Uee = hp.exports;
const qee = { class: "chat-app" }, Yee = { class: "chat-messages" }, Gee = { key: 0, class: "massagebox" }, Xee = { key: 0, class: "textbox" }, Jee = { key: 1, class: "ai-textbox" }, Zee = { class: "chat-input" }, Qee = ae({ __name: "TheWelcome", setup(e) { const t = Lt({ circleUrl: "https://cube.elemecdn.com/3/7c/3ea6beec64369c2642b92c6726f1epng.png", squareUrl: "https://cube.elemecdn.com/9/c2/f0ee8a3c7c9638a54940382568c9dpng.png", sizeList: ["small", "", "large"] }), { squareUrl: n } = Sn(t), o = M(""), r = M([]), s = new Uee.Client("ws://" + location.host.split(":")[0] + ":8080"); let l; ft(async () => { s.getAvailableRooms("my_room").then(u => { u.forEach(c => { console.log(c.roomId), console.log(c.clients), console.log(c.maxClients), console.log(c.metadata); }); }).catch(u => { console.error(u); }); try {
        l = await s.joinOrCreate("my_room", {}), console.log("joined successfully", l), l.onMessage("type", u => { console.log("message received from server"), console.log(u), r.value.push(u); });
    }
    catch (u) {
        console.error("join error", u);
    } }); const a = async () => { l.send("type", o.value); }; return (u, c) => { const d = ct("el-avatar"), f = ct("el-text"), p = ct("el-col"), v = ct("el-row"); return k(), z("div", qee, [Q("div", Yee, [(k(!0), z(Qe, null, Et(r.value, (m, h) => (k(), z("div", { key: h }, [m.user != "ChatGPT" ? (k(), z("div", Gee, [ee(d, { shape: "square", size: "small", src: i(n) }, null, 8, ["src"]), m.user != "ChatGPT" ? (k(), z("div", Xee, [ee(f, { class: "text" }, { default: ie(() => [Ot(Be(m.message), 1)]), _: 2 }, 1024)])) : pe("", !0)])) : (k(), z("div", Jee, [ee(f, { class: "ai-text" }, { default: ie(() => [Ot(Be(m.message), 1)]), _: 2 }, 1024)]))]))), 128))]), Q("div", Zee, [ee(v, { gutter: 10 }, { default: ie(() => [ee(p, { span: 21 }, { default: ie(() => [ee(i(Ln), { modelValue: o.value, "onUpdate:modelValue": c[0] || (c[0] = m => o.value = m), placeholder: "Type a message..." }, null, 8, ["modelValue"])]), _: 1 }), ee(p, { span: 3 }, { default: ie(() => [ee(i(xn), { type: "primary", onClick: a }, { default: ie(() => [Ot("Send")]), _: 1 })]), _: 1 })]), _: 1 })])]); }; } });
const pv = (e, t) => { const n = e.__vccOpts || e; for (const [o, r] of t)
    n[o] = r; return n; }, ete = pv(Qee, [["__scopeId", "data-v-742d6191"]]), tte = ae({ __name: "HomeView", setup(e) { return (t, n) => (k(), z("main", null, [ee(ete)])); } }), nte = N$({ history: JE("/"), routes: [{ path: "/", name: "home", component: tte }, { path: "/about", name: "about", component: () => NE(() => Promise.resolve().then(() => __importStar(require("./AboutView-1cb87b7b.js"))), ["assets/AboutView-1cb87b7b.js", "assets/AboutView-4d995ba2.css"]) }] });
exports._ = pv;
const ote = e => (rk("data-v-05aa4362"), e = e(), sk(), e), rte = { class: "greetings" }, ste = { class: "green" }, lte = ote(() => Q("h3", null, " A experimental multiplayer AI Dungeon game. Powered by langchain and Vue 3. ", -1)), ate = ae({ __name: "HelloWorld", props: { msg: {} }, setup(e) { return (t, n) => (k(), z("div", rte, [Q("h1", ste, Be(t.msg), 1), lte])); } });
const ite = pv(ate, [["__scopeId", "data-v-05aa4362"]]), ute = { class: "wrapper" }, cte = { class: "chat-window" }, dte = ae({ __name: "App", setup(e) { return (t, n) => (k(), z(Qe, null, [Q("header", null, [Q("div", ute, [ee(ite, { msg: "Ai Dungeon Online" }), Q("nav", null, [ee(i(lf), { to: "/" }, { default: ie(() => [Ot("Server")]), _: 1 }), ee(i(lf), { to: "/about" }, { default: ie(() => [Ot("Profile")]), _: 1 })])])]), Q("div", cte, [ee(i(Fb))])], 64)); } });
const fte = pv(dte, [["__scopeId", "data-v-350d0407"]]), hv = Tb(fte);
hv.use(Wee);
hv.use(nte);
hv.mount("#app");
